{
  "categories": [
    {
      "id": "arrays-and-hashing",
      "displayName": "Arrays & Hashing",
      "slug": "arrays-and-hashing",
      "colorHex": "#FF6B35",
      "order": 1,
      "prerequisites": [],
      "description": "Master the fundamentals of arrays and hash-based data structures for O(1) lookups."
    },
    {
      "id": "two-pointers",
      "displayName": "Two Pointers",
      "slug": "two-pointers",
      "colorHex": "#4ECDC4",
      "order": 2,
      "prerequisites": [
        "arrays-and-hashing"
      ],
      "description": "Learn to solve problems efficiently using the two-pointer technique."
    },
    {
      "id": "stack",
      "displayName": "Stack",
      "slug": "stack",
      "colorHex": "#45B7D1",
      "order": 3,
      "prerequisites": [
        "arrays-and-hashing"
      ],
      "description": "Understand LIFO data structure and its applications in parsing and backtracking."
    },
    {
      "id": "sliding-window",
      "displayName": "Sliding Window",
      "slug": "sliding-window",
      "colorHex": "#96CEB4",
      "order": 4,
      "prerequisites": [
        "two-pointers"
      ],
      "description": "Optimize subarray and substring problems with the sliding window pattern."
    },
    {
      "id": "binary-search",
      "displayName": "Binary Search",
      "slug": "binary-search",
      "colorHex": "#FFEAA7",
      "order": 5,
      "prerequisites": [
        "two-pointers"
      ],
      "description": "Divide and conquer with logarithmic time complexity."
    },
    {
      "id": "linked-list",
      "displayName": "Linked List",
      "slug": "linked-list",
      "colorHex": "#DDA0DD",
      "order": 6,
      "prerequisites": [
        "two-pointers"
      ],
      "description": "Navigate node-based data structures with pointer manipulation."
    },
    {
      "id": "trees",
      "displayName": "Trees",
      "slug": "trees",
      "colorHex": "#98D8C8",
      "order": 7,
      "prerequisites": [
        "binary-search",
        "sliding-window",
        "linked-list"
      ],
      "description": "Traverse and manipulate hierarchical data structures."
    },
    {
      "id": "tries",
      "displayName": "Tries",
      "slug": "tries",
      "colorHex": "#F7DC6F",
      "order": 8,
      "prerequisites": [
        "trees"
      ],
      "description": "Efficiently store and search strings with prefix trees."
    },
    {
      "id": "backtracking",
      "displayName": "Backtracking",
      "slug": "backtracking",
      "colorHex": "#BB8FCE",
      "order": 9,
      "prerequisites": [
        "trees"
      ],
      "description": "Explore all possibilities with systematic trial and error."
    },
    {
      "id": "heap",
      "displayName": "Heap / Priority Queue",
      "slug": "heap",
      "colorHex": "#85C1E9",
      "order": 10,
      "prerequisites": [
        "tries"
      ],
      "description": "Maintain priority with heap-based data structures."
    },
    {
      "id": "graphs",
      "displayName": "Graphs",
      "slug": "graphs",
      "colorHex": "#F8B500",
      "order": 11,
      "prerequisites": [
        "backtracking"
      ],
      "description": "Model relationships and connections between entities."
    },
    {
      "id": "advanced-graphs",
      "displayName": "Advanced Graphs",
      "slug": "advanced-graphs",
      "colorHex": "#FF6F61",
      "order": 12,
      "prerequisites": [
        "graphs"
      ],
      "description": "Master complex graph algorithms like shortest paths and minimum spanning trees."
    },
    {
      "id": "1d-dp",
      "displayName": "1-D DP",
      "slug": "1d-dp",
      "colorHex": "#6B5B95",
      "order": 13,
      "prerequisites": [
        "backtracking"
      ],
      "description": "Solve optimization problems with one-dimensional dynamic programming."
    },
    {
      "id": "2d-dp",
      "displayName": "2-D DP",
      "slug": "2d-dp",
      "colorHex": "#88B04B",
      "order": 14,
      "prerequisites": [
        "1d-dp"
      ],
      "description": "Tackle grid and matrix problems with two-dimensional DP."
    },
    {
      "id": "greedy",
      "displayName": "Greedy",
      "slug": "greedy",
      "colorHex": "#F7CAC9",
      "order": 15,
      "prerequisites": [
        "heap"
      ],
      "description": "Make locally optimal choices for globally optimal solutions."
    },
    {
      "id": "intervals",
      "displayName": "Intervals",
      "slug": "intervals",
      "colorHex": "#92A8D1",
      "order": 16,
      "prerequisites": [
        "heap"
      ],
      "description": "Handle overlapping ranges and scheduling problems."
    },
    {
      "id": "bit-manipulation",
      "displayName": "Bit Manipulation",
      "slug": "bit-manipulation",
      "colorHex": "#955251",
      "order": 17,
      "prerequisites": [
        "1d-dp"
      ],
      "description": "Leverage binary operations for space and time efficiency."
    },
    {
      "id": "math-and-geometry",
      "displayName": "Math & Geometry",
      "slug": "math-and-geometry",
      "colorHex": "#B565A7",
      "order": 18,
      "prerequisites": [
        "2d-dp"
      ],
      "description": "Apply mathematical concepts to algorithmic problems."
    }
  ],
  "problems": {
    "arrays-and-hashing": [
      {
        "id": "01-contains-duplicate",
        "slug": "contains-duplicate",
        "title": "Contains Duplicate",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "contains-duplicate"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.",
        "examples": [
          {
            "input": "nums = [1, 2, 3, 1]",
            "output": "true",
            "explanation": "1 appears twice"
          },
          {
            "input": "nums = [1, 2, 3, 4]",
            "output": "false",
            "explanation": "All elements are distinct"
          },
          {
            "input": "nums = [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What is the core operation you need to perform for each element?",
            "options": [
              {
                "id": "a",
                "text": "Compare it with the next element"
              },
              {
                "id": "b",
                "text": "Check if you've seen it before"
              },
              {
                "id": "c",
                "text": "Find its position in sorted order"
              },
              {
                "id": "d",
                "text": "Count how many times it appears"
              }
            ],
            "correct": "b",
            "explanation": "The problem asks if ANY value appears twice. You don't need counts, positions, or adjacent comparisons. You just need to know: seen or not seen.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "If you check each element against all previous elements, what's the time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "c",
            "explanation": "For each of n elements, you potentially scan all previous elements. First element: 0 comparisons, second: 1, third: 2, ... nth: n-1. Total: 0+1+2+...+(n-1) = n(n-1)/2 = O(n²)",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "What operation needs to be faster to improve the solution?",
            "options": [
              {
                "id": "a",
                "text": "Adding elements to the result"
              },
              {
                "id": "b",
                "text": "Checking if an element was seen before"
              },
              {
                "id": "c",
                "text": "Iterating through the array"
              },
              {
                "id": "d",
                "text": "Returning the result"
              }
            ],
            "correct": "b",
            "explanation": "Iteration is already O(n) - you must look at each element once. The bottleneck is that for each element, you're doing O(n) membership check. Make that O(1), and you get O(n) overall.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Which data structure provides O(1) average membership checking?",
            "options": [
              {
                "id": "a",
                "text": "Array"
              },
              {
                "id": "b",
                "text": "Linked List"
              },
              {
                "id": "c",
                "text": "Hash Set"
              },
              {
                "id": "d",
                "text": "Binary Search Tree"
              }
            ],
            "correct": "c",
            "explanation": "Hash sets use hashing to achieve O(1) average insert and lookup. Arrays need O(n) scan, linked lists need O(n) traversal, BSTs need O(log n) traversal.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Complete the algorithm:\n1. Create empty hash set\n2. For each number in array:\n   a. If number is in set → ___\n   b. If number is not in set → ___",
            "options": [
              {
                "id": "a",
                "text": "return false; add to set"
              },
              {
                "id": "b",
                "text": "return true; add to set"
              },
              {
                "id": "c",
                "text": "add to set; return true"
              },
              {
                "id": "d",
                "text": "add to set; return false"
              }
            ],
            "correct": "b",
            "explanation": "If you find the number already in the set, you've found a duplicate → return true immediately. Otherwise, add it to track it for future checks.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "What should the function return if the loop completes without finding a duplicate?",
            "options": [
              {
                "id": "a",
                "text": "true"
              },
              {
                "id": "b",
                "text": "false"
              },
              {
                "id": "c",
                "text": "null"
              },
              {
                "id": "d",
                "text": "-1"
              }
            ],
            "correct": "b",
            "explanation": "If you check every element and never find one already in the set, all elements are unique → no duplicate exists → return false.",
            "conceptId": "hash-set"
          }
        ],
        "oneLiner": "When you need to answer 'have I seen this before?' in O(1), use a hash set.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "The bottleneck is the \"have I seen this?\" lookup.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "contains duplicate",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def containsDuplicate(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False"
      },
      {
        "id": "02-valid-anagram",
        "slug": "valid-anagram",
        "title": "Valid Anagram",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "valid-anagram"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.\n\nAn **anagram** is a word formed by rearranging the letters of another word, using all the original letters exactly once.\n\n**Constraint:** `s` and `t` consist of lowercase English letters only.",
        "examples": [
          {
            "input": "s = \"anagram\", t = \"nagaram\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"rat\", t = \"car\"",
            "output": "false",
            "explanation": ""
          },
          {
            "input": "s = \"a\", t = \"a\"",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If two strings are anagrams, what must be true about their lengths?",
            "options": [
              {
                "id": "a",
                "text": "s must be longer than t"
              },
              {
                "id": "b",
                "text": "s must be shorter than t"
              },
              {
                "id": "c",
                "text": "Lengths must be equal"
              },
              {
                "id": "d",
                "text": "Length doesn't matter"
              }
            ],
            "correct": "c",
            "explanation": "Anagrams use all original letters exactly once. If lengths differ, one string has letters the other doesn't. This is a quick O(1) early exit check.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Two strings are anagrams if they have the same ___ for each character.",
            "options": [
              {
                "id": "a",
                "text": "Position"
              },
              {
                "id": "b",
                "text": "ASCII value"
              },
              {
                "id": "c",
                "text": "Frequency/count"
              },
              {
                "id": "d",
                "text": "Case"
              }
            ],
            "correct": "c",
            "explanation": "Order (position) doesn't matter - that's the whole point of anagrams. We only care that each letter appears the same number of times in both strings.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Which approach correctly checks if two strings are anagrams?",
            "options": [
              {
                "id": "a",
                "text": "Check if first characters match"
              },
              {
                "id": "b",
                "text": "Count character frequencies and compare"
              },
              {
                "id": "c",
                "text": "Check if strings are equal"
              },
              {
                "id": "d",
                "text": "Check if one is a substring of the other"
              }
            ],
            "correct": "b",
            "explanation": "We need to verify identical character counts. Direct equality check would fail (different order). Substring check is wrong concept entirely.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "What's the best way to store character frequencies?",
            "options": [
              {
                "id": "a",
                "text": "A linked list"
              },
              {
                "id": "b",
                "text": "An array of size 26 (for a-z)"
              },
              {
                "id": "c",
                "text": "A binary tree"
              },
              {
                "id": "d",
                "text": "A stack"
              }
            ],
            "correct": "b",
            "explanation": "Since we only have lowercase letters (a-z), a fixed-size array of 26 integers is perfect. Index 0 = 'a' count, index 1 = 'b' count, etc. Hash map also works but array is simpler and faster for fixed alphabet.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Which algorithm correctly determines if s and t are anagrams?",
            "options": [
              {
                "id": "a",
                "text": "Sort both strings, check if equal"
              },
              {
                "id": "b",
                "text": "Count chars in s, count chars in t, compare counts"
              },
              {
                "id": "c",
                "text": "For each char in s, check if it exists in t"
              },
              {
                "id": "d",
                "text": "Both A and B work"
              }
            ],
            "correct": "d",
            "explanation": "Both approaches work! Sorting: O(n log n) time, O(1) space if in-place. Counting: O(n) time, O(1) space for fixed alphabet. Option C doesn't account for frequency - \"aab\" would match \"ab\" incorrectly.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Instead of two count arrays, we can use one. How?",
            "options": [
              {
                "id": "a",
                "text": "Count s, then verify against t by decrementing"
              },
              {
                "id": "b",
                "text": "Count only the longer string"
              },
              {
                "id": "c",
                "text": "Count only vowels"
              },
              {
                "id": "d",
                "text": "This isn't possible"
              }
            ],
            "correct": "a",
            "explanation": "Build counts from s (increment). Then process t (decrement). If any count goes negative, t has a char that s doesn't have enough of → not anagram. If all counts are zero at end → anagram.",
            "conceptId": "frequency-count"
          }
        ],
        "oneLiner": "Anagram = same character frequencies. Count and compare.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "You don't care about order. You care about frequency.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "valid anagram",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    for c in t:\n        count[ord(c) - ord('a')] -= 1\n        if count[ord(c) - ord('a')] < 0:\n            return False\n    return True"
      },
      {
        "id": "03-two-sum",
        "slug": "two-sum",
        "title": "Two Sum",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "two-sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of integers `nums` and an integer `target`, return the **indices** of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.\n\nYou can return the answer in any order.",
        "examples": [
          {
            "input": "nums = [2, 7, 11, 15], target = 9",
            "output": "[0, 1]",
            "explanation": "nums[0] + nums[1] = 2 + 7 = 9"
          },
          {
            "input": "nums = [3, 2, 4], target = 6",
            "output": "[1, 2]",
            "explanation": "nums[1] + nums[2] = 2 + 4 = 6"
          },
          {
            "input": "nums = [3, 3], target = 6",
            "output": "[0, 1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If the target is 9 and the current number is 4, what specific value are you looking for?",
            "options": [
              {
                "id": "a",
                "text": "Any number greater than 4"
              },
              {
                "id": "b",
                "text": "Any number less than 9"
              },
              {
                "id": "c",
                "text": "The number 5"
              },
              {
                "id": "d",
                "text": "The number 4"
              }
            ],
            "correct": "c",
            "explanation": "If current = 4 and target = 9, the complement is 9 - 4 = 5. We're not looking for \"some number\" - we're looking for exactly 5.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "For each number in the array, the main operation is:",
            "options": [
              {
                "id": "a",
                "text": "Compare with adjacent elements"
              },
              {
                "id": "b",
                "text": "Check if its complement exists in what we've seen"
              },
              {
                "id": "c",
                "text": "Sort it into position"
              },
              {
                "id": "d",
                "text": "Count its occurrences"
              }
            ],
            "correct": "b",
            "explanation": "The key operation is complement lookup. \"Does (target - current) exist in our collection?\"",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Why is a hash map better than an array for storing seen numbers?",
            "options": [
              {
                "id": "a",
                "text": "Hash maps are always faster"
              },
              {
                "id": "b",
                "text": "Arrays can't store negative numbers"
              },
              {
                "id": "c",
                "text": "Hash map gives O(1) lookup by value"
              },
              {
                "id": "d",
                "text": "Arrays use more memory"
              }
            ],
            "correct": "c",
            "explanation": "We need to look up \"does value X exist?\" - this requires searching by value. Arrays give O(1) lookup by index, but O(n) lookup by value. Hash maps give O(1) lookup by key (the value itself).",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "The hash map should store:",
            "options": [
              {
                "id": "a",
                "text": "index → value"
              },
              {
                "id": "b",
                "text": "value → index"
              },
              {
                "id": "c",
                "text": "value → count"
              },
              {
                "id": "d",
                "text": "index → index"
              }
            ],
            "correct": "b",
            "explanation": "We search BY value (the complement) and we need to RETURN the index. So: key = value, stored data = index.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "For each number, which order is correct?",
            "options": [
              {
                "id": "a",
                "text": "Add to map, then check for complement"
              },
              {
                "id": "b",
                "text": "Check for complement, then add to map"
              },
              {
                "id": "c",
                "text": "Check for complement only"
              },
              {
                "id": "d",
                "text": "Add to map only"
              }
            ],
            "correct": "b",
            "explanation": "Check first, add second. If you add first, you might match a number with itself (when complement == current and they're the same element).",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Given nums = [3, 3], target = 6. Why does checking before adding work?",
            "options": [
              {
                "id": "a",
                "text": "It doesn't work for this case"
              },
              {
                "id": "b",
                "text": "First 3 is added, second 3 finds complement"
              },
              {
                "id": "c",
                "text": "Both 3s are added simultaneously"
              },
              {
                "id": "d",
                "text": "We need special handling for duplicates"
              }
            ],
            "correct": "b",
            "explanation": "Process first 3: check for 3 (not found), add 3→0. Process second 3: check for 3 (found at index 0!), return [0, 1]. The order ensures we don't match an element with itself.",
            "conceptId": "hash-map"
          }
        ],
        "oneLiner": "For pair problems, don't search for pairs. Calculate the complement and look it up.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "You're not searching for \"any pair.\" You're searching for a specific value.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "two sum",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def twoSum(nums: List[int], target: int) -> List[int]:\n    seen = {}  # value -> index\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []"
      },
      {
        "id": "04-group-anagrams",
        "slug": "group-anagrams",
        "title": "Group Anagrams",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "group-anagrams"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.",
        "examples": [
          {
            "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
            "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "explanation": ""
          },
          {
            "input": "strs = [\"\"]",
            "output": "[[\"\"]]",
            "explanation": ""
          },
          {
            "input": "strs = [\"a\"]",
            "output": "[[\"a\"]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What's the main challenge in grouping anagrams?",
            "options": [
              {
                "id": "a",
                "text": "Sorting the strings alphabetically"
              },
              {
                "id": "b",
                "text": "Finding a way to identify which strings are anagrams"
              },
              {
                "id": "c",
                "text": "Counting the total number of strings"
              },
              {
                "id": "d",
                "text": "Finding the longest string"
              }
            ],
            "correct": "b",
            "explanation": "We need a method to determine \"these strings belong together\" without comparing every pair (which would be O(n²)).",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "What property is IDENTICAL for all anagrams of the same word?",
            "options": [
              {
                "id": "a",
                "text": "Length only"
              },
              {
                "id": "b",
                "text": "First character"
              },
              {
                "id": "c",
                "text": "Sorted character sequence"
              },
              {
                "id": "d",
                "text": "Number of vowels"
              }
            ],
            "correct": "c",
            "explanation": "Sorting the characters produces the same result for all anagrams. \"eat\"→\"aet\", \"tea\"→\"aet\". This sorted form is called a **signature** - a canonical representation that's identical for all anagrams of the same word. Length is necessary but not sufficient (many non-anagrams have same length).",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "To group strings by their signature, what data structure is best?",
            "options": [
              {
                "id": "a",
                "text": "Array of arrays"
              },
              {
                "id": "b",
                "text": "Hash map: signature → list of strings"
              },
              {
                "id": "c",
                "text": "Set of strings"
              },
              {
                "id": "d",
                "text": "Queue"
              }
            ],
            "correct": "b",
            "explanation": "We need to map each signature to all strings that share it. Hash map gives O(1) lookup by signature, and stores the list of matching strings.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "What is the time complexity difference between sorted vs count signatures?",
            "options": [
              {
                "id": "a",
                "text": "Sorted is always better"
              },
              {
                "id": "b",
                "text": "Count is always better"
              },
              {
                "id": "c",
                "text": "Sorted: O(k log k) per string. Count: O(k) per string"
              },
              {
                "id": "d",
                "text": "They have identical performance"
              }
            ],
            "correct": "c",
            "explanation": "For string of length k, sorting is O(k log k), counting is O(k). For very long strings, counting is faster. For short strings, difference is negligible.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "After processing all strings, the hash map values are:",
            "options": [
              {
                "id": "a",
                "text": "The signatures"
              },
              {
                "id": "b",
                "text": "The groups of anagrams"
              },
              {
                "id": "c",
                "text": "The indices of strings"
              },
              {
                "id": "d",
                "text": "The counts of each group"
              }
            ],
            "correct": "b",
            "explanation": "The map is signature → [list of strings with that signature]. The values are exactly the groups we need to return.",
            "conceptId": "hash-map"
          }
        ],
        "oneLiner": "To group anagrams, use a canonical form (sorted or char-count) as hash key.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "All anagrams share the same \"signature.\"",
        "timeComplexity": "O(n * k log k)",
        "spaceComplexity": "O(n * k)",
        "triggerWords": [
          "group anagrams",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def groupAnagrams(strs: List[str]) -> List[List[str]]:\n    groups = defaultdict(list)\n    for s in strs:\n        # Use sorted string as signature\n        key = ''.join(sorted(s))\n        groups[key].append(s)\n    return list(groups.values())"
      },
      {
        "id": "05-top-k-frequent-elements",
        "slug": "top-k-frequent-elements",
        "title": "Top K Frequent Elements",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "top-k-frequent-elements"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.",
        "examples": [
          {
            "input": "nums = [1,1,1,2,2,3], k = 2",
            "output": "[1,2]",
            "explanation": ""
          },
          {
            "input": "nums = [1], k = 1",
            "output": "[1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What's the first thing you need to compute?",
            "options": [
              {
                "id": "a",
                "text": "The maximum element"
              },
              {
                "id": "b",
                "text": "The frequency of each element"
              },
              {
                "id": "c",
                "text": "The sorted array"
              },
              {
                "id": "d",
                "text": "The median"
              }
            ],
            "correct": "b",
            "explanation": "You can't find \"most frequent\" without knowing frequencies.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Best data structure for counting frequencies?",
            "options": [
              {
                "id": "a",
                "text": "Array (if values are bounded and non-negative)"
              },
              {
                "id": "b",
                "text": "Hash map (for general case)"
              },
              {
                "id": "c",
                "text": "Stack"
              },
              {
                "id": "d",
                "text": "Queue"
              }
            ],
            "correct": "b",
            "explanation": "Hash map handles any value range efficiently. Array works too if values are small non-negative integers.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "After counting frequencies, how do you find the top k?",
            "options": [
              {
                "id": "a",
                "text": "Sort all elements by frequency, take first k"
              },
              {
                "id": "b",
                "text": "Use a min-heap of size k"
              },
              {
                "id": "c",
                "text": "Use bucket sort by frequency"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "All work. They differ in time complexity: Sort is O(n log n), Heap is O(n log k), Bucket is O(n).",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Why can we use bucket sort for this problem?",
            "options": [
              {
                "id": "a",
                "text": "Elements are already sorted"
              },
              {
                "id": "b",
                "text": "Frequencies have a bounded range (1 to n)"
              },
              {
                "id": "c",
                "text": "There are only k elements"
              },
              {
                "id": "d",
                "text": "All frequencies are unique"
              }
            ],
            "correct": "b",
            "explanation": "Bucket sort requires a bounded range. Frequency of any element is between 1 and n (total elements). This is a limited range we can bucket into.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "In bucket sort approach, bucket[i] contains:",
            "options": [
              {
                "id": "a",
                "text": "Elements with value i"
              },
              {
                "id": "b",
                "text": "Elements that appear i times"
              },
              {
                "id": "c",
                "text": "The i-th largest element"
              },
              {
                "id": "d",
                "text": "The count of element i"
              }
            ],
            "correct": "b",
            "explanation": "We're bucketing by frequency, not by value. Bucket[3] holds all elements that appear exactly 3 times.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "To get top k frequent, iterate buckets in which order?",
            "options": [
              {
                "id": "a",
                "text": "Bucket 0 to bucket n (ascending frequency)"
              },
              {
                "id": "b",
                "text": "Bucket n to bucket 0 (descending frequency)"
              },
              {
                "id": "c",
                "text": "Random order"
              },
              {
                "id": "d",
                "text": "Order doesn't matter"
              }
            ],
            "correct": "b",
            "explanation": "We want most frequent first. Start from highest frequency bucket (n), work down until we've collected k elements.",
            "conceptId": "frequency-count"
          }
        ],
        "oneLiner": "For 'top k by frequency': count with hash map, then either heap (O(n log k)) or bucket sort by frequency (O(n)).",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "Step 1 is straightforward: hash map for frequency counting.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "top k frequent elements",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def topKFrequent(nums: List[int], k: int) -> List[int]:\n    # Step 1: Count frequencies\n    count = Counter(nums)\n    \n    # Step 2: Bucket sort by frequency\n    buckets = [[] for _ in range(len(nums) + 1)]\n    for num, freq in count.items():\n        buckets[freq].append(num)\n    \n    # Step 3: Collect top k from highest buckets\n    result = []\n    for i in range(len(buckets) - 1, 0, -1):\n        for num in buckets[i]:\n            result.append(num)\n            if len(result) == k:\n                return result\n    return result"
      },
      {
        "id": "06-product-of-array-except-self",
        "slug": "product-of-array-except-self",
        "title": "Product of Array Except Self",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "product-of-array-except-self"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\nYou must write an algorithm that runs in O(n) time and **without using the division operation**.",
        "examples": [
          {
            "input": "nums = [1,2,3,4]",
            "output": "[24,12,8,6]",
            "explanation": ""
          },
          {
            "input": "nums = [-1,1,0,-3,3]",
            "output": "[0,0,9,0,0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If division were allowed, the solution would be:",
            "options": [
              {
                "id": "a",
                "text": "Sort the array and take middle element"
              },
              {
                "id": "b",
                "text": "Compute total product, divide by each element"
              },
              {
                "id": "c",
                "text": "Add all elements and subtract each one"
              },
              {
                "id": "d",
                "text": "Division wouldn't help here"
              }
            ],
            "correct": "b",
            "explanation": "Total product / nums[i] = product of all others. But the problem forbids division, likely to handle zeros properly (division by zero) or as a learning exercise.",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "Product of all elements except nums[i] equals:",
            "options": [
              {
                "id": "a",
                "text": "Sum of all other elements"
              },
              {
                "id": "b",
                "text": "Maximum of all other elements"
              },
              {
                "id": "c",
                "text": "(Product of elements before i) × (Product of elements after i)"
              },
              {
                "id": "d",
                "text": "Product of adjacent elements"
              }
            ],
            "correct": "c",
            "explanation": "This decomposition avoids needing nums[i] itself. We multiply everything to the left with everything to the right.",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "prefix[i] represents:",
            "options": [
              {
                "id": "a",
                "text": "nums[0] + nums[1] + ... + nums[i]"
              },
              {
                "id": "b",
                "text": "nums[0] × nums[1] × ... × nums[i-1]"
              },
              {
                "id": "c",
                "text": "The maximum from 0 to i"
              },
              {
                "id": "d",
                "text": "The count of elements before i"
              }
            ],
            "correct": "b",
            "explanation": "Prefix product at i is the product of all elements BEFORE index i (exclusive of i).",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "suffix[i] represents:",
            "options": [
              {
                "id": "a",
                "text": "nums[i+1] × nums[i+2] × ... × nums[n-1]"
              },
              {
                "id": "b",
                "text": "nums[i] × nums[i+1] × ... × nums[n-1]"
              },
              {
                "id": "c",
                "text": "The sum of elements after i"
              },
              {
                "id": "d",
                "text": "The count of elements after i"
              }
            ],
            "correct": "a",
            "explanation": "Suffix product at i is the product of all elements AFTER index i (exclusive of i).",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "The answer for position i is:",
            "options": [
              {
                "id": "a",
                "text": "prefix[i] + suffix[i]"
              },
              {
                "id": "b",
                "text": "prefix[i] × suffix[i]"
              },
              {
                "id": "c",
                "text": "max(prefix[i], suffix[i])"
              },
              {
                "id": "d",
                "text": "prefix[i] - suffix[i]"
              }
            ],
            "correct": "b",
            "explanation": "Product of everything before × product of everything after = product of everything except nums[i].",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "We can reduce from O(n) extra space to O(1) by:",
            "options": [
              {
                "id": "a",
                "text": "Not storing the result"
              },
              {
                "id": "b",
                "text": "Computing prefix in result array, then multiplying suffix on second pass"
              },
              {
                "id": "c",
                "text": "Using recursion instead"
              },
              {
                "id": "d",
                "text": "It's not possible to optimize space"
              }
            ],
            "correct": "b",
            "explanation": "First pass: fill result with prefix products. Second pass: multiply each result[i] by running suffix product. We only need a single variable for the running suffix.",
            "conceptId": "prefix-sum"
          }
        ],
        "oneLiner": "Product except self = prefix product × suffix product. Compute in two passes.",
        "pattern": "Prefix/Suffix Arrays",
        "keyInsight": "Product of all except nums[i] = (product of everything left of i) × (product of everything right of i)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "product of array except self",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def productExceptSelf(nums: List[int]) -> List[int]:\n    n = len(nums)\n    result = [1] * n\n    \n    # First pass: compute prefix products\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n    \n    # Second pass: multiply by suffix products\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n    \n    return result"
      },
      {
        "id": "07-valid-sudoku",
        "slug": "valid-sudoku",
        "title": "Valid Sudoku",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "valid-sudoku"
        ],
        "estimatedTime": 5,
        "problemStatement": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n1. Each row must contain the digits 1-9 without repetition\n2. Each column must contain the digits 1-9 without repetition\n3. Each of the nine 3 x 3 sub-boxes must contain the digits 1-9 without repetition\n\n**Note:** A Sudoku board (partially filled) could be valid but not necessarily solvable. Only validate filled cells.",
        "examples": [
          {
            "input": "board =",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "board =",
            "output": "false",
            "explanation": "The first column has two 8s"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "How many different duplicate checks does valid Sudoku require?",
            "options": [
              {
                "id": "a",
                "text": "1 (just the whole board)"
              },
              {
                "id": "b",
                "text": "9 (just the rows)"
              },
              {
                "id": "c",
                "text": "27 (9 rows + 9 columns + 9 boxes)"
              },
              {
                "id": "d",
                "text": "81 (every cell)"
              }
            ],
            "correct": "c",
            "explanation": "Each row (9), each column (9), each 3×3 box (9) must have no duplicates = 27 separate checks.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "For each row/column/box, what operation detects invalidity?",
            "options": [
              {
                "id": "a",
                "text": "Checking if sum equals 45"
              },
              {
                "id": "b",
                "text": "Checking if any digit appears more than once"
              },
              {
                "id": "c",
                "text": "Checking if all digits are present"
              },
              {
                "id": "d",
                "text": "Checking if digits are sorted"
              }
            ],
            "correct": "b",
            "explanation": "We only need to check filled cells. A partial board might not have all digits, but no digit should repeat.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Best structure to check for duplicates as you scan?",
            "options": [
              {
                "id": "a",
                "text": "Array of booleans (seen[1..9])"
              },
              {
                "id": "b",
                "text": "Hash set"
              },
              {
                "id": "c",
                "text": "Counter"
              },
              {
                "id": "d",
                "text": "Both A and B work"
              }
            ],
            "correct": "d",
            "explanation": "Both work for O(1) lookup. Array is slightly more efficient for fixed range 1-9, but hash set is more general.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Cell (5, 7) belongs to which 3×3 box?",
            "options": [
              {
                "id": "a",
                "text": "Box 0"
              },
              {
                "id": "b",
                "text": "Box 2"
              },
              {
                "id": "c",
                "text": "Box 5"
              },
              {
                "id": "d",
                "text": "Box 8"
              }
            ],
            "correct": "c",
            "explanation": "row=5, col=7. Box = (5//3)*3 + (7//3) = 1*3 + 2 = 5",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Return false immediately when:",
            "options": [
              {
                "id": "a",
                "text": "A cell contains a non-digit character"
              },
              {
                "id": "b",
                "text": "A digit is already in the set for its row, column, OR box"
              },
              {
                "id": "c",
                "text": "The board has empty cells"
              },
              {
                "id": "d",
                "text": "A row has less than 9 filled cells"
              }
            ],
            "correct": "b",
            "explanation": "Any single duplicate (in any row, column, or box) makes the board invalid. Empty cells ('.') are allowed.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Can we check all constraints in a single pass through the board?",
            "options": [
              {
                "id": "a",
                "text": "No, we need 3 separate passes"
              },
              {
                "id": "b",
                "text": "Yes, update row, column, and box sets simultaneously"
              },
              {
                "id": "c",
                "text": "Yes, but it requires sorting first"
              },
              {
                "id": "d",
                "text": "It depends on the board state"
              }
            ],
            "correct": "b",
            "explanation": "For each cell, we know its row index, column index, and can compute box index. Update all three sets at once.",
            "conceptId": "hash-set"
          }
        ],
        "oneLiner": "Valid Sudoku = no duplicates in any row, column, or 3×3 box. Use sets for each, compute box index with (r//3)*3 + (c//3).",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "For each constraint, use a hash set to track seen digits.",
        "timeComplexity": "O(81)",
        "spaceComplexity": "O(81)",
        "triggerWords": [
          "valid sudoku",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isValidSudoku(board: List[List[str]]) -> bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    \n    for r in range(9):\n        for c in range(9):\n            if board[r][c] == '.':\n                continue\n            \n            num = board[r][c]\n            box_idx = (r // 3) * 3 + (c // 3)\n            \n            if num in rows[r] or num in cols[c] or num in boxes[box_idx]:\n                return False\n            \n            rows[r].add(num)\n            cols[c].add(num)\n            boxes[box_idx].add(num)\n    \n    return True"
      },
      {
        "id": "08-longest-consecutive-sequence",
        "slug": "longest-consecutive-sequence",
        "title": "Longest Consecutive Sequence",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "longest-consecutive-sequence"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.",
        "examples": [
          {
            "input": "nums = [100, 4, 200, 1, 3, 2]",
            "output": "4",
            "explanation": "The longest consecutive sequence is [1, 2, 3, 4]. Length = 4."
          },
          {
            "input": "nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]",
            "output": "9",
            "explanation": "[0, 1, 2, 3, 4, 5, 6, 7, 8]. Length = 9."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Sorting would make consecutive numbers adjacent. Why not use it?",
            "options": [
              {
                "id": "a",
                "text": "Sorting doesn't work for this problem"
              },
              {
                "id": "b",
                "text": "Sorting is O(n log n), problem requires O(n)"
              },
              {
                "id": "c",
                "text": "Sorting uses too much space"
              },
              {
                "id": "d",
                "text": "Sorted arrays can't have consecutive sequences"
              }
            ],
            "correct": "b",
            "explanation": "Sorting works logically, but violates the O(n) time requirement.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "To quickly check \"does number X exist in the array?\", use:",
            "options": [
              {
                "id": "a",
                "text": "Sorted array with binary search"
              },
              {
                "id": "b",
                "text": "Hash set"
              },
              {
                "id": "c",
                "text": "Linked list"
              },
              {
                "id": "d",
                "text": "Stack"
              }
            ],
            "correct": "b",
            "explanation": "Hash set gives O(1) average lookup. Convert array to set first.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "If we try to extend a sequence from EVERY number:\n\nnums = [1, 2, 3, 4]\n\nStarting from 1: count 1→2→3→4, length 4\nStarting from 2: count 2→3→4, length 3\nStarting from 3: count 3→4, length 2\nStarting from 4: count 4, length 1\n\nWhat's wrong?",
            "options": [
              {
                "id": "a",
                "text": "We get the wrong answer"
              },
              {
                "id": "b",
                "text": "We're recounting overlapping sequences"
              },
              {
                "id": "c",
                "text": "The hash lookups fail"
              },
              {
                "id": "d",
                "text": "Nothing is wrong"
              }
            ],
            "correct": "b",
            "explanation": "Each number in the sequence triggers a partial recount. This gives O(n²) worst case.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "How do we ensure each sequence is counted exactly once?",
            "options": [
              {
                "id": "a",
                "text": "Sort the array first"
              },
              {
                "id": "b",
                "text": "Only start counting from the smallest number overall"
              },
              {
                "id": "c",
                "text": "Only start counting if (num - 1) is NOT in the set"
              },
              {
                "id": "d",
                "text": "Only count increasing sequences"
              }
            ],
            "correct": "c",
            "explanation": "If num-1 exists, then num is not the start of its sequence — some earlier number will count it. Only true \"sequence starts\" trigger counting.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "In nums = [100, 4, 200, 1, 3, 2], which numbers are sequence starts?",
            "options": [
              {
                "id": "a",
                "text": "All of them"
              },
              {
                "id": "b",
                "text": "100, 200, 1"
              },
              {
                "id": "c",
                "text": "1, 2, 3, 4"
              },
              {
                "id": "d",
                "text": "100"
              }
            ],
            "correct": "b",
            "explanation": "1 is a start (0 not in set). 100 is a start (99 not in set). 200 is a start (199 not in set). 2, 3, 4 are NOT starts because their predecessors exist.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Starting from num = 1, how do we find the sequence length?",
            "options": [
              {
                "id": "a",
                "text": "Count how many times 1 appears"
              },
              {
                "id": "b",
                "text": "Check if 2, 3, 4, ... exist until one doesn't"
              },
              {
                "id": "c",
                "text": "Binary search for the endpoint"
              },
              {
                "id": "d",
                "text": "Check if 0, -1, -2, ... exist"
              }
            ],
            "correct": "b",
            "explanation": "From a start, extend right: does num+1 exist? Does num+2 exist? Count until you hit a gap.",
            "conceptId": "hash-set"
          }
        ],
        "oneLiner": "Only count from sequence starts (where num-1 doesn't exist). This ensures O(n) — each number is visited at most twice.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "Only start counting from sequence BEGINNINGS.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "longest consecutive sequence",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def longestConsecutive(nums: List[int]) -> int:\n    num_set = set(nums)\n    longest = 0\n    \n    for num in num_set:\n        # Only start counting from sequence beginnings\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n            \n            while current + 1 in num_set:\n                current += 1\n                length += 1\n            \n            longest = max(longest, length)\n    \n    return longest"
      }
    ],
    "two-pointers": [
      {
        "id": "01-valid-palindrome",
        "slug": "valid-palindrome",
        "title": "Valid Palindrome",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "valid-palindrome"
        ],
        "estimatedTime": 5,
        "problemStatement": "A phrase is a **palindrome** if, after converting all uppercase letters to lowercase and removing all non-alphanumeric characters, it reads the same forward and backward.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
        "examples": [
          {
            "input": "s = \"A man, a plan, a canal: Panama\"",
            "output": "true",
            "explanation": "\"amanaplanacanalpanama\" is a palindrome"
          },
          {
            "input": "s = \"race a car\"",
            "output": "false",
            "explanation": "\"raceacar\" is not a palindrome"
          },
          {
            "input": "s = \" \"",
            "output": "true",
            "explanation": "Empty string after removing non-alphanumeric = palindrome"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What must be true for a string to be a palindrome?",
            "options": [
              {
                "id": "a",
                "text": "All characters are the same"
              },
              {
                "id": "b",
                "text": "Characters at position i equal characters at position (n-1-i)"
              },
              {
                "id": "c",
                "text": "Characters are in alphabetical order"
              },
              {
                "id": "d",
                "text": "The string has odd length"
              }
            ],
            "correct": "b",
            "explanation": "Position 0 must equal position n-1, position 1 must equal position n-2, etc. Mirror symmetry.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Why use two pointers instead of creating a reversed copy?",
            "options": [
              {
                "id": "a",
                "text": "Two pointers can't solve this"
              },
              {
                "id": "b",
                "text": "Two pointers use O(1) space vs O(n) for reverse"
              },
              {
                "id": "c",
                "text": "Two pointers are slower"
              },
              {
                "id": "d",
                "text": "Reversing doesn't work for palindromes"
              }
            ],
            "correct": "b",
            "explanation": "Reversing creates a new string (O(n) space). Two pointers compare in-place.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If s[left] == s[right], what do you do?",
            "options": [
              {
                "id": "a",
                "text": "Return true"
              },
              {
                "id": "b",
                "text": "Move left pointer left"
              },
              {
                "id": "c",
                "text": "Move left pointer right AND right pointer left"
              },
              {
                "id": "d",
                "text": "Reset both pointers"
              }
            ],
            "correct": "c",
            "explanation": "Characters match, move inward to check the next pair.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "When left pointer is at a space or punctuation:",
            "options": [
              {
                "id": "a",
                "text": "Return false"
              },
              {
                "id": "b",
                "text": "Skip it by moving left pointer right"
              },
              {
                "id": "c",
                "text": "Compare it anyway"
              },
              {
                "id": "d",
                "text": "Remove it from the string"
              }
            ],
            "correct": "b",
            "explanation": "Non-alphanumeric chars don't count. Skip them without comparison.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "When do the pointers stop moving?",
            "options": [
              {
                "id": "a",
                "text": "When they find a mismatch"
              },
              {
                "id": "b",
                "text": "When left >= right"
              },
              {
                "id": "c",
                "text": "When they reach the string ends"
              },
              {
                "id": "d",
                "text": "After n iterations"
              }
            ],
            "correct": "b",
            "explanation": "When pointers cross or meet, we've checked all pairs. If no mismatch found, it's a palindrome.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If s[left] ≠ s[right] (after skipping non-alphanumeric and case conversion):",
            "options": [
              {
                "id": "a",
                "text": "Move both pointers"
              },
              {
                "id": "b",
                "text": "Return true"
              },
              {
                "id": "c",
                "text": "Return false immediately"
              },
              {
                "id": "d",
                "text": "Try different characters"
              }
            ],
            "correct": "c",
            "explanation": "A single mismatch proves it's not a palindrome. Early exit.",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "Palindrome check = two pointers from ends moving inward, comparing cleaned characters.",
        "pattern": "Two Pointers",
        "keyInsight": "Compare characters from both ends, moving inward.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "valid palindrome",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isPalindrome(s: str) -> bool:\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric from left\n        while left < right and not s[left].isalnum():\n            left += 1\n        # Skip non-alphanumeric from right\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Compare characters (case-insensitive)\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True"
      },
      {
        "id": "02-two-sum-ii",
        "slug": "two-sum-ii",
        "title": "Two Sum II - Input Array Is Sorted",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "two-sum-ii-input-array-is-sorted"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a **1-indexed** array of integers `numbers` that is already **sorted in non-decreasing order**, find two numbers such that they add up to a specific `target` number.\n\nReturn the indices of the two numbers (1-indexed) as an integer array `[index1, index2]`.\n\nYou may not use the same element twice. There is exactly one solution.\n\n**Constraint:** Must use only constant extra space.",
        "examples": [
          {
            "input": "numbers = [2,7,11,15], target = 9",
            "output": "[1,2]",
            "explanation": "2 + 7 = 9. Index1 = 1, Index2 = 2."
          },
          {
            "input": "numbers = [2,3,4], target = 6",
            "output": "[1,3]",
            "explanation": ""
          },
          {
            "input": "numbers = [-1,0], target = -1",
            "output": "[1,2]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The problem requires O(1) space. Why does hash map violate this?",
            "options": [
              {
                "id": "a",
                "text": "Hash maps are slow"
              },
              {
                "id": "b",
                "text": "Hash maps use O(n) space"
              },
              {
                "id": "c",
                "text": "Hash maps don't work with sorted arrays"
              },
              {
                "id": "d",
                "text": "We can use hash map, the constraint is wrong"
              }
            ],
            "correct": "b",
            "explanation": "Hash map stores up to n elements. The problem explicitly requires constant space.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Because the array is sorted, if nums[L] + nums[R] < target, we know:",
            "options": [
              {
                "id": "a",
                "text": "The answer doesn't exist"
              },
              {
                "id": "b",
                "text": "We need a larger sum, so move L right"
              },
              {
                "id": "c",
                "text": "We need a smaller sum, so move R left"
              },
              {
                "id": "d",
                "text": "We should try different elements randomly"
              }
            ],
            "correct": "b",
            "explanation": "Moving L right gives us a larger number on the left, increasing the sum. Moving R left would decrease sum further — wrong direction.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If nums[L] + nums[R] > target, we should:",
            "options": [
              {
                "id": "a",
                "text": "Move L right (increase sum)"
              },
              {
                "id": "b",
                "text": "Move R left (decrease sum)"
              },
              {
                "id": "c",
                "text": "Move both pointers"
              },
              {
                "id": "d",
                "text": "Return no solution"
              }
            ],
            "correct": "b",
            "explanation": "Sum too big → need smaller numbers → only way is to move R left (can't move L left, it's already as far left as possible relative to our search).",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Why are we guaranteed to find the answer (if it exists) with this approach?",
            "options": [
              {
                "id": "a",
                "text": "We try all pairs eventually"
              },
              {
                "id": "b",
                "text": "Each move eliminates impossible candidates while preserving the answer"
              },
              {
                "id": "c",
                "text": "Sorted arrays always have a two-sum solution"
              },
              {
                "id": "d",
                "text": "We use random chance"
              }
            ],
            "correct": "b",
            "explanation": "When we move L right (sum too small), we eliminate all pairs with current L because they'd all be too small. Answer is preserved because it needs a larger left value. Similarly for moving R.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "The loop terminates when:",
            "options": [
              {
                "id": "a",
                "text": "We find the answer (sum == target)"
              },
              {
                "id": "b",
                "text": "Pointers cross (L >= R) meaning no solution"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "After n iterations"
              }
            ],
            "correct": "c",
            "explanation": "Either we find it and return, or pointers cross (which shouldn't happen given \"exactly one solution\" guarantee, but is the logical stopping point).",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "In sorted arrays, two pointers from ends let you search in O(n) time, O(1) space — sum too small means move left pointer right, too big means move right pointer left.",
        "pattern": "Two Pointers",
        "keyInsight": "In a sorted array, the sum of two elements tells you how to adjust.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "two sum ii - input array is sorted",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def twoSum(numbers: List[int], target: int) -> List[int]:\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # 1-indexed\n        elif current_sum < target:\n            left += 1  # Need larger sum\n        else:\n            right -= 1  # Need smaller sum\n    \n    return []  # No solution found"
      },
      {
        "id": "03-three-sum",
        "slug": "three-sum",
        "title": "3Sum",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "3sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nThe solution set must not contain duplicate triplets.",
        "examples": [
          {
            "input": "nums = [-1,0,1,2,-1,-4]",
            "output": "[[-1,-1,2],[-1,0,1]]",
            "explanation": ""
          },
          {
            "input": "nums = [0,1,1]",
            "output": "[]",
            "explanation": "No triplets sum to 0."
          },
          {
            "input": "nums = [0,0,0]",
            "output": "[[0,0,0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If we fix one element nums[i], what remains?",
            "options": [
              {
                "id": "a",
                "text": "A 3Sum problem on the rest"
              },
              {
                "id": "b",
                "text": "A 2Sum problem with target = -nums[i]"
              },
              {
                "id": "c",
                "text": "A 1Sum problem"
              },
              {
                "id": "d",
                "text": "An unsolvable problem"
              }
            ],
            "correct": "b",
            "explanation": "nums[i] + nums[j] + nums[k] = 0 means nums[j] + nums[k] = -nums[i]. Two Sum!",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Sorting helps with (select all):",
            "options": [
              {
                "id": "a",
                "text": "Using two-pointer technique for 2Sum"
              },
              {
                "id": "b",
                "text": "Skipping duplicate triplets efficiently"
              },
              {
                "id": "c",
                "text": "Finding the minimum element"
              },
              {
                "id": "d",
                "text": "Both A and B"
              }
            ],
            "correct": "d",
            "explanation": "Sorting enables two-pointer 2Sum (O(n) each) and makes duplicates adjacent (easy to skip).",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After processing i=1 where nums[1]=-1: [-4, -1, -1, 0, 1, 2] ↑ Should we process i=2 where nums[2]=-1?",
            "options": [
              {
                "id": "a",
                "text": "Yes, always process every index"
              },
              {
                "id": "b",
                "text": "No, skip because nums[2] == nums[1]"
              },
              {
                "id": "c",
                "text": "Yes, but use different two-pointer logic"
              },
              {
                "id": "d",
                "text": "It depends on the target"
              }
            ],
            "correct": "b",
            "explanation": "If nums[i] == nums[i-1], we've already found all triplets starting with this value. Skip to avoid duplicates.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "During two-pointer search, after finding a valid triplet: nums = [..., -1, 0, 0, 1, 1, ...] L     ↑     R After finding [..., 0, 1] as part of triplet, we should:",
            "options": [
              {
                "id": "a",
                "text": "Return immediately"
              },
              {
                "id": "b",
                "text": "Move L right, skipping duplicate 0s; move R left, skipping duplicate 1s"
              },
              {
                "id": "c",
                "text": "Only move L, keep R"
              },
              {
                "id": "d",
                "text": "Restart the search"
              }
            ],
            "correct": "b",
            "explanation": "After finding a triplet, continue searching but skip over duplicate values to avoid finding the same triplet again.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "What's the time complexity of 3Sum with this approach?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(n³)"
              }
            ],
            "correct": "c",
            "explanation": "Sorting is O(n log n). For each of n elements (outer loop), we do O(n) two-pointer search. Total: O(n²).",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "3Sum = sort + fix one element + two-pointer 2Sum. Skip duplicates by comparing with previous values.",
        "pattern": "Two Pointers",
        "keyInsight": "3Sum = Fix one element + Two Sum on the rest",
        "timeComplexity": "O(n²)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "3sum",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def threeSum(nums: List[int]) -> List[List[int]]:\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        # Skip duplicate first elements\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        target = -nums[i]\n        \n        while left < right:\n            current_sum = nums[left] + nums[right]\n            \n            if current_sum == target:\n                result.append([nums[i], nums[left], nums[right]])\n                # Skip duplicates\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return result"
      },
      {
        "id": "04-container-with-most-water",
        "slug": "container-with-most-water",
        "title": "Container With Most Water",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "container-with-most-water"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i`th line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\n**Note:** You may not slant the container.",
        "examples": [
          {
            "input": "height = [1,8,6,2,5,4,8,3,7]",
            "output": "49",
            "explanation": "Lines at index 1 (height 8) and index 8 (height 7)."
          },
          {
            "input": "height = [1,1]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The area of water between lines at positions i and j is:",
            "options": [
              {
                "id": "a",
                "text": "height[i] × height[j]"
              },
              {
                "id": "b",
                "text": "(height[i] + height[j]) × (j - i)"
              },
              {
                "id": "c",
                "text": "min(height[i], height[j]) × (j - i)"
              },
              {
                "id": "d",
                "text": "max(height[i], height[j]) × (j - i)"
              }
            ],
            "correct": "c",
            "explanation": "Water level = shorter line (water would spill over). Width = distance between lines.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Starting with L=0 and R=n-1 gives us:",
            "options": [
              {
                "id": "a",
                "text": "The minimum possible width"
              },
              {
                "id": "b",
                "text": "The maximum possible width"
              },
              {
                "id": "c",
                "text": "Random width"
              },
              {
                "id": "d",
                "text": "The optimal answer immediately"
              }
            ],
            "correct": "b",
            "explanation": "Pointers at extremes = maximum distance = maximum width. This is our starting point.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If height[L] < height[R], which pointer should move?",
            "options": [
              {
                "id": "a",
                "text": "Move L (the shorter one) inward"
              },
              {
                "id": "b",
                "text": "Move R (the taller one) inward"
              },
              {
                "id": "c",
                "text": "Move both"
              },
              {
                "id": "d",
                "text": "Move neither"
              }
            ],
            "correct": "a",
            "explanation": "Moving R inward would decrease width while the height is still limited by L (the shorter). Moving L gives a chance of finding a taller line that could compensate for lost width.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If height[L]=3 and height[R]=7, moving R to a line of height 5:\n\n- Old area: 3 × width\n- New area: min(3, 5) × (width-1) = 3 × (width-1)\n\nWhat happened?",
            "options": [
              {
                "id": "a",
                "text": "Area increased"
              },
              {
                "id": "b",
                "text": "Area decreased"
              },
              {
                "id": "c",
                "text": "Area stayed same"
              },
              {
                "id": "d",
                "text": "Can't determine"
              }
            ],
            "correct": "b",
            "explanation": "The height is still capped at 3 (the short line didn't move). But width decreased. Guaranteed worse or equal, never better.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If height[L]=3 and height[R]=7, moving L to a line of height 6:\n\n- Old area: 3 × width\n- New area: min(6, 7) × (width-1) = 6 × (width-1)\n\nUnder what condition is new area larger?",
            "options": [
              {
                "id": "a",
                "text": "When 6 × (width-1) > 3 × width"
              },
              {
                "id": "b",
                "text": "Never"
              },
              {
                "id": "c",
                "text": "Always"
              },
              {
                "id": "d",
                "text": "When width > 6"
              }
            ],
            "correct": "a",
            "explanation": "Simplify: 6w - 6 > 3w → 3w > 6 → w > 2. If width > 2, moving to a taller line helps!",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Why does always moving the shorter pointer find the global maximum?",
            "options": [
              {
                "id": "a",
                "text": "It doesn't always work"
              },
              {
                "id": "b",
                "text": "We try all promising pairs; moving taller pointer only finds worse solutions"
              },
              {
                "id": "c",
                "text": "Luck"
              },
              {
                "id": "d",
                "text": "The array is sorted"
              }
            ],
            "correct": "b",
            "explanation": "Moving the taller pointer can never improve (height capped, width decreasing). We're not missing any potentially better solutions by moving the shorter one.",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "Start wide, greedily sacrifice width by moving the shorter line inward — only way to potentially find more area.",
        "pattern": "Two Pointers",
        "keyInsight": "Start with maximum width (pointers at both ends). Trade width for potentially greater height.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "container with most water",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxArea(height: List[int]) -> int:\n    left, right = 0, len(height) - 1\n    max_water = 0\n    \n    while left < right:\n        # Calculate current area\n        width = right - left\n        h = min(height[left], height[right])\n        max_water = max(max_water, width * h)\n        \n        # Move the shorter line inward\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water"
      },
      {
        "id": "05-trapping-rain-water",
        "slug": "trapping-rain-water",
        "title": "Trapping Rain Water",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "trapping-rain-water"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "examples": [
          {
            "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
            "output": "6",
            "explanation": "The elevation map (black) can trap 6 units of rain water (blue)."
          },
          {
            "input": "height = [4,2,0,3,2,5]",
            "output": "9",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Water can be trapped at position i if:",
            "options": [
              {
                "id": "a",
                "text": "There's a taller bar somewhere to the left AND somewhere to the right"
              },
              {
                "id": "b",
                "text": "There's a taller bar immediately adjacent"
              },
              {
                "id": "c",
                "text": "The bar at i is the shortest in the array"
              },
              {
                "id": "d",
                "text": "The total height is positive"
              }
            ],
            "correct": "a",
            "explanation": "Water needs walls on both sides to be contained. Without both, it would flow off.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "The water level at position i cannot exceed:",
            "options": [
              {
                "id": "a",
                "text": "The height of the tallest bar in the array"
              },
              {
                "id": "b",
                "text": "The height of the tallest bar to the left"
              },
              {
                "id": "c",
                "text": "The height of the tallest bar to the right"
              },
              {
                "id": "d",
                "text": "min(tallest left, tallest right)"
              }
            ],
            "correct": "d",
            "explanation": "Water would overflow over the shorter of the two bounding walls.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If max_left = 3, max_right = 2, height[i] = 1, water trapped = ?",
            "options": [
              {
                "id": "a",
                "text": "3 - 1 = 2"
              },
              {
                "id": "b",
                "text": "2 - 1 = 1"
              },
              {
                "id": "c",
                "text": "3 + 2 - 1 = 4"
              },
              {
                "id": "d",
                "text": "(3 + 2) / 2 - 1 = 1.5"
              }
            ],
            "correct": "b",
            "explanation": "Water level = min(3, 2) = 2. Water trapped = 2 - 1 = 1.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Naive approach: For each position, scan left for max, scan right for max. Time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "c",
            "explanation": "For each of n positions, we scan up to n elements left and right.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "We can precompute max_left[] and max_right[] arrays. What's the new time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "a",
            "explanation": "One pass to build max_left, one for max_right, one to compute water. O(3n) = O(n).",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "Two pointers can solve this in O(1) space because:",
            "options": [
              {
                "id": "a",
                "text": "We only need to track the current water level"
              },
              {
                "id": "b",
                "text": "At each step, we know enough about one side to compute water"
              },
              {
                "id": "c",
                "text": "Pointers magically know the max heights"
              },
              {
                "id": "d",
                "text": "It's not possible in O(1) space"
              }
            ],
            "correct": "b",
            "explanation": "If max_left < max_right, we know the left side is the bottleneck. We can safely compute water at the left pointer without knowing the exact max_right (just that it's >= max_left).",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "Water at each position = min(max_left, max_right) - height. Two pointers let us compute this in O(1) space by always processing the side with the smaller known max.",
        "pattern": "Two Pointers",
        "keyInsight": "Water at position i = min(max_left, max_right) - height[i]",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "trapping rain water",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def trap(height: List[int]) -> int:\n    if not height:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max, right_max = height[left], height[right]\n    water = 0\n    \n    while left < right:\n        if left_max < right_max:\n            left += 1\n            left_max = max(left_max, height[left])\n            water += left_max - height[left]\n        else:\n            right -= 1\n            right_max = max(right_max, height[right])\n            water += right_max - height[right]\n    \n    return water"
      }
    ],
    "stack": [
      {
        "id": "01-valid-parentheses",
        "slug": "valid-parentheses",
        "title": "Valid Parentheses",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "valid-parentheses"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets\n2. Open brackets must be closed in the correct order\n3. Every close bracket has a corresponding open bracket of the same type",
        "examples": [
          {
            "input": "s = \"()\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"()[]{}\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"(]\"",
            "output": "false",
            "explanation": ""
          },
          {
            "input": "s = \"([)]\"",
            "output": "false",
            "explanation": ""
          },
          {
            "input": "s = \"{[]}\"",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The key property that makes a stack appropriate is:",
            "options": [
              {
                "id": "a",
                "text": "Brackets come in pairs"
              },
              {
                "id": "b",
                "text": "The most recent open bracket must close first"
              },
              {
                "id": "c",
                "text": "There are three types of brackets"
              },
              {
                "id": "d",
                "text": "The string has finite length"
              }
            ],
            "correct": "b",
            "explanation": "LIFO behavior. The innermost (most recently opened) bracket must be matched first.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "When you see an opening bracket '(', '[', or '{', you should:",
            "options": [
              {
                "id": "a",
                "text": "Push the closing bracket onto the stack"
              },
              {
                "id": "b",
                "text": "Push the opening bracket onto the stack"
              },
              {
                "id": "c",
                "text": "Pop from the stack"
              },
              {
                "id": "d",
                "text": "Do nothing"
              }
            ],
            "correct": "a",
            "explanation": "Empty stack means no opener to match = invalid. Otherwise, top of stack should be the matching opener.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "After processing all characters, the string is valid if:",
            "options": [
              {
                "id": "a",
                "text": "We never returned false"
              },
              {
                "id": "b",
                "text": "The stack is empty"
              },
              {
                "id": "c",
                "text": "The stack has one element"
              },
              {
                "id": "d",
                "text": "Both A and B"
              }
            ],
            "correct": "d",
            "explanation": "We need no mismatches during processing AND no unmatched openers left.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "\"([)]\" fails because:",
            "options": [
              {
                "id": "a",
                "text": "Different number of opens and closes"
              },
              {
                "id": "b",
                "text": "The '[' must close before ')' but ')' comes first"
              },
              {
                "id": "c",
                "text": "Parentheses can't be next to brackets"
              },
              {
                "id": "d",
                "text": "The string is too long"
              }
            ],
            "correct": "b",
            "explanation": "After `([`, stack is `[(, []`. Seeing `)` requires `(` on top, but `[` is on top. Nesting violation.",
            "conceptId": "stack"
          }
        ],
        "oneLiner": "Nested structures = stack. Push openers, pop and match on closers, end with empty stack.",
        "pattern": "Stack",
        "keyInsight": "Last opened bracket must be first to close.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "valid parentheses",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:  # Closing bracket\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:  # Opening bracket\n            stack.append(char)\n    \n    return len(stack) == 0"
      },
      {
        "id": "02-min-stack",
        "slug": "min-stack",
        "title": "Min Stack",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "min-stack"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the `MinStack` class:\n- `MinStack()` initializes the stack object\n- `void push(int val)` pushes the element val onto the stack\n- `void pop()` removes the element on the top of the stack\n- `int top()` gets the top element of the stack\n- `int getMin()` retrieves the minimum element in the stack\n\nAll operations must be O(1) time.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If we store just the minimum value, what breaks on pop?",
            "options": [
              {
                "id": "a",
                "text": "We don't know what to pop"
              },
              {
                "id": "b",
                "text": "We lose what the previous minimum was"
              },
              {
                "id": "c",
                "text": "The stack becomes empty"
              },
              {
                "id": "d",
                "text": "Nothing breaks"
              }
            ],
            "correct": "b",
            "explanation": "If we pop the current min, we don't know the second smallest without scanning.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "When element X is on top, the minimum is determined by:",
            "options": [
              {
                "id": "a",
                "text": "Only X"
              },
              {
                "id": "b",
                "text": "All elements currently in the stack"
              },
              {
                "id": "c",
                "text": "All elements ever pushed"
              },
              {
                "id": "d",
                "text": "The element below X"
              }
            ],
            "correct": "b",
            "explanation": "Minimum is among current elements. When X is popped, min changes to min of remaining elements.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "At each stack position, we can precompute:",
            "options": [
              {
                "id": "a",
                "text": "The sum of all elements below"
              },
              {
                "id": "b",
                "text": "The minimum of all elements at or below this position"
              },
              {
                "id": "c",
                "text": "The maximum element"
              },
              {
                "id": "d",
                "text": "The count of elements"
              }
            ],
            "correct": "b",
            "explanation": "This \"minimum-so-far\" lets us answer getMin() instantly and recover previous min on pop.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "Which approach works for O(1) operations?",
            "options": [
              {
                "id": "a",
                "text": "Store (value, min_so_far) pairs"
              },
              {
                "id": "b",
                "text": "Use two stacks: main stack and min stack"
              },
              {
                "id": "c",
                "text": "Single stack with lazy min computation"
              },
              {
                "id": "d",
                "text": "Both A and B work"
              }
            ],
            "correct": "d",
            "explanation": "Pairs and synchronized stacks are equivalent. Both achieve O(1) for all operations.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "With two stacks (main, mins), when pushing value X:",
            "options": [
              {
                "id": "a",
                "text": "Push X to main; push min(X, mins.top()) to mins"
              },
              {
                "id": "b",
                "text": "Push X to both stacks"
              },
              {
                "id": "c",
                "text": "Push X to main only if X < current min"
              },
              {
                "id": "d",
                "text": "Push X to mins only if X < current min"
              }
            ],
            "correct": "a",
            "explanation": "Main stack holds all values. Mins stack holds the minimum at each level. They stay synchronized in size.",
            "conceptId": "stack"
          }
        ],
        "oneLiner": "Track 'minimum so far' at each stack position — either with pairs (val, min) or synchronized min stack.",
        "pattern": "Stack",
        "keyInsight": "Track the minimum at each \"level\" of the stack.",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "min stack",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class MinStack:\n    def __init__(self):\n        self.stack = []      # (value, min_so_far)\n    \n    def push(self, val: int) -> None:\n        if not self.stack:\n            self.stack.append((val, val))\n        else:\n            current_min = min(val, self.stack[-1][1])\n            self.stack.append((val, current_min))\n    \n    def pop(self) -> None:\n        self.stack.pop()\n    \n    def top(self) -> int:\n        return self.stack[-1][0]\n    \n    def getMin(self) -> int:\n        return self.stack[-1][1]"
      },
      {
        "id": "03-evaluate-reverse-polish-notation",
        "slug": "evaluate-reverse-polish-notation",
        "title": "Evaluate Reverse Polish Notation",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "evaluate-reverse-polish-notation"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of strings `tokens` that represents an arithmetic expression in Reverse Polish Notation (RPN).\n\nEvaluate the expression and return an integer representing the value.\n\n**Notes:**\n- Valid operators are `+`, `-`, `*`, and `/`\n- Each operand may be an integer or another expression\n- Division truncates toward zero\n- No division by zero\n- Answer fits in 32-bit integer",
        "examples": [
          {
            "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
            "output": "9",
            "explanation": "((2 + 1) * 3) = 9"
          },
          {
            "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
            "output": "6",
            "explanation": "(4 + (13 / 5)) = 4 + 2 = 6"
          },
          {
            "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
            "output": "22",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "When you encounter a number token, you should:",
            "options": [
              {
                "id": "a",
                "text": "Immediately output it"
              },
              {
                "id": "b",
                "text": "Push it onto the stack"
              },
              {
                "id": "c",
                "text": "Discard it"
              },
              {
                "id": "d",
                "text": "Apply the previous operator"
              }
            ],
            "correct": "b",
            "explanation": "Numbers wait on the stack until an operator needs them.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "When you encounter an operator, you should:",
            "options": [
              {
                "id": "a",
                "text": "Push it onto the stack"
              },
              {
                "id": "b",
                "text": "Pop one operand, apply operator"
              },
              {
                "id": "c",
                "text": "Pop two operands, apply operator, push result"
              },
              {
                "id": "d",
                "text": "Wait for the next number"
              }
            ],
            "correct": "c",
            "explanation": "Binary operators need two operands. Result goes back on stack for future operations.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "For tokens [\"10\", \"3\", \"-\"], the result is:",
            "options": [
              {
                "id": "a",
                "text": "3 - 10 = -7"
              },
              {
                "id": "b",
                "text": "10 - 3 = 7"
              },
              {
                "id": "c",
                "text": "Error"
              },
              {
                "id": "d",
                "text": "13"
              }
            ],
            "correct": "b",
            "explanation": "First number pushed (10) is second popped. Order is: second_popped OP first_popped = 10 - 3 = 7.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "If stack is [10, 3] and operator is \"/\": Pop 3, pop 10. The computation is:",
            "options": [
              {
                "id": "a",
                "text": "3 / 10"
              },
              {
                "id": "b",
                "text": "10 / 3"
              },
              {
                "id": "c",
                "text": "Either works"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "b",
            "explanation": "The operand pushed first (10) is the dividend. Operand pushed second (3) is the divisor. 10 / 3 = 3 (truncated).",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "After processing all tokens, the answer is:",
            "options": [
              {
                "id": "a",
                "text": "The sum of all stack elements"
              },
              {
                "id": "b",
                "text": "The top (and only) element of the stack"
              },
              {
                "id": "c",
                "text": "The bottom element of the stack"
              },
              {
                "id": "d",
                "text": "Zero"
              }
            ],
            "correct": "b",
            "explanation": "Valid RPN expression reduces to exactly one value on the stack.",
            "conceptId": "stack"
          }
        ],
        "oneLiner": "RPN evaluation: numbers go on stack, operators pop two, compute, push result. Final answer is stack's only element.",
        "pattern": "Stack",
        "keyInsight": "When you see an operator, apply it to the two most recent numbers.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "evaluate reverse polish notation",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def evalRPN(tokens: List[str]) -> int:\n    stack = []\n    operators = {'+', '-', '*', '/'}\n    \n    for token in tokens:\n        if token in operators:\n            b = stack.pop()  # Second operand\n            a = stack.pop()  # First operand\n            \n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            else:  # Division truncates toward zero\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    \n    return stack[0]"
      },
      {
        "id": "04-generate-parentheses",
        "slug": "generate-parentheses",
        "title": "Generate Parentheses",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "generate-parentheses"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
        "examples": [
          {
            "input": "n = 3",
            "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
            "explanation": ""
          },
          {
            "input": "n = 1",
            "output": "[\"()\"]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For n pairs, a valid sequence must have:",
            "options": [
              {
                "id": "a",
                "text": "n characters total"
              },
              {
                "id": "b",
                "text": "n '(' and n ')' characters"
              },
              {
                "id": "c",
                "text": "More '(' than ')'"
              },
              {
                "id": "d",
                "text": "Alternating '(' and ')'"
              }
            ],
            "correct": "b",
            "explanation": "Exactly n of each type, total length 2n.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At any prefix of a valid sequence:",
            "options": [
              {
                "id": "a",
                "text": "Count of ')' > count of '('"
              },
              {
                "id": "b",
                "text": "Count of '(' ≥ count of ')'"
              },
              {
                "id": "c",
                "text": "Counts must be equal"
              },
              {
                "id": "d",
                "text": "No constraint"
              }
            ],
            "correct": "b",
            "explanation": "If ')' ever exceeds '(', there's an unmatched closer. Invalid.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We can add an opening bracket if:",
            "options": [
              {
                "id": "a",
                "text": "We've added at least one ')'"
              },
              {
                "id": "b",
                "text": "We've used fewer than n '(' so far"
              },
              {
                "id": "c",
                "text": "The previous char was ')'"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "b",
            "explanation": "We have n opens to use. If used < n, we can add more.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We can add a closing bracket if:",
            "options": [
              {
                "id": "a",
                "text": "We've used fewer than n ')' so far"
              },
              {
                "id": "b",
                "text": "Open count > close count"
              },
              {
                "id": "c",
                "text": "Both A and B"
              },
              {
                "id": "d",
                "text": "The string is non-empty"
              }
            ],
            "correct": "c",
            "explanation": "We need both: (1) ')' available and (2) a '(' to match. Condition B implies A when building sequentially.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We've completed a valid sequence when:",
            "options": [
              {
                "id": "a",
                "text": "Length equals n"
              },
              {
                "id": "b",
                "text": "Length equals 2n"
              },
              {
                "id": "c",
                "text": "We can't add more characters"
              },
              {
                "id": "d",
                "text": "Both B and C"
              }
            ],
            "correct": "b",
            "explanation": "2n characters = n opens + n closes = complete sequence.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Generate valid parentheses by backtracking: add '(' if < n used, add ')' if close < open. Both constraints must hold.",
        "pattern": "Stack",
        "keyInsight": "Build sequences character by character, tracking counts.",
        "timeComplexity": "O(4^n / √n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "generate parentheses",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def generateParenthesis(n: int) -> List[str]:\n    result = []\n    \n    def backtrack(current: str, open_count: int, close_count: int):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        # Can add '(' if we haven't used all n\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        \n        # Can add ')' if it doesn't exceed open count\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result"
      },
      {
        "id": "05-daily-temperatures",
        "slug": "daily-temperatures",
        "title": "Daily Temperatures",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "daily-temperatures"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of integers `temperatures` represents the daily temperatures, return an array `answer` such that `answer[i]` is the number of days you have to wait after the `i`th day to get a warmer temperature. If there is no future day with warmer temperature, `answer[i] = 0`.",
        "examples": [
          {
            "input": "temperatures = [73,74,75,71,69,72,76,73]",
            "output": "[1,1,4,2,1,1,0,0]",
            "explanation": ""
          },
          {
            "input": "temperatures = [30,40,50,60]",
            "output": "[1,1,1,0]",
            "explanation": ""
          },
          {
            "input": "temperatures = [30,60,90]",
            "output": "[1,1,0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For each day i, scan forward to find the first warmer day. Time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "c",
            "explanation": "For each of n days, we might scan up to n days forward.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The stack holds days that are:",
            "options": [
              {
                "id": "a",
                "text": "Already resolved (found their warmer day)"
              },
              {
                "id": "b",
                "text": "Still waiting to find a warmer day"
              },
              {
                "id": "c",
                "text": "The warmest days seen"
              },
              {
                "id": "d",
                "text": "Random days"
              }
            ],
            "correct": "b",
            "explanation": "Days on the stack haven't found their next warmer day yet.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "When processing day i with temperature T, pop from stack if:",
            "options": [
              {
                "id": "a",
                "text": "Stack is not empty"
              },
              {
                "id": "b",
                "text": "Stack top's temperature < T"
              },
              {
                "id": "c",
                "text": "Stack top's temperature > T"
              },
              {
                "id": "d",
                "text": "Stack has more than one element"
              }
            ],
            "correct": "b",
            "explanation": "Day on stack top is cooler than today. Today is its \"next warmer day\"!",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "When popping day j because day i is warmer: answer[j] = ?",
            "options": [
              {
                "id": "a",
                "text": "temperatures[i]"
              },
              {
                "id": "b",
                "text": "temperatures[i] - temperatures[j]"
              },
              {
                "id": "c",
                "text": "i - j"
              },
              {
                "id": "d",
                "text": "j"
              }
            ],
            "correct": "c",
            "explanation": "We want days to wait, not temperature difference. Days = index difference.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "After resolving all cooler days, what do we do with the current day?",
            "options": [
              {
                "id": "a",
                "text": "Discard it"
              },
              {
                "id": "b",
                "text": "Push it onto the stack"
              },
              {
                "id": "c",
                "text": "Store it in answer"
              },
              {
                "id": "d",
                "text": "Pop more elements"
              }
            ],
            "correct": "b",
            "explanation": "Current day now waits for ITS next warmer day. It joins the stack.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The temperatures of days on the stack form a:",
            "options": [
              {
                "id": "a",
                "text": "Random sequence"
              },
              {
                "id": "b",
                "text": "Increasing sequence"
              },
              {
                "id": "c",
                "text": "Decreasing sequence (from bottom to top)"
              },
              {
                "id": "d",
                "text": "Alternating sequence"
              }
            ],
            "correct": "c",
            "explanation": "We pop anything smaller than current before pushing. So bottom is largest, top is smallest of the waiting days. This is a monotonic decreasing stack.",
            "conceptId": "monotonic-stack"
          }
        ],
        "oneLiner": "Next greater element = monotonic decreasing stack. Pop and resolve when current > stack top, then push current.",
        "pattern": "Stack",
        "keyInsight": "Use a stack to track days waiting for a warmer day.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "daily temperatures",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def dailyTemperatures(temperatures: List[int]) -> List[int]:\n    n = len(temperatures)\n    answer = [0] * n\n    stack = []  # Stack of indices\n    \n    for i in range(n):\n        # Pop all days that found their warmer day\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            prev_day = stack.pop()\n            answer[prev_day] = i - prev_day\n        \n        # Current day waits for its warmer day\n        stack.append(i)\n    \n    return answer"
      },
      {
        "id": "06-car-fleet",
        "slug": "car-fleet",
        "title": "Car Fleet",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "car-fleet"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\n\nYou are given two integer arrays `position` and `speed`, both of length `n`, where `position[i]` is the position of the `i`th car and `speed[i]` is the speed of the `i`th car (in miles per hour).\n\nA car can never pass another car ahead of it, but it can catch up to it and then travel at the same speed. The faster car will slow down to match the slower car's speed.\n\nA **car fleet** is some non-empty set of cars driving at the same position and same speed. A single car is also a fleet.\n\nIf a car catches up to a car fleet right at the destination point, it still counts as one fleet.\n\nReturn the number of car fleets that will arrive at the destination.",
        "examples": [
          {
            "input": "target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]",
            "output": "3",
            "explanation": ""
          },
          {
            "input": "target = 10, position = [3], speed = [3]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For a car at position p with speed s, time to reach target T is:",
            "options": [
              {
                "id": "a",
                "text": "T * s"
              },
              {
                "id": "b",
                "text": "(T - p) / s"
              },
              {
                "id": "c",
                "text": "p / s"
              },
              {
                "id": "d",
                "text": "T / p"
              }
            ],
            "correct": "b",
            "explanation": "Distance to travel = T - p. Time = distance / speed.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "We process cars from closest to target because:",
            "options": [
              {
                "id": "a",
                "text": "It's alphabetically first"
              },
              {
                "id": "b",
                "text": "Front cars can block/slow down cars behind them"
              },
              {
                "id": "c",
                "text": "Front cars are always faster"
              },
              {
                "id": "d",
                "text": "Randomizes the result"
              }
            ],
            "correct": "b",
            "explanation": "A slower car in front creates a \"barrier\" — faster cars behind can only match its arrival time, not beat it.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Car B (behind) merges with Car A (ahead) if:",
            "options": [
              {
                "id": "a",
                "text": "B is faster than A"
              },
              {
                "id": "b",
                "text": "B would arrive at target before or at same time as A"
              },
              {
                "id": "c",
                "text": "B starts closer to target"
              },
              {
                "id": "d",
                "text": "A and B have the same speed"
              }
            ],
            "correct": "b",
            "explanation": "If B's arrival time ≤ A's, B catches up (or ties at target). B can't pass A, so B joins A's fleet.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "When car B merges with car A's fleet:",
            "options": [
              {
                "id": "a",
                "text": "Both times are averaged"
              },
              {
                "id": "b",
                "text": "Fleet takes B's (faster) arrival time"
              },
              {
                "id": "c",
                "text": "Fleet takes A's (slower) arrival time"
              },
              {
                "id": "d",
                "text": "Fleet speed doubles"
              }
            ],
            "correct": "c",
            "explanation": "B can't pass A, so B slows down to A's pace. Fleet arrival = A's original arrival time.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "The stack stores:",
            "options": [
              {
                "id": "a",
                "text": "Car positions"
              },
              {
                "id": "b",
                "text": "Car speeds"
              },
              {
                "id": "c",
                "text": "Arrival times of fleet \"leaders\""
              },
              {
                "id": "d",
                "text": "Number of cars in each fleet"
              }
            ],
            "correct": "c",
            "explanation": "Each stack entry represents a fleet. We track its arrival time to compare with the next car.",
            "conceptId": "stack"
          }
        ],
        "oneLiner": "Sort cars by position (front first). Car joins fleet ahead if its arrival time ≤ fleet's time, else forms new fleet. Count distinct fleet times.",
        "pattern": "Stack",
        "keyInsight": "Calculate arrival time for each car. Process from position closest to target backward.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "car fleet",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def carFleet(target: int, position: List[int], speed: List[int]) -> int:\n    # Pair positions with arrival times, sort by position descending\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []  # Arrival times of fleet leaders\n    \n    for pos, spd in cars:\n        arrival_time = (target - pos) / spd\n        \n        # If this car arrives later than the fleet ahead, it's a new fleet\n        if not stack or arrival_time > stack[-1]:\n            stack.append(arrival_time)\n        # Otherwise, it merges with the fleet ahead (don't push)\n    \n    return len(stack)"
      },
      {
        "id": "07-largest-rectangle-in-histogram",
        "slug": "largest-rectangle-in-histogram",
        "title": "Largest Rectangle in Histogram",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "largest-rectangle-in-histogram"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of integers `heights` representing the histogram's bar heights where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
        "examples": [
          {
            "input": "heights = [2,1,5,6,2,3]",
            "output": "10",
            "explanation": "Rectangle with height 5 and width 2 (indices 2-3) = 10"
          },
          {
            "input": "heights = [2,4]",
            "output": "4",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A rectangle of height h starting at bar i can extend to bar j if:",
            "options": [
              {
                "id": "a",
                "text": "heights[j] ≥ h"
              },
              {
                "id": "b",
                "text": "heights[j] > h"
              },
              {
                "id": "c",
                "text": "heights[j] = h"
              },
              {
                "id": "d",
                "text": "j > i"
              }
            ],
            "correct": "a",
            "explanation": "As long as bars are at least height h, the rectangle continues.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The maximum rectangle using bar i as the shortest bar:",
            "options": [
              {
                "id": "a",
                "text": "Has width 1"
              },
              {
                "id": "b",
                "text": "Extends to first shorter bar on each side"
              },
              {
                "id": "c",
                "text": "Extends to the array ends"
              },
              {
                "id": "d",
                "text": "Only includes taller bars"
              }
            ],
            "correct": "b",
            "explanation": "Rectangle height is limited by bar i. It extends until a shorter bar blocks it.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "We maintain bars in increasing height order because:",
            "options": [
              {
                "id": "a",
                "text": "It looks nice"
              },
              {
                "id": "b",
                "text": "When a shorter bar appears, we can compute rectangles for all taller bars"
              },
              {
                "id": "c",
                "text": "We only care about increasing sequences"
              },
              {
                "id": "d",
                "text": "Random order works too"
              }
            ],
            "correct": "b",
            "explanation": "A shorter bar terminates all taller bars' extensions to the right. We process them now.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "For a bar popped from the stack, its left boundary is:",
            "options": [
              {
                "id": "a",
                "text": "Index 0"
              },
              {
                "id": "b",
                "text": "Its own index"
              },
              {
                "id": "c",
                "text": "The new stack top's index (or -1 if empty)"
              },
              {
                "id": "d",
                "text": "The index of the bar that caused the pop"
              }
            ],
            "correct": "c",
            "explanation": "The bar below it on the stack is the first shorter bar to its left. If stack becomes empty, it can extend to index 0 (left boundary = -1).",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "For a bar popped because of bar at index i, its right boundary is:",
            "options": [
              {
                "id": "a",
                "text": "The array's length"
              },
              {
                "id": "b",
                "text": "i"
              },
              {
                "id": "c",
                "text": "i + 1"
              },
              {
                "id": "d",
                "text": "The bar's own index"
              }
            ],
            "correct": "b",
            "explanation": "Bar at index i is the first shorter bar to its right. Right boundary = i (exclusive).",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "If left boundary (exclusive) is L and right boundary (exclusive) is R: Width = ?",
            "options": [
              {
                "id": "a",
                "text": "R - L"
              },
              {
                "id": "b",
                "text": "R - L - 1"
              },
              {
                "id": "c",
                "text": "R - L + 1"
              },
              {
                "id": "d",
                "text": "L - R"
              }
            ],
            "correct": "b",
            "explanation": "Bars from L+1 to R-1 are included. Count = (R-1) - (L+1) + 1 = R - L - 1.",
            "conceptId": "monotonic-stack"
          }
        ],
        "oneLiner": "Monotonic increasing stack: when a shorter bar appears, all taller bars on stack have found their right boundary. Pop, compute width = right - left - 1, track max area.",
        "pattern": "Stack",
        "keyInsight": "For each bar, find how far it can extend left and right.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "largest rectangle in histogram",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def largestRectangleArea(heights: List[int]) -> int:\n    stack = []  # Stack of indices\n    max_area = 0\n    \n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            idx, height = stack.pop()\n            max_area = max(max_area, height * (i - idx))\n            start = idx  # Extend left boundary\n        stack.append((start, h))\n    \n    # Process remaining bars (extend to end)\n    for idx, height in stack:\n        max_area = max(max_area, height * (len(heights) - idx))\n    \n    return max_area"
      }
    ],
    "sliding-window": [
      {
        "id": "01-best-time-to-buy-and-sell-stock",
        "slug": "best-time-to-buy-and-sell-stock",
        "title": "Best Time to Buy and Sell Stock",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "best-time-to-buy-and-sell-stock"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
        "examples": [
          {
            "input": "prices = [7,1,5,3,6,4]",
            "output": "5",
            "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
          },
          {
            "input": "prices = [7,6,4,3,1]",
            "output": "0",
            "explanation": "No profitable transaction possible (prices only decrease)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To find max profit, the naive approach is:",
            "options": [
              {
                "id": "a",
                "text": "Sort the array and take max - min"
              },
              {
                "id": "b",
                "text": "For each day, check profit with every future day"
              },
              {
                "id": "c",
                "text": "Sum all the prices"
              },
              {
                "id": "d",
                "text": "Find the average price"
              }
            ],
            "correct": "b",
            "explanation": "We need to check all buy-sell pairs where sell comes after buy. But this is O(n²).",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "Given prices = [3, 1, 4], after sorting = [1, 3, 4]. Max - min = 4 - 1 = 3. Is this achievable?",
            "options": [
              {
                "id": "a",
                "text": "Yes, always achievable"
              },
              {
                "id": "b",
                "text": "Only if max comes after min in original array"
              },
              {
                "id": "c",
                "text": "Only if array is already sorted"
              },
              {
                "id": "d",
                "text": "Never achievable"
              }
            ],
            "correct": "b",
            "explanation": "We can only sell AFTER buying. Sorting loses temporal order. Here it works (4 comes after 1), but [4,1,3] would give wrong answer.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "As we scan left to right, what should we track?",
            "options": [
              {
                "id": "a",
                "text": "Maximum price seen so far"
              },
              {
                "id": "b",
                "text": "Minimum price seen so far"
              },
              {
                "id": "c",
                "text": "Average price so far"
              },
              {
                "id": "d",
                "text": "Median price so far"
              }
            ],
            "correct": "b",
            "explanation": "We want to buy low. The best buy opportunity at any point is the minimum we've seen. We can only buy in the past, not the future.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "At day i, the best profit if we sell today is:",
            "options": [
              {
                "id": "a",
                "text": "prices[i] - prices[0]"
              },
              {
                "id": "b",
                "text": "prices[i] - min(prices[0:i])"
              },
              {
                "id": "c",
                "text": "max(prices[0:i]) - prices[i]"
              },
              {
                "id": "d",
                "text": "prices[i] - prices[i-1]"
              }
            ],
            "correct": "b",
            "explanation": "Best profit = today's price minus the cheapest price before today.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "After computing today's potential profit, we:",
            "options": [
              {
                "id": "a",
                "text": "Always update the answer"
              },
              {
                "id": "b",
                "text": "Update answer if this profit > current best"
              },
              {
                "id": "c",
                "text": "Update answer if price increased from yesterday"
              },
              {
                "id": "d",
                "text": "Reset the minimum price"
              }
            ],
            "correct": "b",
            "explanation": "We want maximum profit, so only update if we found a better one.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "If today's price is lower than our tracked minimum:",
            "options": [
              {
                "id": "a",
                "text": "We should sell today"
              },
              {
                "id": "b",
                "text": "We should update minimum and skip profit calculation"
              },
              {
                "id": "c",
                "text": "We should update minimum, and profit today is 0"
              },
              {
                "id": "d",
                "text": "We should restart the algorithm"
              }
            ],
            "correct": "c",
            "explanation": "New minimum can't give positive profit today (selling at price we just bought). Future days might benefit from this lower buy price.",
            "conceptId": "sliding-window"
          }
        ],
        "oneLiner": "Track minimum price seen. At each day, profit = today - min. Track maximum profit.",
        "pattern": "Sliding Window",
        "keyInsight": "Track the minimum price seen so far. At each day, calculate potential profit if we sold today.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "best time to buy and sell stock",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxProfit(prices: List[int]) -> int:\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        profit = price - min_price\n        max_profit = max(max_profit, profit)\n    \n    return max_profit"
      },
      {
        "id": "02-longest-substring-without-repeating",
        "slug": "longest-substring-without-repeating",
        "title": "Longest Substring Without Repeating Characters",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "longest-substring-without-repeating-characters"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s`, find the length of the longest substring without repeating characters.",
        "examples": [
          {
            "input": "s = \"abcabcbb\"",
            "output": "3",
            "explanation": "The answer is \"abc\", with length 3."
          },
          {
            "input": "s = \"bbbbb\"",
            "output": "1",
            "explanation": "The answer is \"b\", with length 1."
          },
          {
            "input": "s = \"pwwkew\"",
            "output": "3",
            "explanation": "The answer is \"wke\", with length 3."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A window (substring) is valid if:",
            "options": [
              {
                "id": "a",
                "text": "It contains at least one character"
              },
              {
                "id": "b",
                "text": "All characters in it are unique"
              },
              {
                "id": "c",
                "text": "It starts at index 0"
              },
              {
                "id": "d",
                "text": "It has odd length"
              }
            ],
            "correct": "b",
            "explanation": "\"Without repeating characters\" means all unique within the window.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "We can expand the window by moving the right pointer when:",
            "options": [
              {
                "id": "a",
                "text": "The window is empty"
              },
              {
                "id": "b",
                "text": "The new character is not in the current window"
              },
              {
                "id": "c",
                "text": "The window size is less than 26"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "b",
            "explanation": "Adding a character that's already in the window creates a duplicate, violating our constraint.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "We must shrink the window (move left pointer) when:",
            "options": [
              {
                "id": "a",
                "text": "Window size exceeds some limit"
              },
              {
                "id": "b",
                "text": "The character at right pointer already exists in window"
              },
              {
                "id": "c",
                "text": "We've scanned half the string"
              },
              {
                "id": "d",
                "text": "The left character is a vowel"
              }
            ],
            "correct": "b",
            "explanation": "A duplicate means the window is invalid. Shrink until the duplicate is removed.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "When shrinking due to duplicate at position r, shrink until:",
            "options": [
              {
                "id": "a",
                "text": "Window is empty"
              },
              {
                "id": "b",
                "text": "Window size is 1"
              },
              {
                "id": "c",
                "text": "The duplicate character is no longer in the window"
              },
              {
                "id": "d",
                "text": "Left pointer equals right pointer"
              }
            ],
            "correct": "c",
            "explanation": "We only need to remove enough to eliminate the duplicate. Then we can include s[r].",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "To check if a character is in the current window in O(1):",
            "options": [
              {
                "id": "a",
                "text": "Scan the window each time"
              },
              {
                "id": "b",
                "text": "Use a hash set"
              },
              {
                "id": "c",
                "text": "Use a sorted array"
              },
              {
                "id": "d",
                "text": "Use a queue"
              }
            ],
            "correct": "b",
            "explanation": "Set provides O(1) add, remove, and contains operations.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "If we track each character's last position, when we find duplicate:",
            "options": [
              {
                "id": "a",
                "text": "We must still remove one at a time"
              },
              {
                "id": "b",
                "text": "We can jump left pointer to last_position[char] + 1"
              },
              {
                "id": "c",
                "text": "We reset to position 0"
              },
              {
                "id": "d",
                "text": "We skip the duplicate entirely"
              }
            ],
            "correct": "b",
            "explanation": "If we know where the duplicate was last seen, we can jump past it. This is still O(n) but with fewer operations.",
            "conceptId": "hash-map"
          }
        ],
        "oneLiner": "Sliding window with set: expand right, shrink left until no duplicate, track max window size.",
        "pattern": "Sliding Window",
        "keyInsight": "Expand the window right. When a duplicate is found, shrink from the left until unique again.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(min(n, alphabet))",
        "triggerWords": [
          "longest substring without repeating characters",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def lengthOfLongestSubstring(s: str) -> int:\n    char_set = set()\n    left = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        # Shrink window until no duplicate\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        char_set.add(s[right])\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len"
      },
      {
        "id": "03-longest-repeating-character-replacement",
        "slug": "longest-repeating-character-replacement",
        "title": "Longest Repeating Character Replacement",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "longest-repeating-character-replacement"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.",
        "examples": [
          {
            "input": "s = \"ABAB\", k = 2",
            "output": "4",
            "explanation": "Replace the two 'A's with 'B's or vice versa."
          },
          {
            "input": "s = \"AABABBA\", k = 1",
            "output": "4",
            "explanation": "Replace the 'B' at index 2 with 'A'. Substring \"AAAB\" or replace 'A' at index 0 with 'B' for \"BABBA\" → \"BBBB\" (substring \"ABBB\" starting at 1)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A window can become all same character if:",
            "options": [
              {
                "id": "a",
                "text": "It contains only one unique character"
              },
              {
                "id": "b",
                "text": "Characters to change ≤ k"
              },
              {
                "id": "c",
                "text": "Window size ≤ k"
              },
              {
                "id": "d",
                "text": "Most frequent char appears > k times"
              }
            ],
            "correct": "b",
            "explanation": "We have k changes. If we need more than k, window is invalid.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "In a valid window, which character should we NOT change?",
            "options": [
              {
                "id": "a",
                "text": "The first character"
              },
              {
                "id": "b",
                "text": "The last character"
              },
              {
                "id": "c",
                "text": "The most frequent character"
              },
              {
                "id": "d",
                "text": "Any vowel present"
              }
            ],
            "correct": "c",
            "explanation": "Keeping the most frequent minimizes changes needed. Changing the minority to match the majority.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "For a window of size W with most frequent character appearing F times: Replacements needed = ?",
            "options": [
              {
                "id": "a",
                "text": "W"
              },
              {
                "id": "b",
                "text": "F"
              },
              {
                "id": "c",
                "text": "W - F"
              },
              {
                "id": "d",
                "text": "W + F"
              }
            ],
            "correct": "c",
            "explanation": "Total chars - chars we keep = chars we must change.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "Window is invalid when:",
            "options": [
              {
                "id": "a",
                "text": "W - F > k"
              },
              {
                "id": "b",
                "text": "W - F < k"
              },
              {
                "id": "c",
                "text": "F > k"
              },
              {
                "id": "d",
                "text": "W > k"
              }
            ],
            "correct": "a",
            "explanation": "If we need more than k replacements, we can't make all chars the same.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "When window becomes invalid, we:",
            "options": [
              {
                "id": "a",
                "text": "Reset to empty window"
              },
              {
                "id": "b",
                "text": "Move left pointer right by 1"
              },
              {
                "id": "c",
                "text": "Move right pointer left by 1"
              },
              {
                "id": "d",
                "text": "Remove all occurrences of some character"
              }
            ],
            "correct": "b",
            "explanation": "Shrink window minimally. Maybe removing one char from left makes it valid again.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "To know the most frequent character in current window:",
            "options": [
              {
                "id": "a",
                "text": "Scan window each time"
              },
              {
                "id": "b",
                "text": "Keep a frequency map of chars in window"
              },
              {
                "id": "c",
                "text": "Only track the first character"
              },
              {
                "id": "d",
                "text": "Use a sorted set"
              }
            ],
            "correct": "b",
            "explanation": "Maintain count of each character. Update as window expands/shrinks.",
            "conceptId": "frequency-count"
          }
        ],
        "oneLiner": "Valid window: size - max_frequency ≤ k. Expand right, shrink left when invalid, track max size.",
        "pattern": "Sliding Window",
        "keyInsight": "Characters to replace = window size - count of most frequent character.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(26)",
        "triggerWords": [
          "longest repeating character replacement",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def characterReplacement(s: str, k: int) -> int:\n    count = {}  # Frequency of chars in window\n    left = 0\n    max_freq = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_freq = max(max_freq, count[s[right]])\n        \n        # Window is invalid: size - max_freq > k\n        while (right - left + 1) - max_freq > k:\n            count[s[left]] -= 1\n            left += 1\n        \n        max_len = max(max_len, right - left + 1)\n    \n    return max_len"
      },
      {
        "id": "04-permutation-in-string",
        "slug": "permutation-in-string",
        "title": "Permutation in String",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "permutation-in-string"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1`, or `false` otherwise.\n\nIn other words, return `true` if one of `s1`'s permutations is a substring of `s2`.",
        "examples": [
          {
            "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
            "output": "true",
            "explanation": "s2 contains one permutation of s1 (\"ba\")."
          },
          {
            "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Two strings are permutations of each other if:",
            "options": [
              {
                "id": "a",
                "text": "They have the same length"
              },
              {
                "id": "b",
                "text": "They have the same first and last character"
              },
              {
                "id": "c",
                "text": "They have identical character frequency counts"
              },
              {
                "id": "d",
                "text": "One can be reversed to get the other"
              }
            ],
            "correct": "c",
            "explanation": "\"abc\" and \"bca\" are permutations — same chars, same counts, different order.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "For s1 of length n, generating all permutations takes:",
            "options": [
              {
                "id": "a",
                "text": "O(n) time"
              },
              {
                "id": "b",
                "text": "O(n²) time"
              },
              {
                "id": "c",
                "text": "O(n!) time"
              },
              {
                "id": "d",
                "text": "O(2^n) time"
              }
            ],
            "correct": "c",
            "explanation": "n! permutations exist. For n=10, that's 3.6 million. Way too slow.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "To find a permutation of s1 in s2, the window size should be:",
            "options": [
              {
                "id": "a",
                "text": "Variable"
              },
              {
                "id": "b",
                "text": "len(s1)"
              },
              {
                "id": "c",
                "text": "len(s2)"
              },
              {
                "id": "d",
                "text": "min(len(s1), len(s2))"
              }
            ],
            "correct": "b",
            "explanation": "Permutation has exact same length as original. Window must match s1's length.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "With a fixed-size window, when we slide right by 1:",
            "options": [
              {
                "id": "a",
                "text": "Rebuild the entire frequency count"
              },
              {
                "id": "b",
                "text": "Add new char on right, remove old char on left"
              },
              {
                "id": "c",
                "text": "Only add new char on right"
              },
              {
                "id": "d",
                "text": "Reset the window"
              }
            ],
            "correct": "b",
            "explanation": "Sliding by 1 = one char enters (right), one char exits (left). Update counts incrementally.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "The simplest way to check if window matches s1:",
            "options": [
              {
                "id": "a",
                "text": "Sort both and compare"
              },
              {
                "id": "b",
                "text": "Compare frequency dictionaries"
              },
              {
                "id": "c",
                "text": "Check if all characters exist"
              },
              {
                "id": "d",
                "text": "Use string equality"
              }
            ],
            "correct": "b",
            "explanation": "Two frequency maps can be compared in O(26) = O(1) for lowercase letters.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Instead of comparing full maps, we can track:",
            "options": [
              {
                "id": "a",
                "text": "Just the first character"
              },
              {
                "id": "b",
                "text": "Number of matching character counts"
              },
              {
                "id": "c",
                "text": "Sum of all frequencies"
              },
              {
                "id": "d",
                "text": "Product of all frequencies"
              }
            ],
            "correct": "b",
            "explanation": "Track how many of the 26 characters have matching counts. When all 26 match (or all present chars match), we found a permutation.",
            "conceptId": "sliding-window"
          }
        ],
        "oneLiner": "Permutation = same frequency. Slide fixed-size window, update counts incrementally, check for match.",
        "pattern": "Sliding Window",
        "keyInsight": "A permutation has the same characters in different order. Same characters = same frequency count.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "permutation in string",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def checkInclusion(s1: str, s2: str) -> bool:\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = [0] * 26\n    window_count = [0] * 26\n    \n    for c in s1:\n        s1_count[ord(c) - ord('a')] += 1\n    \n    for i in range(len(s2)):\n        # Add char to window\n        window_count[ord(s2[i]) - ord('a')] += 1\n        \n        # Remove char that left the window\n        if i >= len(s1):\n            window_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        \n        # Check if window matches s1\n        if window_count == s1_count:\n            return True\n    \n    return False"
      },
      {
        "id": "05-minimum-window-substring",
        "slug": "minimum-window-substring",
        "title": "Minimum Window Substring",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "minimum-window-substring"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `\"\"`.",
        "examples": [
          {
            "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
            "output": "\"BANC\"",
            "explanation": "\"BANC\" is the smallest window containing 'A', 'B', and 'C'."
          },
          {
            "input": "s = \"a\", t = \"a\"",
            "output": "\"a\"",
            "explanation": ""
          },
          {
            "input": "s = \"a\", t = \"aa\"",
            "output": "\"\"",
            "explanation": "Need two 'a's but only one exists."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We use sliding window because:",
            "options": [
              {
                "id": "a",
                "text": "The answer is always at the start"
              },
              {
                "id": "b",
                "text": "We're looking for a contiguous substring"
              },
              {
                "id": "c",
                "text": "The strings are sorted"
              },
              {
                "id": "d",
                "text": "We need O(1) space"
              }
            ],
            "correct": "b",
            "explanation": "Substring = contiguous sequence. Window maintains contiguity.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "A window is valid when:",
            "options": [
              {
                "id": "a",
                "text": "It contains at least one char from t"
              },
              {
                "id": "b",
                "text": "It contains each unique char from t at least once"
              },
              {
                "id": "c",
                "text": "It contains each char from t with at least the required frequency"
              },
              {
                "id": "d",
                "text": "Its length equals t's length"
              }
            ],
            "correct": "c",
            "explanation": "If t = \"aab\", window needs at least 2 'a's and 1 'b'. Frequencies matter.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "We expand the window when:",
            "options": [
              {
                "id": "a",
                "text": "Window is already valid"
              },
              {
                "id": "b",
                "text": "Window is not yet valid"
              },
              {
                "id": "c",
                "text": "We've found a minimum"
              },
              {
                "id": "d",
                "text": "Left equals right"
              }
            ],
            "correct": "b",
            "explanation": "Need to include more chars to meet the requirement. Once valid, try shrinking.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "Once window is valid, we shrink from left to:",
            "options": [
              {
                "id": "a",
                "text": "Make window invalid"
              },
              {
                "id": "b",
                "text": "Find a smaller valid window"
              },
              {
                "id": "c",
                "text": "Reset the search"
              },
              {
                "id": "d",
                "text": "Remove duplicates"
              }
            ],
            "correct": "b",
            "explanation": "We want minimum window. Maybe some chars on the left aren't needed. Shrink until invalid, track min valid.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "To efficiently check if window contains all of t:",
            "options": [
              {
                "id": "a",
                "text": "Compare sorted strings"
              },
              {
                "id": "b",
                "text": "Track \"how many char requirements are fully met\""
              },
              {
                "id": "c",
                "text": "Count total characters only"
              },
              {
                "id": "d",
                "text": "Use regex matching"
              }
            ],
            "correct": "b",
            "explanation": "For each char in t, track if window has enough. Count how many chars have met quota. When count equals unique chars in t, window is valid.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "We update our answer (minimum window) when:",
            "options": [
              {
                "id": "a",
                "text": "Window expands"
              },
              {
                "id": "b",
                "text": "Window shrinks"
              },
              {
                "id": "c",
                "text": "Window is valid and smaller than current best"
              },
              {
                "id": "d",
                "text": "Window contains exactly t"
              }
            ],
            "correct": "c",
            "explanation": "Only valid windows count. Among valid, we want smallest.",
            "conceptId": "sliding-window"
          }
        ],
        "oneLiner": "Expand right until valid, shrink left while still valid, track minimum. Validity = all target chars satisfied.",
        "pattern": "Sliding Window",
        "keyInsight": "Expand window until valid (contains all of t). Then shrink from left while still valid. Track minimum.",
        "timeComplexity": "O(|s| + |t|)",
        "spaceComplexity": "O(|s| + |t|)",
        "triggerWords": [
          "minimum window substring",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minWindow(s: str, t: str) -> str:\n    if not t or not s:\n        return \"\"\n    \n    from collections import Counter\n    t_count = Counter(t)\n    required = len(t_count)\n    \n    left = 0\n    formed = 0\n    window_count = {}\n    ans = (float('inf'), None, None)  # (length, left, right)\n    \n    for right in range(len(s)):\n        char = s[right]\n        window_count[char] = window_count.get(char, 0) + 1\n        \n        if char in t_count and window_count[char] == t_count[char]:\n            formed += 1\n        \n        # Shrink window while valid\n        while formed == required:\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            left_char = s[left]\n            window_count[left_char] -= 1\n            if left_char in t_count and window_count[left_char] < t_count[left_char]:\n                formed -= 1\n            left += 1\n    \n    return \"\" if ans[0] == float('inf') else s[ans[1]:ans[2]+1]"
      },
      {
        "id": "06-sliding-window-maximum",
        "slug": "sliding-window-maximum",
        "title": "Sliding Window Maximum",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "sliding-window-maximum"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of integers `nums`, and there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n\nReturn the max sliding window.",
        "examples": [
          {
            "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
            "output": "[3,3,5,5,6,7]",
            "explanation": ""
          },
          {
            "input": "nums = [1], k = 1",
            "output": "[1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A max-heap seems natural for tracking maximum. The issue is:",
            "options": [
              {
                "id": "a",
                "text": "Heaps are too slow"
              },
              {
                "id": "b",
                "text": "Heaps can't handle removing arbitrary elements efficiently"
              },
              {
                "id": "c",
                "text": "Heaps only work for positive numbers"
              },
              {
                "id": "d",
                "text": "Heaps need sorted input"
              }
            ],
            "correct": "b",
            "explanation": "When the window slides, we must remove the element leaving the window. Heaps don't support efficient arbitrary removal (only top removal).",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "When a larger element enters the window, all smaller elements to its left:",
            "options": [
              {
                "id": "a",
                "text": "Become more important"
              },
              {
                "id": "b",
                "text": "Can never be the maximum while the larger element is in the window"
              },
              {
                "id": "c",
                "text": "Should be moved to the front"
              },
              {
                "id": "d",
                "text": "Are immediately removed from array"
              }
            ],
            "correct": "b",
            "explanation": "A smaller element can only become max if all larger elements leave. But the new larger element entered AFTER, so it leaves later. The smaller elements will never be max.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The deque should store:",
            "options": [
              {
                "id": "a",
                "text": "Values in the window"
              },
              {
                "id": "b",
                "text": "Indices of potential maximum candidates"
              },
              {
                "id": "c",
                "text": "All indices in the window"
              },
              {
                "id": "d",
                "text": "Only the current maximum"
              }
            ],
            "correct": "b",
            "explanation": "We store indices because (1) we can get values from indices, and (2) we need indices to check if element is still in window.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The deque maintains elements in:",
            "options": [
              {
                "id": "a",
                "text": "Increasing order"
              },
              {
                "id": "b",
                "text": "Decreasing order (from front to back)"
              },
              {
                "id": "c",
                "text": "Original order"
              },
              {
                "id": "d",
                "text": "Random order"
              }
            ],
            "correct": "b",
            "explanation": "Front is the maximum. Each subsequent element is smaller but might become max later when larger elements leave.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "Before adding nums[i] to deque, we:",
            "options": [
              {
                "id": "a",
                "text": "Just append it"
              },
              {
                "id": "b",
                "text": "Remove all smaller elements from back"
              },
              {
                "id": "c",
                "text": "Remove all smaller elements from front"
              },
              {
                "id": "d",
                "text": "Clear the entire deque"
              }
            ],
            "correct": "b",
            "explanation": "Elements smaller than nums[i] will never be max while nums[i] is in window. Remove from back (LIFO) to maintain deque order.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "We remove from front when:",
            "options": [
              {
                "id": "a",
                "text": "Front value is smaller than new value"
              },
              {
                "id": "b",
                "text": "Front index is outside the current window"
              },
              {
                "id": "c",
                "text": "Deque size exceeds k"
              },
              {
                "id": "d",
                "text": "Always after adding new element"
              }
            ],
            "correct": "b",
            "explanation": "If front index ≤ current index - k, it's no longer in the window. Remove it.",
            "conceptId": "sliding-window"
          }
        ],
        "oneLiner": "Monotonic decreasing deque of indices: remove smaller from back (useless candidates), remove expired from front (out of window). Front is always current max.",
        "pattern": "Sliding Window",
        "keyInsight": "Use a monotonic decreasing deque. Front is always the current max. Remove elements that can't be max for future windows.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "sliding window maximum",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import deque\n\ndef maxSlidingWindow(nums: List[int], k: int) -> List[int]:\n    dq = deque()  # Store indices, decreasing order by value\n    result = []\n    \n    for i in range(len(nums)):\n        # Remove indices outside current window\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove smaller elements from back\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Add max to result once window is complete\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result"
      }
    ],
    "binary-search": [
      {
        "id": "01-binary-search",
        "slug": "binary-search",
        "title": "Binary Search",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "binary-search"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with O(log n) runtime complexity.",
        "examples": [
          {
            "input": "nums = [-1,0,3,5,9,12], target = 9",
            "output": "4",
            "explanation": "9 exists in nums and its index is 4"
          },
          {
            "input": "nums = [-1,0,3,5,9,12], target = 2",
            "output": "-1",
            "explanation": "2 does not exist in nums so return -1"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Binary search is O(log n) because:",
            "options": [
              {
                "id": "a",
                "text": "It uses recursion"
              },
              {
                "id": "b",
                "text": "It halves the search space each iteration"
              },
              {
                "id": "c",
                "text": "It uses a sorted array"
              },
              {
                "id": "d",
                "text": "It only checks odd indices"
              }
            ],
            "correct": "b",
            "explanation": "n → n/2 → n/4 → ... → 1 takes log₂(n) steps.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Binary search requires the array to be:",
            "options": [
              {
                "id": "a",
                "text": "Non-empty"
              },
              {
                "id": "b",
                "text": "Sorted"
              },
              {
                "id": "c",
                "text": "Containing unique elements"
              },
              {
                "id": "d",
                "text": "Having even length"
              }
            ],
            "correct": "b",
            "explanation": "Without sorting, we can't eliminate half based on a single comparison.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "To avoid integer overflow, the middle index should be:",
            "options": [
              {
                "id": "a",
                "text": "(left + right) / 2"
              },
              {
                "id": "b",
                "text": "left + (right - left) / 2"
              },
              {
                "id": "c",
                "text": "right - left / 2"
              },
              {
                "id": "d",
                "text": "(left + right + 1) / 2"
              }
            ],
            "correct": "b",
            "explanation": "left + right can overflow for large indices. This formula avoids it.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If nums[mid] == target:",
            "options": [
              {
                "id": "a",
                "text": "Continue searching left"
              },
              {
                "id": "b",
                "text": "Continue searching right"
              },
              {
                "id": "c",
                "text": "Return mid"
              },
              {
                "id": "d",
                "text": "Return -1"
              }
            ],
            "correct": "c",
            "explanation": "We found it! Return the index.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We search the left half (right = mid - 1) when:",
            "options": [
              {
                "id": "a",
                "text": "target > nums[mid]"
              },
              {
                "id": "b",
                "text": "target < nums[mid]"
              },
              {
                "id": "c",
                "text": "target == nums[mid]"
              },
              {
                "id": "d",
                "text": "left < right"
              }
            ],
            "correct": "b",
            "explanation": "Target is smaller than middle, so it must be in the smaller (left) portion.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "The loop should continue while:",
            "options": [
              {
                "id": "a",
                "text": "left < right"
              },
              {
                "id": "b",
                "text": "left <= right"
              },
              {
                "id": "c",
                "text": "left != right"
              },
              {
                "id": "d",
                "text": "mid != target"
              }
            ],
            "correct": "b",
            "explanation": "When left == right, there's still one element to check. Loop ends when left > right (search space empty).",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Sorted array: compare middle to target, eliminate half. Repeat until found or search space empty.",
        "pattern": "Binary Search",
        "keyInsight": "Sorted array = can eliminate half the search space with each comparison.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "binary search",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1"
      },
      {
        "id": "02-search-2d-matrix",
        "slug": "search-2d-matrix",
        "title": "Search a 2D Matrix",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "search-a-2d-matrix"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an `m x n` integer matrix `matrix` with the following two properties:\n- Each row is sorted in non-decreasing order.\n- The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer `target`, return `true` if `target` is in `matrix` or `false` otherwise.\n\nYou must write a solution in O(log(m * n)) time complexity.",
        "examples": [
          {
            "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Given the two properties, the entire matrix when read row by row is:",
            "options": [
              {
                "id": "a",
                "text": "Partially sorted"
              },
              {
                "id": "b",
                "text": "Fully sorted"
              },
              {
                "id": "c",
                "text": "Unsorted"
              },
              {
                "id": "d",
                "text": "Sorted in each row only"
              }
            ],
            "correct": "b",
            "explanation": "Each row is sorted, and row i's last element < row i+1's first element. So all elements are in ascending order.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "For an m×n matrix, how many elements total?",
            "options": [
              {
                "id": "a",
                "text": "m + n"
              },
              {
                "id": "b",
                "text": "m × n"
              },
              {
                "id": "c",
                "text": "m - n"
              },
              {
                "id": "d",
                "text": "max(m, n)"
              }
            ],
            "correct": "b",
            "explanation": "m rows, n elements each = m × n total.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "For a 1D index i in a matrix with n columns, the row is:",
            "options": [
              {
                "id": "a",
                "text": "i % n"
              },
              {
                "id": "b",
                "text": "i / n (integer division)"
              },
              {
                "id": "c",
                "text": "i - n"
              },
              {
                "id": "d",
                "text": "n / i"
              }
            ],
            "correct": "b",
            "explanation": "After every n elements, we move to the next row. i / n gives the row number.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "For a 1D index i in a matrix with n columns, the column is:",
            "options": [
              {
                "id": "a",
                "text": "i % n"
              },
              {
                "id": "b",
                "text": "i / n"
              },
              {
                "id": "c",
                "text": "i - n"
              },
              {
                "id": "d",
                "text": "n % i"
              }
            ],
            "correct": "a",
            "explanation": "Position within the row cycles every n elements. i % n gives column.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Binary search should search indices from:",
            "options": [
              {
                "id": "a",
                "text": "0 to m-1"
              },
              {
                "id": "b",
                "text": "0 to n-1"
              },
              {
                "id": "c",
                "text": "0 to m×n-1"
              },
              {
                "id": "d",
                "text": "1 to m×n"
              }
            ],
            "correct": "c",
            "explanation": "Total m×n elements, indices 0 through m×n-1.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Another valid approach is:",
            "options": [
              {
                "id": "a",
                "text": "Binary search to find the row, then binary search within the row"
              },
              {
                "id": "b",
                "text": "Linear search each row"
              },
              {
                "id": "c",
                "text": "Check only diagonal elements"
              },
              {
                "id": "d",
                "text": "Sort the matrix first"
              }
            ],
            "correct": "a",
            "explanation": "Two binary searches: O(log m) + O(log n) = O(log(m×n)). Same complexity!",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Matrix with sorted rows and row-to-row ordering = one sorted array. Binary search with index conversion: row = mid/cols, col = mid%cols.",
        "pattern": "Binary Search",
        "keyInsight": "Treat the 2D matrix as a 1D sorted array. Use index conversion.",
        "timeComplexity": "O(log(m*n))",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "search a 2d matrix",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def searchMatrix(matrix: List[List[int]], target: int) -> bool:\n    if not matrix:\n        return False\n    \n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        row, col = mid // n, mid % n\n        val = matrix[row][col]\n        \n        if val == target:\n            return True\n        elif val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False"
      },
      {
        "id": "03-koko-eating-bananas",
        "slug": "koko-eating-bananas",
        "title": "Koko Eating Bananas",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "koko-eating-bananas"
        ],
        "estimatedTime": 5,
        "problemStatement": "Koko loves to eat bananas. There are `n` piles of bananas, the `i`th pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses a pile and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them and will not eat any more bananas during that hour.\n\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.",
        "examples": [
          {
            "input": "piles = [3,6,7,11], h = 8",
            "output": "4",
            "explanation": "At k=4: ceil(3/4) + ceil(6/4) + ceil(7/4) + ceil(11/4) = 1+2+2+3 = 8 hours"
          },
          {
            "input": "piles = [30,11,23,4,20], h = 5",
            "output": "30",
            "explanation": "Must eat one pile per hour (fastest possible)."
          },
          {
            "input": "piles = [30,11,23,4,20], h = 6",
            "output": "23",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We're binary searching for:",
            "options": [
              {
                "id": "a",
                "text": "The index of the largest pile"
              },
              {
                "id": "b",
                "text": "The pile to eat first"
              },
              {
                "id": "c",
                "text": "The eating speed k"
              },
              {
                "id": "d",
                "text": "The number of hours"
              }
            ],
            "correct": "c",
            "explanation": "We want to find the minimum k that allows finishing in h hours. k is a value we're searching for, not an index.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "The minimum possible eating speed is:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "min(piles)"
              },
              {
                "id": "d",
                "text": "h"
              }
            ],
            "correct": "b",
            "explanation": "Must eat at least 1 banana per hour. k=0 means never eating.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "The maximum useful eating speed is:",
            "options": [
              {
                "id": "a",
                "text": "sum(piles)"
              },
              {
                "id": "b",
                "text": "max(piles)"
              },
              {
                "id": "c",
                "text": "len(piles)"
              },
              {
                "id": "d",
                "text": "h"
              }
            ],
            "correct": "b",
            "explanation": "Eating faster than the largest pile gains nothing (can only eat one pile per hour anyway). At k = max(piles), each pile takes exactly 1 hour.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "To eat a pile of size p at speed k, hours needed:",
            "options": [
              {
                "id": "a",
                "text": "p / k"
              },
              {
                "id": "b",
                "text": "ceil(p / k)"
              },
              {
                "id": "c",
                "text": "p * k"
              },
              {
                "id": "d",
                "text": "p - k"
              }
            ],
            "correct": "b",
            "explanation": "If p=7, k=4: eat 4 first hour, 3 second hour = 2 hours = ceil(7/4).",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Total hours at speed k:",
            "options": [
              {
                "id": "a",
                "text": "sum(piles) / k"
              },
              {
                "id": "b",
                "text": "len(piles)"
              },
              {
                "id": "c",
                "text": "sum(ceil(p/k) for each pile)"
              },
              {
                "id": "d",
                "text": "max(piles) / k"
              }
            ],
            "correct": "c",
            "explanation": "Each pile takes ceil(size/k) hours. Sum all piles' times.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If k hours > h (too slow):",
            "options": [
              {
                "id": "a",
                "text": "Try smaller k"
              },
              {
                "id": "b",
                "text": "Try larger k"
              },
              {
                "id": "c",
                "text": "k is the answer"
              },
              {
                "id": "d",
                "text": "No answer exists"
              }
            ],
            "correct": "b",
            "explanation": "Need to eat faster (larger k) to finish in fewer hours.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Binary search on answer: k in [1, max(piles)]. Check if sum(ceil(pile/k)) ≤ h. Find minimum valid k.",
        "pattern": "Binary Search",
        "keyInsight": "Binary search on the answer (k), not on the input.",
        "timeComplexity": "O(n * log(max(piles)))",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "koko eating bananas",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import math\n\ndef minEatingSpeed(piles: List[int], h: int) -> int:\n    left, right = 1, max(piles)\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        # Calculate hours needed at speed mid\n        hours = sum(math.ceil(p / mid) for p in piles)\n        \n        if hours <= h:\n            right = mid  # Can go slower\n        else:\n            left = mid + 1  # Need to go faster\n    \n    return left"
      },
      {
        "id": "04-search-in-rotated-sorted-array",
        "slug": "search-in-rotated-sorted-array",
        "title": "Search in Rotated Sorted Array",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "search-in-rotated-sorted-array"
        ],
        "estimatedTime": 5,
        "problemStatement": "There is an integer array `nums` sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, `nums` is possibly rotated at an unknown pivot index `k` such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`.\n\nGiven the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\n\nYou must write an algorithm with O(log n) runtime complexity.",
        "examples": [
          {
            "input": "nums = [4,5,6,7,0,1,2], target = 0",
            "output": "4",
            "explanation": ""
          },
          {
            "input": "nums = [4,5,6,7,0,1,2], target = 3",
            "output": "-1",
            "explanation": ""
          },
          {
            "input": "nums = [1], target = 0",
            "output": "-1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "After rotation, the array:",
            "options": [
              {
                "id": "a",
                "text": "Becomes unsorted"
              },
              {
                "id": "b",
                "text": "Has two sorted portions"
              },
              {
                "id": "c",
                "text": "Has random order"
              },
              {
                "id": "d",
                "text": "Stays the same"
              }
            ],
            "correct": "b",
            "explanation": "[1,2,3,4,5] rotated → [4,5,1,2,3]. Both [4,5] and [1,2,3] are sorted.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "At index mid, the left half [left...mid] is sorted if:",
            "options": [
              {
                "id": "a",
                "text": "nums[mid] > nums[right]"
              },
              {
                "id": "b",
                "text": "nums[left] <= nums[mid]"
              },
              {
                "id": "c",
                "text": "mid > left"
              },
              {
                "id": "d",
                "text": "nums[left] < nums[right]"
              }
            ],
            "correct": "b",
            "explanation": "If left element ≤ mid element, the left half is in ascending order (no rotation break in this half).",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If left half is sorted, target is in left half if:",
            "options": [
              {
                "id": "a",
                "text": "target > nums[mid]"
              },
              {
                "id": "b",
                "text": "target < nums[left]"
              },
              {
                "id": "c",
                "text": "nums[left] <= target < nums[mid]"
              },
              {
                "id": "d",
                "text": "target == nums[left]"
              }
            ],
            "correct": "c",
            "explanation": "Target must be ≥ the sorted half's minimum and < its maximum (mid) to be in that range.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If left half is sorted and target is NOT in left half:",
            "options": [
              {
                "id": "a",
                "text": "Search left half anyway"
              },
              {
                "id": "b",
                "text": "Search right half"
              },
              {
                "id": "c",
                "text": "Return -1"
              },
              {
                "id": "d",
                "text": "Restart the search"
              }
            ],
            "correct": "b",
            "explanation": "If target isn't in the sorted left, it must be in the right (if it exists).",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If left half is NOT sorted (nums[left] > nums[mid]), then:",
            "options": [
              {
                "id": "a",
                "text": "Neither half is sorted"
              },
              {
                "id": "b",
                "text": "Right half must be sorted"
              },
              {
                "id": "c",
                "text": "The pivot is at mid"
              },
              {
                "id": "d",
                "text": "Target doesn't exist"
              }
            ],
            "correct": "b",
            "explanation": "One half must always be sorted. If left isn't, right is.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Within a sorted half, we can:",
            "options": [
              {
                "id": "a",
                "text": "Only do linear search"
              },
              {
                "id": "b",
                "text": "Apply standard binary search logic"
              },
              {
                "id": "c",
                "text": "Skip elements randomly"
              },
              {
                "id": "d",
                "text": "Reverse and search"
              }
            ],
            "correct": "b",
            "explanation": "A sorted portion allows normal binary search range checking.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "At mid, one half is sorted. Check if target is in the sorted half's range; if yes search there, else search the other half.",
        "pattern": "Binary Search",
        "keyInsight": "At any midpoint, at least one half is properly sorted. Check if target is in the sorted half.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "search in rotated sorted array",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        # Left half is sorted\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        # Right half is sorted\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1"
      },
      {
        "id": "05-find-minimum-in-rotated-sorted-array",
        "slug": "find-minimum-in-rotated-sorted-array",
        "title": "Find Minimum in Rotated Sorted Array",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "find-minimum-in-rotated-sorted-array"
        ],
        "estimatedTime": 5,
        "problemStatement": "Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n- `[4,5,6,7,0,1,2]` if it was rotated 4 times.\n- `[0,1,2,4,5,6,7]` if it was rotated 7 times.\n\nGiven the sorted rotated array `nums` of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
          {
            "input": "nums = [3,4,5,1,2]",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "nums = [4,5,6,7,0,1,2]",
            "output": "0",
            "explanation": ""
          },
          {
            "input": "nums = [11,13,15,17]",
            "output": "11",
            "explanation": "Array not rotated (or rotated n times), minimum at start."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "In a rotated sorted array, the minimum element is:",
            "options": [
              {
                "id": "a",
                "text": "Always at index 0"
              },
              {
                "id": "b",
                "text": "Always at index n-1"
              },
              {
                "id": "c",
                "text": "At the rotation point (where the \"break\" occurs)"
              },
              {
                "id": "d",
                "text": "In the middle"
              }
            ],
            "correct": "c",
            "explanation": "[4,5,6,7,0,1,2] — minimum 0 is where the sequence breaks from 7 to 0.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If the array is sorted (not rotated or rotated n times), minimum is at:",
            "options": [
              {
                "id": "a",
                "text": "Index 0"
              },
              {
                "id": "b",
                "text": "Index n-1"
              },
              {
                "id": "c",
                "text": "Middle index"
              },
              {
                "id": "d",
                "text": "Nowhere determinable"
              }
            ],
            "correct": "a",
            "explanation": "[1,2,3,4,5] — standard sorted, minimum is first element.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We compare nums[mid] with nums[right] because:",
            "options": [
              {
                "id": "a",
                "text": "It's simpler than comparing with left"
              },
              {
                "id": "b",
                "text": "It tells us which half contains the minimum"
              },
              {
                "id": "c",
                "text": "The right element is always the minimum"
              },
              {
                "id": "d",
                "text": "Random choice"
              }
            ],
            "correct": "b",
            "explanation": "If mid > right, the break is between mid and right (min is right of mid). If mid < right, this portion is sorted, so min is at or left of mid.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If nums[mid] > nums[right], the minimum is:",
            "options": [
              {
                "id": "a",
                "text": "At mid"
              },
              {
                "id": "b",
                "text": "To the left of mid"
              },
              {
                "id": "c",
                "text": "To the right of mid"
              },
              {
                "id": "d",
                "text": "At the right end"
              }
            ],
            "correct": "c",
            "explanation": "Mid being greater than right means there's a \"drop\" somewhere between mid and right. The minimum is in the right half.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If nums[mid] < nums[right], the minimum:",
            "options": [
              {
                "id": "a",
                "text": "Might be at mid itself"
              },
              {
                "id": "b",
                "text": "Is definitely not at mid"
              },
              {
                "id": "c",
                "text": "Is at the right end"
              },
              {
                "id": "d",
                "text": "Doesn't exist"
              }
            ],
            "correct": "a",
            "explanation": "The portion from mid to right is sorted. The minimum could be mid or something to its left. Don't exclude mid.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We use `left < right` (not `left <= right`) because:",
            "options": [
              {
                "id": "a",
                "text": "We're finding a value, not searching for a target"
              },
              {
                "id": "b",
                "text": "It's faster"
              },
              {
                "id": "c",
                "text": "Prevents off-by-one errors only"
              },
              {
                "id": "d",
                "text": "No particular reason"
              }
            ],
            "correct": "a",
            "explanation": "We're narrowing down to the minimum. When left == right, that's our answer. No need to check equality.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Compare mid with right: if mid > right, minimum is in right half (left = mid + 1). Else minimum is at mid or left (right = mid). Converge to find break point.",
        "pattern": "Binary Search",
        "keyInsight": "The minimum is where the \"break\" happens — where a larger element is followed by a smaller one.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "find minimum in rotated sorted array",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findMin(nums: List[int]) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] > nums[right]:\n            # Minimum is in right half\n            left = mid + 1\n        else:\n            # Minimum is at mid or left of mid\n            right = mid\n    \n    return nums[left]"
      },
      {
        "id": "06-time-based-key-value-store",
        "slug": "time-based-key-value-store",
        "title": "Time Based Key-Value Store",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "time-based-key-value-store"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\n\nImplement the `TimeMap` class:\n- `TimeMap()` Initializes the object.\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time `timestamp`.\n- `String get(String key, int timestamp)` Returns a value such that `set` was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\"\"`.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To map keys to their history, use:",
            "options": [
              {
                "id": "a",
                "text": "Array"
              },
              {
                "id": "b",
                "text": "Hash map with key → list of (timestamp, value)"
              },
              {
                "id": "c",
                "text": "Sorted set"
              },
              {
                "id": "d",
                "text": "Queue"
              }
            ],
            "correct": "b",
            "explanation": "Need O(1) key lookup. Each key has multiple (timestamp, value) pairs.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "The constraint \"timestamps are strictly increasing\" means:",
            "options": [
              {
                "id": "a",
                "text": "We must sort after each insert"
              },
              {
                "id": "b",
                "text": "Appending maintains sorted order"
              },
              {
                "id": "c",
                "text": "We need a heap"
              },
              {
                "id": "d",
                "text": "Order doesn't matter"
              }
            ],
            "correct": "b",
            "explanation": "New timestamps are always larger, so appending naturally keeps list sorted.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "get(key, timestamp) should return:",
            "options": [
              {
                "id": "a",
                "text": "Exact match or nothing"
              },
              {
                "id": "b",
                "text": "Value with smallest timestamp"
              },
              {
                "id": "c",
                "text": "Value with largest timestamp ≤ query"
              },
              {
                "id": "d",
                "text": "Value with smallest timestamp > query"
              }
            ],
            "correct": "c",
            "explanation": "\"Most recent before or at this time\" = largest timestamp that doesn't exceed query.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We need binary search to find:",
            "options": [
              {
                "id": "a",
                "text": "Exact timestamp match"
              },
              {
                "id": "b",
                "text": "Rightmost timestamp ≤ query (upper bound - 1)"
              },
              {
                "id": "c",
                "text": "Leftmost timestamp ≥ query"
              },
              {
                "id": "d",
                "text": "Any timestamp"
              }
            ],
            "correct": "b",
            "explanation": "We want the largest timestamp not exceeding query. This is floor/predecessor search.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If no timestamp ≤ query exists:",
            "options": [
              {
                "id": "a",
                "text": "Return the first value"
              },
              {
                "id": "b",
                "text": "Return the last value"
              },
              {
                "id": "c",
                "text": "Return empty string"
              },
              {
                "id": "d",
                "text": "Throw error"
              }
            ],
            "correct": "c",
            "explanation": "Problem states to return \"\" if no valid timestamp found.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "With n entries for a key, get() takes:",
            "options": [
              {
                "id": "a",
                "text": "O(1)"
              },
              {
                "id": "b",
                "text": "O(log n)"
              },
              {
                "id": "c",
                "text": "O(n)"
              },
              {
                "id": "d",
                "text": "O(n log n)"
              }
            ],
            "correct": "b",
            "explanation": "Binary search on sorted list of timestamps.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Store (timestamp, value) pairs per key. Timestamps increase so list stays sorted. Binary search for largest timestamp ≤ query.",
        "pattern": "Binary Search",
        "keyInsight": "Timestamps are always increasing. Store (timestamp, value) pairs per key in sorted order. Binary search for largest timestamp ≤ query.",
        "timeComplexity": "set: O(1), get: O(log n)",
        "spaceComplexity": "O(total entries)",
        "triggerWords": [
          "time based key-value store",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class TimeMap:\n    def __init__(self):\n        self.store = {}  # key -> [(timestamp, value), ...]\n    \n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.store:\n            self.store[key] = []\n        self.store[key].append((timestamp, value))\n    \n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"\n        \n        values = self.store[key]\n        left, right = 0, len(values) - 1\n        result = \"\"\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if values[mid][0] <= timestamp:\n                result = values[mid][1]\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return result"
      },
      {
        "id": "07-median-of-two-sorted-arrays",
        "slug": "median-of-two-sorted-arrays",
        "title": "Median of Two Sorted Arrays",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "median-of-two-sorted-arrays"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
          {
            "input": "nums1 = [1,3], nums2 = [2]",
            "output": "2.0",
            "explanation": "merged = [1,2,3], median = 2"
          },
          {
            "input": "nums1 = [1,2], nums2 = [3,4]",
            "output": "2.5",
            "explanation": "merged = [1,2,3,4], median = (2+3)/2 = 2.5"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For n elements, the median is:",
            "options": [
              {
                "id": "a",
                "text": "The first element"
              },
              {
                "id": "b",
                "text": "The last element"
              },
              {
                "id": "c",
                "text": "Middle element (odd n) or average of two middle (even n)"
              },
              {
                "id": "d",
                "text": "The maximum element"
              }
            ],
            "correct": "c",
            "explanation": "Median = value that separates the higher half from lower half.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "For total = m + n elements, the left partition should contain:",
            "options": [
              {
                "id": "a",
                "text": "(m + n) / 2 elements always"
              },
              {
                "id": "b",
                "text": "(m + n + 1) / 2 elements"
              },
              {
                "id": "c",
                "text": "m elements"
              },
              {
                "id": "d",
                "text": "n elements"
              }
            ],
            "correct": "b",
            "explanation": "For odd total, include the median in left. For even total, this equals half. Works for both.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If we take i elements from nums1 for left partition, from nums2 we take:",
            "options": [
              {
                "id": "a",
                "text": "i elements"
              },
              {
                "id": "b",
                "text": "half - i elements"
              },
              {
                "id": "c",
                "text": "n - i elements"
              },
              {
                "id": "d",
                "text": "m - i elements"
              }
            ],
            "correct": "b",
            "explanation": "Total left = half = i + j, so j = half - i.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "A partition is valid when:",
            "options": [
              {
                "id": "a",
                "text": "Left and right have equal size"
              },
              {
                "id": "b",
                "text": "nums1[i-1] ≤ nums2[j] AND nums2[j-1] ≤ nums1[i]"
              },
              {
                "id": "c",
                "text": "All elements are equal"
              },
              {
                "id": "d",
                "text": "i = j"
              }
            ],
            "correct": "b",
            "explanation": "max(left of nums1) ≤ min(right of nums2), AND max(left of nums2) ≤ min(right of nums1). This ensures left ≤ right overall.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If nums1[i-1] > nums2[j], we should:",
            "options": [
              {
                "id": "a",
                "text": "Increase i (take more from nums1)"
              },
              {
                "id": "b",
                "text": "Decrease i (take fewer from nums1)"
              },
              {
                "id": "c",
                "text": "Increase j"
              },
              {
                "id": "d",
                "text": "Start over"
              }
            ],
            "correct": "b",
            "explanation": "nums1's left side has an element too large. Move partition left in nums1 to reduce it.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We binary search on the smaller array because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "Ensures j = half - i is always valid (non-negative)"
              },
              {
                "id": "c",
                "text": "Smaller arrays are always sorted"
              },
              {
                "id": "d",
                "text": "No particular reason"
              }
            ],
            "correct": "b",
            "explanation": "If we search on larger array, i might be so large that j becomes negative. Searching smaller ensures 0 ≤ j ≤ n.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Binary search partition point in smaller array. Valid partition: max(left_halves) ≤ min(right_halves). Median from partition boundaries.",
        "pattern": "Binary Search",
        "keyInsight": "Binary search for a partition: split both arrays such that left partition has exactly half the total elements, and all left elements ≤ all right elements.",
        "timeComplexity": "O(log(min(m,n)))",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "median of two sorted arrays",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:\n    # Ensure nums1 is smaller\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    half = (m + n + 1) // 2\n    left, right = 0, m\n    \n    while left <= right:\n        i = (left + right) // 2  # Partition in nums1\n        j = half - i              # Partition in nums2\n        \n        left1 = nums1[i-1] if i > 0 else float('-inf')\n        right1 = nums1[i] if i < m else float('inf')\n        left2 = nums2[j-1] if j > 0 else float('-inf')\n        right2 = nums2[j] if j < n else float('inf')\n        \n        if left1 <= right2 and left2 <= right1:\n            # Valid partition\n            if (m + n) % 2 == 1:\n                return max(left1, left2)\n            return (max(left1, left2) + min(right1, right2)) / 2\n        elif left1 > right2:\n            right = i - 1\n        else:\n            left = i + 1\n    \n    return 0.0"
      }
    ],
    "linked-list": [
      {
        "id": "01-reverse-linked-list",
        "slug": "reverse-linked-list",
        "title": "Reverse Linked List",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "reverse-linked-list"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.",
        "examples": [
          {
            "input": "head = [1,2,3,4,5]",
            "output": "[5,4,3,2,1]",
            "explanation": ""
          },
          {
            "input": "head = [1,2]",
            "output": "[2,1]",
            "explanation": ""
          },
          {
            "input": "head = []",
            "output": "[]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To reverse a linked list, we change each node's:",
            "options": [
              {
                "id": "a",
                "text": "Value"
              },
              {
                "id": "b",
                "text": "next pointer"
              },
              {
                "id": "c",
                "text": "Address"
              },
              {
                "id": "d",
                "text": "Nothing, we build new nodes"
              }
            ],
            "correct": "b",
            "explanation": "We don't change values or create nodes. We just redirect pointers.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After setting curr.next = prev, we lose:",
            "options": [
              {
                "id": "a",
                "text": "Reference to prev"
              },
              {
                "id": "b",
                "text": "Reference to curr"
              },
              {
                "id": "c",
                "text": "Reference to the original next node"
              },
              {
                "id": "d",
                "text": "Nothing"
              }
            ],
            "correct": "c",
            "explanation": "curr.next used to point forward. After changing it, we can't reach the rest of the list without saving it first.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "To reverse iteratively, we need how many pointers?",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "2"
              },
              {
                "id": "c",
                "text": "3"
              },
              {
                "id": "d",
                "text": "4"
              }
            ],
            "correct": "c",
            "explanation": "prev (new next), curr (current node), next_temp (saved forward reference).",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "At the start, prev should be:",
            "options": [
              {
                "id": "a",
                "text": "head"
              },
              {
                "id": "b",
                "text": "null/None"
              },
              {
                "id": "c",
                "text": "The last node"
              },
              {
                "id": "d",
                "text": "A new node"
              }
            ],
            "correct": "b",
            "explanation": "After reversal, the original head becomes the tail, pointing to null.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We continue the loop while:",
            "options": [
              {
                "id": "a",
                "text": "prev is not null"
              },
              {
                "id": "b",
                "text": "curr is not null"
              },
              {
                "id": "c",
                "text": "next_temp is not null"
              },
              {
                "id": "d",
                "text": "We've seen n nodes"
              }
            ],
            "correct": "b",
            "explanation": "curr traverses each node. When curr is null, we've processed all nodes.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After the loop, we return:",
            "options": [
              {
                "id": "a",
                "text": "curr (which is null)"
              },
              {
                "id": "b",
                "text": "prev (which is the new head)"
              },
              {
                "id": "c",
                "text": "head (the original head)"
              },
              {
                "id": "d",
                "text": "next_temp"
              }
            ],
            "correct": "b",
            "explanation": "prev ends up pointing to the last node we processed, which is the new head.",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Save next, point current backward, advance. Repeat until end. Return prev as new head.",
        "pattern": "Linked List",
        "keyInsight": "To reverse, change each node's `next` pointer to point to its previous node.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reverse linked list",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reverseList(head: ListNode) -> ListNode:\n    prev = None\n    curr = head\n    \n    while curr:\n        next_temp = curr.next  # Save next\n        curr.next = prev       # Reverse pointer\n        prev = curr            # Move prev forward\n        curr = next_temp       # Move curr forward\n    \n    return prev"
      },
      {
        "id": "02-merge-two-sorted-lists",
        "slug": "merge-two-sorted-lists",
        "title": "Merge Two Sorted Lists",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "merge-two-sorted-lists"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
        "examples": [
          {
            "input": "list1 = [1,2,4], list2 = [1,3,4]",
            "output": "[1,1,2,3,4,4]",
            "explanation": ""
          },
          {
            "input": "list1 = [], list2 = []",
            "output": "[]",
            "explanation": ""
          },
          {
            "input": "list1 = [], list2 = [0]",
            "output": "[0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At each step, we compare:",
            "options": [
              {
                "id": "a",
                "text": "Tails of both lists"
              },
              {
                "id": "b",
                "text": "Heads (current nodes) of both lists"
              },
              {
                "id": "c",
                "text": "All nodes of both lists"
              },
              {
                "id": "d",
                "text": "Random nodes"
              }
            ],
            "correct": "b",
            "explanation": "Both lists are sorted. Smallest remaining element is always at the head of one list.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "If list1.val < list2.val, we:",
            "options": [
              {
                "id": "a",
                "text": "Take node from list2"
              },
              {
                "id": "b",
                "text": "Take node from list1"
              },
              {
                "id": "c",
                "text": "Take from either"
              },
              {
                "id": "d",
                "text": "Swap them"
              }
            ],
            "correct": "b",
            "explanation": "We want sorted order. Smaller goes first.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After appending a node from list1, we:",
            "options": [
              {
                "id": "a",
                "text": "Stay at same position in list1"
              },
              {
                "id": "b",
                "text": "Advance list1 to list1.next"
              },
              {
                "id": "c",
                "text": "Advance list2"
              },
              {
                "id": "d",
                "text": "Reset to beginning"
              }
            ],
            "correct": "b",
            "explanation": "We've used this node. Move to the next candidate.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "A dummy node helps because:",
            "options": [
              {
                "id": "a",
                "text": "It stores extra data"
              },
              {
                "id": "b",
                "text": "It simplifies handling the head of result"
              },
              {
                "id": "c",
                "text": "It makes the list circular"
              },
              {
                "id": "d",
                "text": "It's required for linked lists"
              }
            ],
            "correct": "b",
            "explanation": "Without dummy, we need special logic for the first node. With dummy, we always append to dummy's current position.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "When list1 becomes null (exhausted):",
            "options": [
              {
                "id": "a",
                "text": "Return null"
              },
              {
                "id": "b",
                "text": "Append remaining list2"
              },
              {
                "id": "c",
                "text": "Stop immediately"
              },
              {
                "id": "d",
                "text": "Restart list1"
              }
            ],
            "correct": "b",
            "explanation": "Remaining nodes of list2 are already sorted. Just attach them.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We return:",
            "options": [
              {
                "id": "a",
                "text": "The dummy node"
              },
              {
                "id": "b",
                "text": "dummy.next"
              },
              {
                "id": "c",
                "text": "list1"
              },
              {
                "id": "d",
                "text": "list2"
              }
            ],
            "correct": "b",
            "explanation": "Dummy is just a placeholder. The actual merged list starts at dummy.next.",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Compare heads, take smaller, advance that pointer. Use dummy node. Attach remaining list when one exhausts.",
        "pattern": "Linked List",
        "keyInsight": "Compare heads of both lists. Take the smaller one, advance that list's pointer. Repeat.",
        "timeComplexity": "O(n + m)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "merge two sorted lists",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def mergeTwoLists(list1: ListNode, list2: ListNode) -> ListNode:\n    dummy = ListNode()\n    curr = dummy\n    \n    while list1 and list2:\n        if list1.val <= list2.val:\n            curr.next = list1\n            list1 = list1.next\n        else:\n            curr.next = list2\n            list2 = list2.next\n        curr = curr.next\n    \n    # Attach remaining nodes\n    curr.next = list1 if list1 else list2\n    \n    return dummy.next"
      },
      {
        "id": "03-linked-list-cycle",
        "slug": "linked-list-cycle",
        "title": "Linked List Cycle",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "linked-list-cycle"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer.\n\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.",
        "examples": [
          {
            "input": "head = [3,2,0,-4], pos = 1",
            "output": "true",
            "explanation": "Tail connects to node at index 1 (0-indexed)."
          },
          {
            "input": "head = [1,2], pos = 0",
            "output": "true",
            "explanation": "Tail connects to node at index 0."
          },
          {
            "input": "head = [1], pos = -1",
            "output": "false",
            "explanation": "No cycle."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To detect a cycle, we could:",
            "options": [
              {
                "id": "a",
                "text": "Store visited nodes in a set and check for repeats"
              },
              {
                "id": "b",
                "text": "Count the number of nodes"
              },
              {
                "id": "c",
                "text": "Reverse the list"
              },
              {
                "id": "d",
                "text": "Check if head is null"
              }
            ],
            "correct": "a",
            "explanation": "If we see the same node twice, there's a cycle. But this uses O(n) space.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "If fast moves 2x speed of slow, in a cycle:",
            "options": [
              {
                "id": "a",
                "text": "They'll never meet"
              },
              {
                "id": "b",
                "text": "Fast will eventually catch slow"
              },
              {
                "id": "c",
                "text": "Slow catches fast"
              },
              {
                "id": "d",
                "text": "Both reach the end"
              }
            ],
            "correct": "b",
            "explanation": "In a cycle, fast gains 1 position on slow each step. Eventually the gap closes to 0.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "If slow is at position S and fast is at position F in a cycle:",
            "options": [
              {
                "id": "a",
                "text": "The gap increases"
              },
              {
                "id": "b",
                "text": "The gap stays same"
              },
              {
                "id": "c",
                "text": "The gap decreases by 1 each step"
              },
              {
                "id": "d",
                "text": "The gap oscillates"
              }
            ],
            "correct": "c",
            "explanation": "Fast moves 2, slow moves 1. Relative movement = 1. Gap shrinks by 1.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "If there's no cycle:",
            "options": [
              {
                "id": "a",
                "text": "Slow reaches null first"
              },
              {
                "id": "b",
                "text": "Fast reaches null first"
              },
              {
                "id": "c",
                "text": "Neither reaches null"
              },
              {
                "id": "d",
                "text": "Both reach null together"
              }
            ],
            "correct": "b",
            "explanation": "Fast moves faster, so it hits the end of the list first (or fast.next is null).",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "We continue the loop while:",
            "options": [
              {
                "id": "a",
                "text": "slow is not null"
              },
              {
                "id": "b",
                "text": "fast is not null AND fast.next is not null"
              },
              {
                "id": "c",
                "text": "slow != fast"
              },
              {
                "id": "d",
                "text": "We've visited n nodes"
              }
            ],
            "correct": "b",
            "explanation": "Fast moves 2 steps, so we need both fast and fast.next to exist.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "If slow == fast during traversal:",
            "options": [
              {
                "id": "a",
                "text": "There might be a cycle"
              },
              {
                "id": "b",
                "text": "There is definitely a cycle"
              },
              {
                "id": "c",
                "text": "There is no cycle"
              },
              {
                "id": "d",
                "text": "The list is empty"
              }
            ],
            "correct": "b",
            "explanation": "For them to meet, fast must have gone around and caught up. Only possible in a cycle.",
            "conceptId": "floyd-cycle"
          }
        ],
        "oneLiner": "Slow moves 1, fast moves 2. If cycle exists, fast catches slow. If no cycle, fast reaches null.",
        "pattern": "Linked List",
        "keyInsight": "Fast and slow pointers: if there's a cycle, they will eventually meet.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "linked list cycle",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def hasCycle(head: ListNode) -> bool:\n    slow = fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        \n        if slow == fast:\n            return True\n    \n    return False"
      },
      {
        "id": "04-reorder-list",
        "slug": "reorder-list",
        "title": "Reorder List",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "reorder-list"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given the head of a singly linked list. The list can be represented as:\n```\nL0 → L1 → L2 → ... → Ln-1 → Ln\n```\n\nReorder the list to be in the following form:\n```\nL0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...\n```\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.",
        "examples": [
          {
            "input": "head = [1,2,3,4]",
            "output": "[1,4,2,3]",
            "explanation": ""
          },
          {
            "input": "head = [1,2,3,4,5]",
            "output": "[1,5,2,4,3]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To access nodes from the end, we need to:",
            "options": [
              {
                "id": "a",
                "text": "Use recursion only"
              },
              {
                "id": "b",
                "text": "Reverse the entire list"
              },
              {
                "id": "c",
                "text": "Reverse just the second half"
              },
              {
                "id": "d",
                "text": "Copy to an array"
              }
            ],
            "correct": "c",
            "explanation": "We need first half forward, second half backward. Reverse only second half.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "To find the middle of a linked list efficiently:",
            "options": [
              {
                "id": "a",
                "text": "Count nodes, then traverse to n/2"
              },
              {
                "id": "b",
                "text": "Use fast and slow pointers"
              },
              {
                "id": "c",
                "text": "Use a stack"
              },
              {
                "id": "d",
                "text": "Guess"
              }
            ],
            "correct": "b",
            "explanation": "When fast reaches end, slow is at middle. O(n) time, O(1) space.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "For [1,2,3,4,5], the middle element (3) should:",
            "options": [
              {
                "id": "a",
                "text": "Go in the first half"
              },
              {
                "id": "b",
                "text": "Go in the second half"
              },
              {
                "id": "c",
                "text": "Be removed"
              },
              {
                "id": "d",
                "text": "Stay at its position"
              }
            ],
            "correct": "a",
            "explanation": "After merge, order is 1,5,2,4,3. The middle element ends up at the end of the result.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "When merging [1,2,3] and [5,4], we alternate:",
            "options": [
              {
                "id": "a",
                "text": "All of first, then all of second"
              },
              {
                "id": "b",
                "text": "1 from first, 1 from second, repeat"
              },
              {
                "id": "c",
                "text": "2 from first, 2 from second"
              },
              {
                "id": "d",
                "text": "Randomly"
              }
            ],
            "correct": "b",
            "explanation": "The pattern is L0, Ln, L1, Ln-1, ... — alternating from front and back.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We stop merging when:",
            "options": [
              {
                "id": "a",
                "text": "First half is exhausted"
              },
              {
                "id": "b",
                "text": "Second half is exhausted"
              },
              {
                "id": "c",
                "text": "Both are exhausted"
              },
              {
                "id": "d",
                "text": "They're equal length"
              }
            ],
            "correct": "b",
            "explanation": "Second half is equal or shorter. When it's done, first half might have one node left (the original middle).",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "This problem should be solved in:",
            "options": [
              {
                "id": "a",
                "text": "O(n) space"
              },
              {
                "id": "b",
                "text": "O(log n) space"
              },
              {
                "id": "c",
                "text": "O(1) space"
              },
              {
                "id": "d",
                "text": "Space doesn't matter"
              }
            ],
            "correct": "c",
            "explanation": "All three steps (find middle, reverse, merge) can be done in-place with O(1) extra space.",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Find middle, reverse second half, merge alternately. Three fundamental operations combined.",
        "pattern": "Linked List",
        "keyInsight": "Three steps: find middle with slow/fast, reverse second half, merge alternately.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reorder list",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reorderList(head: ListNode) -> None:\n    if not head or not head.next:\n        return\n    \n    # 1. Find middle with slow/fast\n    slow = fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # 2. Reverse second half\n    prev, curr = None, slow.next\n    slow.next = None  # Cut the list\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    # 3. Merge two halves alternately\n    first, second = head, prev\n    while second:\n        tmp1, tmp2 = first.next, second.next\n        first.next = second\n        second.next = tmp1\n        first, second = tmp1, tmp2"
      },
      {
        "id": "05-remove-nth-node-from-end",
        "slug": "remove-nth-node-from-end",
        "title": "Remove Nth Node From End of List",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "remove-nth-node-from-end-of-list"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `head` of a linked list, remove the `n`th node from the end of the list and return its head.",
        "examples": [
          {
            "input": "head = [1,2,3,4,5], n = 2",
            "output": "[1,2,3,5]",
            "explanation": "Remove 4 (2nd from end)"
          },
          {
            "input": "head = [1], n = 1",
            "output": "[]",
            "explanation": ""
          },
          {
            "input": "head = [1,2], n = 1",
            "output": "[1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A two-pass solution would:",
            "options": [
              {
                "id": "a",
                "text": "First count nodes, then remove (n-k+1)th"
              },
              {
                "id": "b",
                "text": "Not work for linked lists"
              },
              {
                "id": "c",
                "text": "Be faster than one-pass"
              },
              {
                "id": "d",
                "text": "Use less memory"
              }
            ],
            "correct": "a",
            "explanation": "Count length L, then remove node at position L-n+1 (0-indexed: L-n). This works but requires 2 traversals.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "If fast is n steps ahead of slow, when fast is at end:",
            "options": [
              {
                "id": "a",
                "text": "slow is at the target node"
              },
              {
                "id": "b",
                "text": "slow is right before the target node"
              },
              {
                "id": "c",
                "text": "slow is n steps past the target"
              },
              {
                "id": "d",
                "text": "slow is at the beginning"
              }
            ],
            "correct": "b",
            "explanation": "We want slow to stop at the node BEFORE the target, so we can do slow.next = slow.next.next.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "To create a gap of n, we:",
            "options": [
              {
                "id": "a",
                "text": "Move slow n steps first"
              },
              {
                "id": "b",
                "text": "Move fast n steps first"
              },
              {
                "id": "c",
                "text": "Move both n steps"
              },
              {
                "id": "d",
                "text": "Start fast at position n"
              }
            ],
            "correct": "b",
            "explanation": "Advance fast by n steps. Now fast is n ahead of slow (which is still at start).",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If we need to remove the head (n equals list length):",
            "options": [
              {
                "id": "a",
                "text": "We can't use this method"
              },
              {
                "id": "b",
                "text": "Use a dummy node before head"
              },
              {
                "id": "c",
                "text": "Return null always"
              },
              {
                "id": "d",
                "text": "Move slow backward"
              }
            ],
            "correct": "b",
            "explanation": "Dummy node handles edge case. slow.next = slow.next.next works even when target is head.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We stop advancing when:",
            "options": [
              {
                "id": "a",
                "text": "fast is null"
              },
              {
                "id": "b",
                "text": "fast.next is null"
              },
              {
                "id": "c",
                "text": "slow.next is null"
              },
              {
                "id": "d",
                "text": "We've moved n times"
              }
            ],
            "correct": "a",
            "explanation": "We want slow to be one before target. Stop when fast reaches null.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "After fast is n ahead, we:",
            "options": [
              {
                "id": "a",
                "text": "Move only fast"
              },
              {
                "id": "b",
                "text": "Move only slow"
              },
              {
                "id": "c",
                "text": "Move both together until fast is null"
              },
              {
                "id": "d",
                "text": "Reverse the list"
              }
            ],
            "correct": "c",
            "explanation": "Maintain the gap. When fast reaches null, slow is in position.",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "Create n-step gap between fast and slow. Move both until fast at end. Slow is before target. Delete slow.next.",
        "pattern": "Linked List",
        "keyInsight": "Use two pointers with a gap of n nodes. When the fast pointer reaches the end, the slow pointer is at the node before the target.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "remove nth node from end of list",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def removeNthFromEnd(head: ListNode, n: int) -> ListNode:\n    dummy = ListNode(0, head)\n    slow = fast = dummy\n    \n    # Move fast n+1 steps ahead\n    for _ in range(n + 1):\n        fast = fast.next\n    \n    # Move both until fast reaches end\n    while fast:\n        slow = slow.next\n        fast = fast.next\n    \n    # Remove the nth node\n    slow.next = slow.next.next\n    \n    return dummy.next"
      },
      {
        "id": "06-copy-list-with-random-pointer",
        "slug": "copy-list-with-random-pointer",
        "title": "Copy List with Random Pointer",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "copy-list-with-random-pointer"
        ],
        "estimatedTime": 5,
        "problemStatement": "A linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\n\nConstruct a deep copy of the list. The deep copy should consist of exactly `n` brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state.\n\nReturn the head of the copied linked list.",
        "examples": [
          {
            "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
            "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Simply creating nodes as we traverse fails because:",
            "options": [
              {
                "id": "a",
                "text": "We can't create new nodes"
              },
              {
                "id": "b",
                "text": "Random might point to a node not yet created"
              },
              {
                "id": "c",
                "text": "Next pointers are complex"
              },
              {
                "id": "d",
                "text": "Linked lists can't be copied"
              }
            ],
            "correct": "b",
            "explanation": "If node 1's random points to node 5, when we're at node 1, node 5's copy doesn't exist yet.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "Using a hash map {old_node: new_node} helps because:",
            "options": [
              {
                "id": "a",
                "text": "It stores values"
              },
              {
                "id": "b",
                "text": "We can look up corresponding new node for any old node"
              },
              {
                "id": "c",
                "text": "It's faster"
              },
              {
                "id": "d",
                "text": "It's required for linked lists"
              }
            ],
            "correct": "b",
            "explanation": "When setting random, we find old_node's random in the map to get the new target.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Interleaving means placing each new node:",
            "options": [
              {
                "id": "a",
                "text": "At the end of the list"
              },
              {
                "id": "b",
                "text": "At the beginning of the list"
              },
              {
                "id": "c",
                "text": "Right after its corresponding old node"
              },
              {
                "id": "d",
                "text": "In a separate list"
              }
            ],
            "correct": "c",
            "explanation": "old1 → new1 → old2 → new2 → ... This lets us access new nodes without a map.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "With interleaving, if old.random = X, then new.random should be:",
            "options": [
              {
                "id": "a",
                "text": "X"
              },
              {
                "id": "b",
                "text": "X.next"
              },
              {
                "id": "c",
                "text": "X.prev"
              },
              {
                "id": "d",
                "text": "null"
              }
            ],
            "correct": "b",
            "explanation": "X.next is the new copy of X (due to interleaving). So old.random.next = corresponding new node.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After setting all pointers, we need to:",
            "options": [
              {
                "id": "a",
                "text": "Leave the lists interleaved"
              },
              {
                "id": "b",
                "text": "Separate the lists (restore original and extract copy)"
              },
              {
                "id": "c",
                "text": "Delete the original list"
              },
              {
                "id": "d",
                "text": "Reverse the copy"
              }
            ],
            "correct": "b",
            "explanation": "We need to return a clean copy and restore the original list to its state.",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Challenge: random points to not-yet-created nodes. Solution: create all nodes first (map them), then set pointers. Or interleave for O(1) space.",
        "pattern": "Linked List",
        "keyInsight": "Map old nodes to new nodes. When setting random pointers, look up the corresponding new node.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "copy list with random pointer",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def copyRandomList(head: Node) -> Node:\n    if not head:\n        return None\n    \n    # Map old nodes to new nodes\n    old_to_new = {}\n    \n    # First pass: create all new nodes\n    curr = head\n    while curr:\n        old_to_new[curr] = Node(curr.val)\n        curr = curr.next\n    \n    # Second pass: set next and random pointers\n    curr = head\n    while curr:\n        old_to_new[curr].next = old_to_new.get(curr.next)\n        old_to_new[curr].random = old_to_new.get(curr.random)\n        curr = curr.next\n    \n    return old_to_new[head]"
      },
      {
        "id": "07-merge-k-sorted-lists",
        "slug": "merge-k-sorted-lists",
        "title": "Merge K Sorted Lists",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "merge-k-sorted-lists"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.",
        "examples": [
          {
            "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
            "output": "[1,1,2,3,4,4,5,6]",
            "explanation": ""
          },
          {
            "input": "lists = []",
            "output": "[]",
            "explanation": ""
          },
          {
            "input": "lists = [[]]",
            "output": "[]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Merge lists one by one: merge(merge(merge(l1,l2),l3),l4)... Time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(N)"
              },
              {
                "id": "b",
                "text": "O(N log k)"
              },
              {
                "id": "c",
                "text": "O(kN)"
              },
              {
                "id": "d",
                "text": "O(N²)"
              }
            ],
            "correct": "c",
            "explanation": "First merge is 2n, second is 3n, ..., total ≈ (2+3+...+k)n = O(kN).",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "Pair up lists and merge pairs, then repeat: Time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(N)"
              },
              {
                "id": "b",
                "text": "O(N log k)"
              },
              {
                "id": "c",
                "text": "O(kN)"
              },
              {
                "id": "d",
                "text": "O(N²)"
              }
            ],
            "correct": "b",
            "explanation": "log k levels of merging, each level processes all N nodes total.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "Using a min-heap of size k helps because:",
            "options": [
              {
                "id": "a",
                "text": "We can find minimum of k elements in O(log k)"
              },
              {
                "id": "b",
                "text": "It sorts the lists"
              },
              {
                "id": "c",
                "text": "It reduces total nodes"
              },
              {
                "id": "d",
                "text": "It merges pairs"
              }
            ],
            "correct": "a",
            "explanation": "Always extract minimum head in O(log k) instead of O(k) linear scan.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "The heap should store:",
            "options": [
              {
                "id": "a",
                "text": "All nodes from all lists"
              },
              {
                "id": "b",
                "text": "Just the head of each non-empty list"
              },
              {
                "id": "c",
                "text": "Only values, not nodes"
              },
              {
                "id": "d",
                "text": "Only the smallest node"
              }
            ],
            "correct": "b",
            "explanation": "We only need to compare current candidates (heads). After picking one, add its next to the heap.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For each of N nodes in the result:",
            "options": [
              {
                "id": "a",
                "text": "One push and one pop"
              },
              {
                "id": "b",
                "text": "k pushes and k pops"
              },
              {
                "id": "c",
                "text": "log k pushes"
              },
              {
                "id": "d",
                "text": "No heap operations"
              }
            ],
            "correct": "a",
            "explanation": "Pop the minimum, push its next (if exists). Both are O(log k).",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "N nodes, each requiring O(log k) heap operations:",
            "options": [
              {
                "id": "a",
                "text": "O(N)"
              },
              {
                "id": "b",
                "text": "O(N log k)"
              },
              {
                "id": "c",
                "text": "O(kN)"
              },
              {
                "id": "d",
                "text": "O(N log N)"
              }
            ],
            "correct": "b",
            "explanation": "N × O(log k) = O(N log k).",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Min-heap of k heads: always pop smallest, push its next. O(N log k) — each node does one push and one pop.",
        "pattern": "Linked List",
        "keyInsight": "Use a min-heap to always pick the smallest among k candidates.",
        "timeComplexity": "O(N log k)",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "merge k sorted lists",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef mergeKLists(lists: List[ListNode]) -> ListNode:\n    # Min heap: (value, index, node)\n    heap = []\n    \n    # Add head of each non-empty list\n    for i, node in enumerate(lists):\n        if node:\n            heapq.heappush(heap, (node.val, i, node))\n    \n    dummy = ListNode()\n    curr = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        curr.next = node\n        curr = curr.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next"
      },
      {
        "id": "08-reverse-nodes-in-k-group",
        "slug": "reverse-nodes-in-k-group",
        "title": "Reverse Nodes in K-Group",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "reverse-nodes-in-k-group"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
        "examples": [
          {
            "input": "head = [1,2,3,4,5], k = 2",
            "output": "[2,1,4,3,5]",
            "explanation": ""
          },
          {
            "input": "head = [1,2,3,4,5], k = 3",
            "output": "[3,2,1,4,5]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Before reversing a group, we must:",
            "options": [
              {
                "id": "a",
                "text": "Reverse first, check later"
              },
              {
                "id": "b",
                "text": "Check if k nodes exist"
              },
              {
                "id": "c",
                "text": "Count all nodes in list"
              },
              {
                "id": "d",
                "text": "Check if next group exists"
              }
            ],
            "correct": "b",
            "explanation": "If fewer than k nodes remain, don't reverse this group.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "To reverse k nodes, we use:",
            "options": [
              {
                "id": "a",
                "text": "Stack of size k"
              },
              {
                "id": "b",
                "text": "Standard reversal, but stop after k iterations"
              },
              {
                "id": "c",
                "text": "Recursion only"
              },
              {
                "id": "d",
                "text": "Array conversion"
              }
            ],
            "correct": "b",
            "explanation": "Same reversal logic, just limited to k steps.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After reversing [2, 3, 4] to [4, 3, 2], we need:",
            "options": [
              {
                "id": "a",
                "text": "Connect 4 to what came before, 2 to what comes after"
              },
              {
                "id": "b",
                "text": "Only connect 4 to what came before"
              },
              {
                "id": "c",
                "text": "No connections needed"
              },
              {
                "id": "d",
                "text": "Reverse the connections"
              }
            ],
            "correct": "a",
            "explanation": "The new head (4) must link to previous group's tail. The new tail (2) must link to next group's head.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "For each group, we track:",
            "options": [
              {
                "id": "a",
                "text": "Only the group's head"
              },
              {
                "id": "b",
                "text": "Previous group's tail and current group's head/tail"
              },
              {
                "id": "c",
                "text": "All nodes in all groups"
              },
              {
                "id": "d",
                "text": "Just the first node"
              }
            ],
            "correct": "b",
            "explanation": "prev_group_end points to where new head should attach. group_start becomes the new tail after reversal.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "A dummy node before head helps:",
            "options": [
              {
                "id": "a",
                "text": "Handle first group uniformly (no special case)"
              },
              {
                "id": "b",
                "text": "Store extra data"
              },
              {
                "id": "c",
                "text": "Double the list length"
              },
              {
                "id": "d",
                "text": "Nothing"
              }
            ],
            "correct": "a",
            "explanation": "Even the first group has a \"previous\" (the dummy), simplifying connections.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We stop when:",
            "options": [
              {
                "id": "a",
                "text": "We've done one reversal"
              },
              {
                "id": "b",
                "text": "Fewer than k nodes remain"
              },
              {
                "id": "c",
                "text": "We reach the original end"
              },
              {
                "id": "d",
                "text": "k groups are done"
              }
            ],
            "correct": "b",
            "explanation": "Each iteration checks if k nodes exist. If not, stop (leave remaining as is).",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Process k nodes at a time: check k exist, reverse them, connect to previous tail and next head, repeat until fewer than k remain.",
        "pattern": "Linked List",
        "keyInsight": "Break the problem into: check if k nodes exist, reverse k nodes, connect groups properly.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reverse nodes in k-group",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reverseKGroup(head: ListNode, k: int) -> ListNode:\n    dummy = ListNode(0, head)\n    group_prev = dummy\n    \n    while True:\n        # Check if k nodes exist\n        kth = group_prev\n        for _ in range(k):\n            kth = kth.next\n            if not kth:\n                return dummy.next\n        \n        group_next = kth.next\n        \n        # Reverse k nodes\n        prev, curr = kth.next, group_prev.next\n        while curr != group_next:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        \n        # Connect with previous group\n        tmp = group_prev.next\n        group_prev.next = kth\n        group_prev = tmp\n    \n    return dummy.next"
      }
    ],
    "trees": [
      {
        "id": "01-invert-binary-tree",
        "slug": "invert-binary-tree",
        "title": "Invert Binary Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "invert-binary-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, invert the tree, and return its root.\n\nInverting a binary tree means swapping every left child with its corresponding right child.",
        "examples": [
          {
            "input": "root = [4,2,7,1,3,6,9]",
            "output": "[4,7,2,9,6,3,1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For a null node, we:",
            "options": [
              {
                "id": "a",
                "text": "Swap its children"
              },
              {
                "id": "b",
                "text": "Return null"
              },
              {
                "id": "c",
                "text": "Create new children"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "b",
            "explanation": "Nothing to swap in an empty tree. Just return null.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "At each node, we swap:",
            "options": [
              {
                "id": "a",
                "text": "Node values"
              },
              {
                "id": "b",
                "text": "Left and right child pointers"
              },
              {
                "id": "c",
                "text": "Parent and child"
              },
              {
                "id": "d",
                "text": "Node addresses"
              }
            ],
            "correct": "b",
            "explanation": "Swap the subtrees, not values. Node keeps its value, but its children switch sides.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "At each node, we can:",
            "options": [
              {
                "id": "a",
                "text": "Only swap then recurse"
              },
              {
                "id": "b",
                "text": "Only recurse then swap"
              },
              {
                "id": "c",
                "text": "Either order works"
              },
              {
                "id": "d",
                "text": "Neither order works"
              }
            ],
            "correct": "c",
            "explanation": "Swap first, then invert children. Or invert children first, then swap. Both produce correct result.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "After swapping, we:",
            "options": [
              {
                "id": "a",
                "text": "Stop (done)"
              },
              {
                "id": "b",
                "text": "Invert both children recursively"
              },
              {
                "id": "c",
                "text": "Only invert one child"
              },
              {
                "id": "d",
                "text": "Go to parent"
              }
            ],
            "correct": "b",
            "explanation": "Each subtree needs to be inverted too. Recurse on both.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "After inverting, we return:",
            "options": [
              {
                "id": "a",
                "text": "null"
              },
              {
                "id": "b",
                "text": "The original root"
              },
              {
                "id": "c",
                "text": "A new node"
              },
              {
                "id": "d",
                "text": "The left child"
              }
            ],
            "correct": "b",
            "explanation": "Return the (now inverted) root so caller can connect it.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Iteratively, we can use:",
            "options": [
              {
                "id": "a",
                "text": "Just a counter"
              },
              {
                "id": "b",
                "text": "BFS or DFS with queue/stack"
              },
              {
                "id": "c",
                "text": "Sorting"
              },
              {
                "id": "d",
                "text": "Binary search"
              }
            ],
            "correct": "b",
            "explanation": "Visit each node (any order), swap its children. Queue (BFS) or stack (DFS) both work.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "At each node, swap left and right children. Recursively invert both subtrees. Return root.",
        "pattern": "Tree Traversal",
        "keyInsight": "At each node, swap its left and right children. Then recursively do the same for each child.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "triggerWords": [
          "invert binary tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def invertTree(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    \n    # Swap left and right children\n    root.left, root.right = root.right, root.left\n    \n    # Recursively invert subtrees\n    invertTree(root.left)\n    invertTree(root.right)\n    \n    return root"
      },
      {
        "id": "02-maximum-depth-of-binary-tree",
        "slug": "maximum-depth-of-binary-tree",
        "title": "Maximum Depth of Binary Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "maximum-depth-of-binary-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
        "examples": [
          {
            "input": "root = [3,9,20,null,null,15,7]",
            "output": "3",
            "explanation": ""
          },
          {
            "input": "root = [1,null,2]",
            "output": "2",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The depth of an empty tree (null) is:",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "-1"
              },
              {
                "id": "c",
                "text": "0"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "c",
            "explanation": "No nodes means depth is 0. This is the foundation for counting.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "A tree with just a root (no children) has depth:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "2"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "One node = depth 1. Base case 0 + 1 = 1.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "depth(node) = ?",
            "options": [
              {
                "id": "a",
                "text": "depth(left) + depth(right)"
              },
              {
                "id": "b",
                "text": "max(depth(left), depth(right))"
              },
              {
                "id": "c",
                "text": "1 + max(depth(left), depth(right))"
              },
              {
                "id": "d",
                "text": "min(depth(left), depth(right))"
              }
            ],
            "correct": "c",
            "explanation": "Take the deeper subtree, add 1 for current node.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "We use max because:",
            "options": [
              {
                "id": "a",
                "text": "We want total nodes"
              },
              {
                "id": "b",
                "text": "We want the longest path"
              },
              {
                "id": "c",
                "text": "Sum is always larger"
              },
              {
                "id": "d",
                "text": "Random choice"
              }
            ],
            "correct": "b",
            "explanation": "We're finding maximum depth. The longest path determines it.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "This is an example of:",
            "options": [
              {
                "id": "a",
                "text": "Pre-order traversal"
              },
              {
                "id": "b",
                "text": "In-order traversal"
              },
              {
                "id": "c",
                "text": "Post-order traversal"
              },
              {
                "id": "d",
                "text": "Level-order traversal"
              }
            ],
            "correct": "c",
            "explanation": "We process children first, then combine results at parent. That's post-order.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "For iterative solution, we can use:",
            "options": [
              {
                "id": "a",
                "text": "BFS and count levels"
              },
              {
                "id": "b",
                "text": "Sorting"
              },
              {
                "id": "c",
                "text": "Binary search"
              },
              {
                "id": "d",
                "text": "Two pointers"
              }
            ],
            "correct": "a",
            "explanation": "Each level of BFS = one depth. Count total levels.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "Depth = 1 + max(left depth, right depth). Null has depth 0.",
        "pattern": "Tree Traversal",
        "keyInsight": "Depth of a node = 1 + max(depth of left subtree, depth of right subtree)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "triggerWords": [
          "maximum depth of binary tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxDepth(root: TreeNode) -> int:\n    if not root:\n        return 0\n    \n    left_depth = maxDepth(root.left)\n    right_depth = maxDepth(root.right)\n    \n    return 1 + max(left_depth, right_depth)"
      },
      {
        "id": "03-validate-binary-search-tree",
        "slug": "validate-binary-search-tree",
        "title": "Validate Binary Search Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "validate-binary-search-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.",
        "examples": [
          {
            "input": "root = [2,1,3]",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "root = [5,1,4,null,null,3,6]",
            "output": "false",
            "explanation": "3 is in right subtree of 5 but 3 < 5."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Checking only node.left.val < node.val fails because:",
            "options": [
              {
                "id": "a",
                "text": "It doesn't check right children"
              },
              {
                "id": "b",
                "text": "It doesn't enforce ancestor constraints"
              },
              {
                "id": "c",
                "text": "It's too slow"
              },
              {
                "id": "d",
                "text": "Values can be negative"
              }
            ],
            "correct": "b",
            "explanation": "A node in the right subtree must be greater than ALL ancestors up the left path, not just its parent.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "For a node in a BST, its value must be:",
            "options": [
              {
                "id": "a",
                "text": "Any value"
              },
              {
                "id": "b",
                "text": "Within a range defined by ancestor path"
              },
              {
                "id": "c",
                "text": "Greater than parent only"
              },
              {
                "id": "d",
                "text": "Less than parent only"
              }
            ],
            "correct": "b",
            "explanation": "Going left from ancestor X means value < X. Going right from Y means value > Y. All constraints apply.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "For the root node, the valid range is:",
            "options": [
              {
                "id": "a",
                "text": "[0, 100]"
              },
              {
                "id": "b",
                "text": "[min_int, max_int] or (-infinity, +infinity)"
              },
              {
                "id": "c",
                "text": "[root.val, root.val]"
              },
              {
                "id": "d",
                "text": "No range"
              }
            ],
            "correct": "b",
            "explanation": "No ancestors means no constraints yet. Any value is valid for root.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "When moving to left child, the range update is:",
            "options": [
              {
                "id": "a",
                "text": "Set new upper bound to parent's value"
              },
              {
                "id": "b",
                "text": "Set new lower bound to parent's value"
              },
              {
                "id": "c",
                "text": "No change"
              },
              {
                "id": "d",
                "text": "Reset to initial range"
              }
            ],
            "correct": "a",
            "explanation": "Left child must be < parent. So parent's value becomes the upper limit.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "When moving to right child, the range update is:",
            "options": [
              {
                "id": "a",
                "text": "Set new upper bound to parent's value"
              },
              {
                "id": "b",
                "text": "Set new lower bound to parent's value"
              },
              {
                "id": "c",
                "text": "No change"
              },
              {
                "id": "d",
                "text": "Reset to initial range"
              }
            ],
            "correct": "b",
            "explanation": "Right child must be > parent. So parent's value becomes the lower limit.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "BST in-order traversal produces:",
            "options": [
              {
                "id": "a",
                "text": "Random order"
              },
              {
                "id": "b",
                "text": "Descending order"
              },
              {
                "id": "c",
                "text": "Ascending order"
              },
              {
                "id": "d",
                "text": "Level order"
              }
            ],
            "correct": "c",
            "explanation": "In-order visits left, root, right. In BST, this gives sorted order. If not strictly increasing, not a valid BST.",
            "conceptId": "binary-search-tree"
          }
        ],
        "oneLiner": "Pass valid range (min, max) down. Each node must be within range. Left child: upper bound = parent. Right child: lower bound = parent.",
        "pattern": "Tree Traversal",
        "keyInsight": "Each node must be within a valid range defined by its ancestors.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "triggerWords": [
          "validate binary search tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isValidBST(root: TreeNode) -> bool:\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))"
      },
      {
        "id": "04-lowest-common-ancestor",
        "slug": "lowest-common-ancestor",
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "lowest-common-ancestor-of-a-binary-search-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nThe lowest common ancestor is defined as the lowest node in the tree that has both p and q as descendants (where we allow a node to be a descendant of itself).",
        "examples": [
          {
            "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
            "output": "6",
            "explanation": "LCA of 2 and 8 is 6."
          },
          {
            "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
            "output": "2",
            "explanation": "LCA of 2 and 4 is 2 (a node can be its own ancestor)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If p.val < root.val AND q.val < root.val:",
            "options": [
              {
                "id": "a",
                "text": "Root is the LCA"
              },
              {
                "id": "b",
                "text": "LCA is in left subtree"
              },
              {
                "id": "c",
                "text": "LCA is in right subtree"
              },
              {
                "id": "d",
                "text": "No LCA exists"
              }
            ],
            "correct": "b",
            "explanation": "Both nodes are smaller than root, so both are in the left subtree. LCA must be there.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "If p.val > root.val AND q.val > root.val:",
            "options": [
              {
                "id": "a",
                "text": "Root is the LCA"
              },
              {
                "id": "b",
                "text": "LCA is in left subtree"
              },
              {
                "id": "c",
                "text": "LCA is in right subtree"
              },
              {
                "id": "d",
                "text": "No LCA exists"
              }
            ],
            "correct": "c",
            "explanation": "Both nodes are larger than root, so both are in the right subtree. LCA must be there.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "If p.val < root.val AND q.val > root.val (or vice versa):",
            "options": [
              {
                "id": "a",
                "text": "Keep searching"
              },
              {
                "id": "b",
                "text": "Root is the LCA"
              },
              {
                "id": "c",
                "text": "LCA doesn't exist"
              },
              {
                "id": "d",
                "text": "Return null"
              }
            ],
            "correct": "b",
            "explanation": "One in left subtree, one in right. Root is the deepest node containing both.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "If p.val == root.val or q.val == root.val:",
            "options": [
              {
                "id": "a",
                "text": "Keep searching"
              },
              {
                "id": "b",
                "text": "Root is the LCA"
              },
              {
                "id": "c",
                "text": "Return the other node"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "b",
            "explanation": "If one node IS the root, root is an ancestor of both (itself and the other). This is the LCA.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "In a general binary tree, we can't use this approach because:",
            "options": [
              {
                "id": "a",
                "text": "Values might repeat"
              },
              {
                "id": "b",
                "text": "We can't determine which subtree contains a value"
              },
              {
                "id": "c",
                "text": "Trees are too deep"
              },
              {
                "id": "d",
                "text": "General trees don't have LCA"
              }
            ],
            "correct": "b",
            "explanation": "BST ordering tells us exactly where each value is. General trees require checking both subtrees.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "The time complexity is:",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(h) where h is height"
              },
              {
                "id": "c",
                "text": "O(log n) always"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "b",
            "explanation": "We traverse one path from root to LCA. In balanced BST, h = O(log n). In worst case (skewed), h = O(n).",
            "conceptId": "binary-search-tree"
          }
        ],
        "oneLiner": "BST LCA: if both smaller go left, if both larger go right, else current is LCA (split point or match).",
        "pattern": "Tree Traversal",
        "keyInsight": "Use BST property: if both p and q are smaller, go left. If both are larger, go right. Otherwise, current node is the LCA.",
        "timeComplexity": "O(h)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "lowest common ancestor of a binary search tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    curr = root\n    \n    while curr:\n        if p.val < curr.val and q.val < curr.val:\n            curr = curr.left\n        elif p.val > curr.val and q.val > curr.val:\n            curr = curr.right\n        else:\n            return curr\n    \n    return None"
      },
      {
        "id": "05-binary-tree-level-order-traversal",
        "slug": "binary-tree-level-order-traversal",
        "title": "Binary Tree Level Order Traversal",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "binary-tree-level-order-traversal"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
        "examples": [
          {
            "input": "root = [3,9,20,null,null,15,7]",
            "output": "[[3], [9, 20], [15, 7]]",
            "explanation": ""
          },
          {
            "input": "root = [1]",
            "output": "[[1]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "BFS is preferred for level-order because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "It naturally visits nodes level by level"
              },
              {
                "id": "c",
                "text": "DFS can't traverse trees"
              },
              {
                "id": "d",
                "text": "BFS uses less memory"
              }
            ],
            "correct": "b",
            "explanation": "Queue gives FIFO order. Nodes at level k are processed before level k+1.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "BFS uses:",
            "options": [
              {
                "id": "a",
                "text": "Stack"
              },
              {
                "id": "b",
                "text": "Queue"
              },
              {
                "id": "c",
                "text": "Heap"
              },
              {
                "id": "d",
                "text": "Array"
              }
            ],
            "correct": "b",
            "explanation": "Queue ensures FIFO - first in, first out. First discovered nodes processed first.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "To know when a level ends:",
            "options": [
              {
                "id": "a",
                "text": "Track depth of each node"
              },
              {
                "id": "b",
                "text": "Count nodes at each level before processing"
              },
              {
                "id": "c",
                "text": "Use a special marker"
              },
              {
                "id": "d",
                "text": "Guess based on values"
              }
            ],
            "correct": "b",
            "explanation": "Before processing level k, queue contains exactly all level-k nodes. Count them, process exactly that many.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Within a level, nodes are processed:",
            "options": [
              {
                "id": "a",
                "text": "Right to left"
              },
              {
                "id": "b",
                "text": "Left to right"
              },
              {
                "id": "c",
                "text": "Randomly"
              },
              {
                "id": "d",
                "text": "By value"
              }
            ],
            "correct": "b",
            "explanation": "We add left child before right child. Queue preserves this order.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "When processing a node, we add its children:",
            "options": [
              {
                "id": "a",
                "text": "Before processing the node"
              },
              {
                "id": "b",
                "text": "After processing the node"
              },
              {
                "id": "c",
                "text": "Only if they have values"
              },
              {
                "id": "d",
                "text": "Never"
              }
            ],
            "correct": "b",
            "explanation": "Add children to queue AFTER visiting node. They'll be processed in the next level.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "If a level has no nodes:",
            "options": [
              {
                "id": "a",
                "text": "We add an empty list"
              },
              {
                "id": "b",
                "text": "We skip it"
              },
              {
                "id": "c",
                "text": "This means we're done"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "c",
            "explanation": "If queue is empty at start of a level, there are no more nodes. Stop.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "BFS with level tracking: before processing, count queue size = level size. Process exactly that many nodes, adding children for next level.",
        "pattern": "Tree Traversal",
        "keyInsight": "Use BFS (Breadth-First Search). Process all nodes at current level before moving to the next.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(w)",
        "triggerWords": [
          "binary tree level order traversal",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import deque\n\ndef levelOrder(root: TreeNode) -> List[List[int]]:\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result"
      },
      {
        "id": "06-binary-tree-right-side-view",
        "slug": "binary-tree-right-side-view",
        "title": "Binary Tree Right Side View",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "binary-tree-right-side-view"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
        "examples": [
          {
            "input": "root = [1,2,3,null,5,null,4]",
            "output": "[1, 3, 4]",
            "explanation": ""
          },
          {
            "input": "root = [1,null,3]",
            "output": "[1, 3]",
            "explanation": ""
          },
          {
            "input": "root = []",
            "output": "[]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "From the right side, you see:",
            "options": [
              {
                "id": "a",
                "text": "The first node of each level"
              },
              {
                "id": "b",
                "text": "The last node of each level"
              },
              {
                "id": "c",
                "text": "The largest value at each level"
              },
              {
                "id": "d",
                "text": "All nodes of each level"
              }
            ],
            "correct": "b",
            "explanation": "Rightmost node blocks view of nodes to its left at the same level.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "To find the last node of each level:",
            "options": [
              {
                "id": "a",
                "text": "Pre-order (DFS)"
              },
              {
                "id": "b",
                "text": "In-order (DFS)"
              },
              {
                "id": "c",
                "text": "Level-order (BFS)"
              },
              {
                "id": "d",
                "text": "Post-order (DFS)"
              }
            ],
            "correct": "c",
            "explanation": "BFS processes levels left-to-right. Last node processed in each level is the answer.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "With DFS, we can also solve this by:",
            "options": [
              {
                "id": "a",
                "text": "Visiting right child before left"
              },
              {
                "id": "b",
                "text": "Visiting left child before right"
              },
              {
                "id": "c",
                "text": "Only visiting right children"
              },
              {
                "id": "d",
                "text": "Counting nodes"
              }
            ],
            "correct": "a",
            "explanation": "If we go right-first, the first node we see at each depth is the rightmost. Track first visit per depth.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Using BFS, we keep:",
            "options": [
              {
                "id": "a",
                "text": "All nodes"
              },
              {
                "id": "b",
                "text": "First node of each level"
              },
              {
                "id": "c",
                "text": "Last node of each level"
              },
              {
                "id": "d",
                "text": "Middle node"
              }
            ],
            "correct": "c",
            "explanation": "The last one we process before moving to next level is the rightmost.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "In right-first DFS, we add a node to result when:",
            "options": [
              {
                "id": "a",
                "text": "It's a leaf node"
              },
              {
                "id": "b",
                "text": "It's the first node we see at its depth"
              },
              {
                "id": "c",
                "text": "It has a right child"
              },
              {
                "id": "d",
                "text": "It has no left child"
              }
            ],
            "correct": "b",
            "explanation": "First node at each depth (with right-first traversal) is the rightmost. Track depths we've seen.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "The result should be ordered:",
            "options": [
              {
                "id": "a",
                "text": "By value"
              },
              {
                "id": "b",
                "text": "By depth (top to bottom)"
              },
              {
                "id": "c",
                "text": "By breadth"
              },
              {
                "id": "d",
                "text": "Randomly"
              }
            ],
            "correct": "b",
            "explanation": "\"From top to bottom\" = depth 0, 1, 2, ... which is natural BFS/DFS order.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "Right side view = last node at each level. BFS: keep last of each level. DFS: go right-first, add first node at each depth.",
        "pattern": "Tree Traversal",
        "keyInsight": "Level-order traversal, but only keep the last node of each level.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(w)",
        "triggerWords": [
          "binary tree right side view",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import deque\n\ndef rightSideView(root: TreeNode) -> List[int]:\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        \n        for i in range(level_size):\n            node = queue.popleft()\n            \n            # Last node in this level\n            if i == level_size - 1:\n                result.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    \n    return result"
      },
      {
        "id": "07-serialize-and-deserialize-binary-tree",
        "slug": "serialize-and-deserialize-binary-tree",
        "title": "Serialize and Deserialize Binary Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "serialize-and-deserialize-binary-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.",
        "examples": [
          {
            "input": "root = [1,2,3,null,null,4,5]",
            "output": "[1,2,3,null,null,4,5]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Storing just values [1, 2, 3, 4, 5] fails because:",
            "options": [
              {
                "id": "a",
                "text": "It's too short"
              },
              {
                "id": "b",
                "text": "It doesn't capture tree structure"
              },
              {
                "id": "c",
                "text": "Values can be negative"
              },
              {
                "id": "d",
                "text": "We can't store numbers as strings"
              }
            ],
            "correct": "b",
            "explanation": "Same values can form different trees. We need structure info.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Including \"null\" for missing children helps because:",
            "options": [
              {
                "id": "a",
                "text": "It makes the string longer"
              },
              {
                "id": "b",
                "text": "It marks where branches end"
              },
              {
                "id": "c",
                "text": "It's required by the problem"
              },
              {
                "id": "d",
                "text": "It balances the tree"
              }
            ],
            "correct": "b",
            "explanation": "Without nulls, we can't tell where a subtree ends. Nulls are the \"stop\" signals.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Which traversals can uniquely serialize a tree with null markers?",
            "options": [
              {
                "id": "a",
                "text": "Only pre-order"
              },
              {
                "id": "b",
                "text": "Only level-order"
              },
              {
                "id": "c",
                "text": "Pre-order or level-order (both work)"
              },
              {
                "id": "d",
                "text": "In-order"
              }
            ],
            "correct": "c",
            "explanation": "Both work with null markers. In-order doesn't work because multiple trees can have the same in-order with nulls.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "For tree [1, [2], [3, [4], [5]]], pre-order with nulls is:",
            "options": [
              {
                "id": "a",
                "text": "1, 2, 3, 4, 5"
              },
              {
                "id": "b",
                "text": "1, 2, null, null, 3, 4, null, null, 5, null, null"
              },
              {
                "id": "c",
                "text": "null, 2, null, null, 1, 3, 4, null"
              },
              {
                "id": "d",
                "text": "1, 2, 3, null, null, null, null"
              }
            ],
            "correct": "b",
            "explanation": "Visit 1, go left (2, null, null), go right (3, left (4, null, null), right (5, null, null)).",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "When deserializing pre-order, we:",
            "options": [
              {
                "id": "a",
                "text": "Use a stack"
              },
              {
                "id": "b",
                "text": "Process values in order, recursively building left then right"
              },
              {
                "id": "c",
                "text": "Build from leaves up"
              },
              {
                "id": "d",
                "text": "Need the tree first"
              }
            ],
            "correct": "b",
            "explanation": "First value is root. Then recursively build left subtree, then right subtree. Nulls signal \"no child here.\"",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "When we encounter \"null\" during deserialization:",
            "options": [
              {
                "id": "a",
                "text": "Return None and move to next value"
              },
              {
                "id": "b",
                "text": "Create a node with value 0"
              },
              {
                "id": "c",
                "text": "Stop completely"
              },
              {
                "id": "d",
                "text": "Go to parent"
              }
            ],
            "correct": "a",
            "explanation": "Null means no node here. Return None, but continue processing remaining values.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "Pre-order with null markers: serialize by visiting root, left, right with 'null' for None. Deserialize by consuming values in same order, recursively building left then right.",
        "pattern": "Tree Traversal",
        "keyInsight": "Pre-order traversal with null markers creates a unique, reconstructable representation.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "serialize and deserialize binary tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class Codec:\n    def serialize(self, root: TreeNode) -> str:\n        result = []\n        \n        def preorder(node):\n            if not node:\n                result.append('N')\n                return\n            result.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n        \n        preorder(root)\n        return ','.join(result)\n    \n    def deserialize(self, data: str) -> TreeNode:\n        values = iter(data.split(','))\n        \n        def build():\n            val = next(values)\n            if val == 'N':\n                return None\n            node = TreeNode(int(val))\n            node.left = build()\n            node.right = build()\n            return node\n        \n        return build()"
      },
      {
        "id": "08-binary-tree-maximum-path-sum",
        "slug": "binary-tree-maximum-path-sum",
        "title": "Binary Tree Maximum Path Sum",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "binary-tree-maximum-path-sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe path sum of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return the maximum path sum of any non-empty path.",
        "examples": [
          {
            "input": "root = [1,2,3]",
            "output": "6",
            "explanation": "Path 2 -> 1 -> 3 has sum 6."
          },
          {
            "input": "root = [-10,9,20,null,null,15,7]",
            "output": "42",
            "explanation": "Path 15 -> 20 -> 7 has sum 42."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A valid path in this problem:",
            "options": [
              {
                "id": "a",
                "text": "Must start at root"
              },
              {
                "id": "b",
                "text": "Must end at a leaf"
              },
              {
                "id": "c",
                "text": "Can start and end anywhere"
              },
              {
                "id": "d",
                "text": "Must include all nodes"
              }
            ],
            "correct": "c",
            "explanation": "A path is any connected sequence. It can be entirely in a subtree.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "A path can \"turn\" at node X, meaning:",
            "options": [
              {
                "id": "a",
                "text": "It includes both left and right children of X"
              },
              {
                "id": "b",
                "text": "It skips X"
              },
              {
                "id": "c",
                "text": "It visits X twice"
              },
              {
                "id": "d",
                "text": "It goes back to parent"
              }
            ],
            "correct": "a",
            "explanation": "Path goes through left subtree, through X, and through right subtree.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "When returning a value to parent, we can include:",
            "options": [
              {
                "id": "a",
                "text": "Both children's paths"
              },
              {
                "id": "b",
                "text": "At most one child's path"
              },
              {
                "id": "c",
                "text": "No children"
              },
              {
                "id": "d",
                "text": "All descendants"
              }
            ],
            "correct": "b",
            "explanation": "A path can't branch. If we go to parent, we came from one direction only.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "At each node, we compute two things:",
            "options": [
              {
                "id": "a",
                "text": "Left sum and right sum"
              },
              {
                "id": "b",
                "text": "Turn-sum (global update) and straight-sum (return)"
              },
              {
                "id": "c",
                "text": "Min and max"
              },
              {
                "id": "d",
                "text": "Sum and count"
              }
            ],
            "correct": "b",
            "explanation": "Turn-sum includes both children (potential answer). Straight-sum is what we can extend upward.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "If a child's contribution is negative:",
            "options": [
              {
                "id": "a",
                "text": "Include it anyway"
              },
              {
                "id": "b",
                "text": "Treat it as 0 (don't include it)"
              },
              {
                "id": "c",
                "text": "Use its absolute value"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "b",
            "explanation": "A negative contribution makes the path worse. Better to not include that subtree.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "For a null node, the contribution is:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "Negative infinity"
              },
              {
                "id": "c",
                "text": "The parent's value"
              },
              {
                "id": "d",
                "text": "1"
              }
            ],
            "correct": "a",
            "explanation": "No node = no contribution. Neutral value is 0.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "At each node: turn-sum = node + left + right (update global max). Return node + max(left, right) (one direction to parent). Ignore negative contributions.",
        "pattern": "Tree Traversal",
        "keyInsight": "At each node, compute two things: (1) path sum including both children (potential answer), (2) max single-branch sum to return to parent.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "triggerWords": [
          "binary tree maximum path sum",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxPathSum(root: TreeNode) -> int:\n    max_sum = float('-inf')\n    \n    def dfs(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        \n        # Get max gain from children (ignore negative)\n        left_gain = max(dfs(node.left), 0)\n        right_gain = max(dfs(node.right), 0)\n        \n        # Path sum if we \"turn\" at this node\n        path_sum = node.val + left_gain + right_gain\n        max_sum = max(max_sum, path_sum)\n        \n        # Return max gain we can extend to parent\n        return node.val + max(left_gain, right_gain)\n    \n    dfs(root)\n    return max_sum"
      }
    ],
    "tries": [
      {
        "id": "01-implement-trie",
        "slug": "implement-trie",
        "title": "Implement Trie (Prefix Tree)",
        "category": "tries",
        "difficulty": "medium",
        "tags": [
          "tries",
          "implement-trie-prefix-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n- `Trie()` Initializes the trie object.\n- `void insert(String word)` Inserts the string `word` into the trie.\n- `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.\n- `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.",
        "examples": [
          {
            "input": "[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]",
            "output": "[null, null, true, false, true, null, true]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Each trie node can have up to:",
            "options": [
              {
                "id": "a",
                "text": "2 children (binary)"
              },
              {
                "id": "b",
                "text": "26 children (for lowercase letters)"
              },
              {
                "id": "c",
                "text": "1 child"
              },
              {
                "id": "d",
                "text": "Unlimited children"
              }
            ],
            "correct": "b",
            "explanation": "For lowercase English, each node can branch to any of 26 characters.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "A trie node represents:",
            "options": [
              {
                "id": "a",
                "text": "A complete word"
              },
              {
                "id": "b",
                "text": "A single character in a prefix"
              },
              {
                "id": "c",
                "text": "The frequency of a word"
              },
              {
                "id": "d",
                "text": "A sorting criterion"
              }
            ],
            "correct": "b",
            "explanation": "Path from root to node = prefix. Each node = one more character added.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "Why do we need an \"is_end\" or \"is_word\" flag?",
            "options": [
              {
                "id": "a",
                "text": "To count words"
              },
              {
                "id": "b",
                "text": "To distinguish complete words from prefixes"
              },
              {
                "id": "c",
                "text": "To save space"
              },
              {
                "id": "d",
                "text": "To sort the trie"
              }
            ],
            "correct": "b",
            "explanation": "\"app\" might be a prefix of \"apple\". We need to know if \"app\" itself was inserted as a complete word.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "To insert \"cat\", we:",
            "options": [
              {
                "id": "a",
                "text": "Create one node with value \"cat\""
              },
              {
                "id": "b",
                "text": "Create nodes for 'c', 'a', 't' along a path, mark 't' as end"
              },
              {
                "id": "c",
                "text": "Hash the word"
              },
              {
                "id": "d",
                "text": "Sort the characters"
              }
            ],
            "correct": "b",
            "explanation": "Walk/create path c->a->t, mark the final node as a word end.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "The difference between search and startsWith:",
            "options": [
              {
                "id": "a",
                "text": "No difference"
              },
              {
                "id": "b",
                "text": "search checks is_end, startsWith doesn't"
              },
              {
                "id": "c",
                "text": "startsWith is faster"
              },
              {
                "id": "d",
                "text": "search uses BFS"
              }
            ],
            "correct": "b",
            "explanation": "search needs exact match (complete word). startsWith just needs the path to exist.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "Insert and search are:",
            "options": [
              {
                "id": "a",
                "text": "O(1)"
              },
              {
                "id": "b",
                "text": "O(log n)"
              },
              {
                "id": "c",
                "text": "O(m) where m is word length"
              },
              {
                "id": "d",
                "text": "O(n) where n is number of words"
              }
            ],
            "correct": "c",
            "explanation": "We traverse one node per character. Independent of total words stored.",
            "conceptId": "trie"
          }
        ],
        "oneLiner": "Trie: tree where each path = prefix. Insert creates path and marks end. Search verifies path AND end marker. StartsWith just verifies path exists.",
        "pattern": "Trie",
        "keyInsight": "Each node represents a character. A path from root spells a prefix. Mark nodes where words end.",
        "timeComplexity": "O(m) per operation",
        "spaceComplexity": "O(total chars)",
        "triggerWords": [
          "implement trie (prefix tree)",
          "tries"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n    \n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True"
      },
      {
        "id": "02-design-add-and-search-words",
        "slug": "design-add-and-search-words",
        "title": "Design Add and Search Words Data Structure",
        "category": "tries",
        "difficulty": "medium",
        "tags": [
          "tries",
          "design-add-and-search-words-data-structure"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the `WordDictionary` class:\n- `WordDictionary()` Initializes the object.\n- `void addWord(word)` Adds `word` to the data structure, it can be matched later.\n- `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `.` where dots can be matched with any letter.",
        "examples": [
          {
            "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]",
            "output": "[null,null,null,null,false,true,true,true]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Adding a word with dots like \"a.c\":",
            "options": [
              {
                "id": "a",
                "text": "Is allowed"
              },
              {
                "id": "b",
                "text": "Is not supported in this problem"
              },
              {
                "id": "c",
                "text": "Creates special nodes"
              },
              {
                "id": "d",
                "text": "Uses regex"
              }
            ],
            "correct": "b",
            "explanation": "Only search has wildcards. Words added are normal strings.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "Searching \"bad\" (no dots):",
            "options": [
              {
                "id": "a",
                "text": "Uses standard trie search"
              },
              {
                "id": "b",
                "text": "Tries all paths"
              },
              {
                "id": "c",
                "text": "Is not allowed"
              },
              {
                "id": "d",
                "text": "Uses hashing"
              }
            ],
            "correct": "a",
            "explanation": "No wildcards = normal trie traversal.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "The dot `.` matches:",
            "options": [
              {
                "id": "a",
                "text": "Only vowels"
              },
              {
                "id": "b",
                "text": "Only the letter 'd'"
              },
              {
                "id": "c",
                "text": "Any single character"
              },
              {
                "id": "d",
                "text": "Zero or more characters"
              }
            ],
            "correct": "c",
            "explanation": "Like regex `.`, it matches exactly one character, any character.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "To search \".ad\" in a trie:",
            "options": [
              {
                "id": "a",
                "text": "Look for node named \".\""
              },
              {
                "id": "b",
                "text": "Try all children of root, continue with \"ad\""
              },
              {
                "id": "c",
                "text": "Skip to \"ad\""
              },
              {
                "id": "d",
                "text": "Return false"
              }
            ],
            "correct": "b",
            "explanation": "First character is `.`, so we try 'a', 'b', 'c', ... all 26 possibilities for first character.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "When we hit a `.`:",
            "options": [
              {
                "id": "a",
                "text": "Stop searching"
              },
              {
                "id": "b",
                "text": "Recurse on ALL children with remaining pattern"
              },
              {
                "id": "c",
                "text": "Pick a random child"
              },
              {
                "id": "d",
                "text": "Backtrack"
              }
            ],
            "correct": "b",
            "explanation": "Each child is a valid match for `.`. If any path succeeds, return true.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "Searching \"...\" (all dots) in worst case:",
            "options": [
              {
                "id": "a",
                "text": "O(m) where m is pattern length"
              },
              {
                "id": "b",
                "text": "O(26^m) - exponential"
              },
              {
                "id": "c",
                "text": "O(n) where n is total words"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "b",
            "explanation": "Each dot branches to 26 children. m dots = 26^m paths to explore.",
            "conceptId": "trie"
          }
        ],
        "oneLiner": "Standard trie, but search uses DFS. At `.`, recurse on ALL children. At regular char, follow that path only. Return true if any path reaches is_end.",
        "pattern": "Trie",
        "keyInsight": "Standard trie insert. For search, when we hit `.`, try ALL children recursively.",
        "timeComplexity": "O(m) add, O(26^m) search worst",
        "spaceComplexity": "O(total chars)",
        "triggerWords": [
          "design add and search words data structure",
          "tries"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def addWord(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        def dfs(index, node):\n            if index == len(word):\n                return node.is_end\n            \n            char = word[index]\n            if char == '.':\n                # Try all children\n                for child in node.children.values():\n                    if dfs(index + 1, child):\n                        return True\n                return False\n            else:\n                if char not in node.children:\n                    return False\n                return dfs(index + 1, node.children[char])\n        \n        return dfs(0, self.root)"
      },
      {
        "id": "03-word-search-ii",
        "slug": "word-search-ii",
        "title": "Word Search II",
        "category": "tries",
        "difficulty": "medium",
        "tags": [
          "tries",
          "word-search-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` board of characters and a list of strings `words`, return all words on the board.\n\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
        "examples": [
          {
            "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
            "output": "[\"eat\",\"oath\"]",
            "explanation": ""
          },
          {
            "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
            "output": "[]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Using a trie for the word list helps because:",
            "options": [
              {
                "id": "a",
                "text": "It stores words alphabetically"
              },
              {
                "id": "b",
                "text": "We can check if current path is a valid prefix in O(1)"
              },
              {
                "id": "c",
                "text": "It compresses the board"
              },
              {
                "id": "d",
                "text": "It makes DFS faster"
              }
            ],
            "correct": "b",
            "explanation": "Trie lets us know instantly if a path could lead to any word, enabling early pruning.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "We should stop exploring a grid path when:",
            "options": [
              {
                "id": "a",
                "text": "We've visited 4 cells"
              },
              {
                "id": "b",
                "text": "Current path is not a prefix of any word"
              },
              {
                "id": "c",
                "text": "We find a word"
              },
              {
                "id": "d",
                "text": "The cell is 'z'"
              }
            ],
            "correct": "b",
            "explanation": "If no word starts with this prefix, don't waste time continuing.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "When DFS reaches a complete word in trie:",
            "options": [
              {
                "id": "a",
                "text": "Stop immediately"
              },
              {
                "id": "b",
                "text": "Add to results and continue exploring"
              },
              {
                "id": "c",
                "text": "Restart from the beginning"
              },
              {
                "id": "d",
                "text": "Remove the cell from board"
              }
            ],
            "correct": "b",
            "explanation": "\"oath\" might be found, but \"oaths\" could also exist. Continue exploring after finding a word.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "To ensure the same cell isn't used twice in a word:",
            "options": [
              {
                "id": "a",
                "text": "Remove it from board permanently"
              },
              {
                "id": "b",
                "text": "Mark it during DFS, unmark on backtrack"
              },
              {
                "id": "c",
                "text": "Keep a global visited set"
              },
              {
                "id": "d",
                "text": "Check coordinates"
              }
            ],
            "correct": "b",
            "explanation": "Temporarily mark during exploration, restore when backtracking. Standard DFS pattern.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "After finding a word, we can:",
            "options": [
              {
                "id": "a",
                "text": "Keep it in trie"
              },
              {
                "id": "b",
                "text": "Remove it from trie to avoid duplicates"
              },
              {
                "id": "c",
                "text": "Add it again"
              },
              {
                "id": "d",
                "text": "Clear the whole trie"
              }
            ],
            "correct": "b",
            "explanation": "Prevents finding the same word again. Also allows pruning empty trie branches.",
            "conceptId": "trie"
          }
        ],
        "oneLiner": "Build trie from words. DFS on grid while walking trie simultaneously. Prune when path isn't a trie prefix. Store found words, remove from trie to avoid duplicates.",
        "pattern": "Trie",
        "keyInsight": "Build a trie from words. DFS on the grid, but use trie to prune impossible paths early.",
        "timeComplexity": "O(m * n * 4^L)",
        "spaceComplexity": "O(total chars in words)",
        "triggerWords": [
          "word search ii",
          "tries"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\ndef findWords(board: List[List[str]], words: List[str]) -> List[str]:\n    # Build trie\n    root = TrieNode()\n    for word in words:\n        node = root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.word = word\n    \n    result = []\n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c, node):\n        char = board[r][c]\n        if char not in node.children:\n            return\n        \n        next_node = node.children[char]\n        \n        # Found a word\n        if next_node.word:\n            result.append(next_node.word)\n            next_node.word = None  # Avoid duplicates\n        \n        # Mark visited\n        board[r][c] = '#'\n        \n        # Explore neighbors\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] != '#':\n                dfs(nr, nc, next_node)\n        \n        # Restore\n        board[r][c] = char\n    \n    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, root)\n    \n    return result"
      }
    ],
    "backtracking": [
      {
        "id": "01-subsets",
        "slug": "subsets",
        "title": "Subsets",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "subsets"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums` of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
            "explanation": ""
          },
          {
            "input": "nums = [0]",
            "output": "[[],[0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For n elements, the total number of subsets is:",
            "options": [
              {
                "id": "a",
                "text": "n"
              },
              {
                "id": "b",
                "text": "n!"
              },
              {
                "id": "c",
                "text": "2^n"
              },
              {
                "id": "d",
                "text": "n^2"
              }
            ],
            "correct": "c",
            "explanation": "Each element is either in or out. 2 choices x n elements = 2^n subsets.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "The empty set [] is:",
            "options": [
              {
                "id": "a",
                "text": "Not a valid subset"
              },
              {
                "id": "b",
                "text": "Always a valid subset"
              },
              {
                "id": "c",
                "text": "Only valid for empty input"
              },
              {
                "id": "d",
                "text": "The only subset"
              }
            ],
            "correct": "b",
            "explanation": "Every set has an empty subset (choosing to include nothing).",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At element nums[i], we:",
            "options": [
              {
                "id": "a",
                "text": "Must include it"
              },
              {
                "id": "b",
                "text": "Must exclude it"
              },
              {
                "id": "c",
                "text": "Either include or exclude it"
              },
              {
                "id": "d",
                "text": "Include it twice"
              }
            ],
            "correct": "c",
            "explanation": "Both choices lead to valid subsets. We explore both paths.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We add the current subset to results:",
            "options": [
              {
                "id": "a",
                "text": "Only when all elements are processed"
              },
              {
                "id": "b",
                "text": "Only when subset is non-empty"
              },
              {
                "id": "c",
                "text": "At every decision point"
              },
              {
                "id": "d",
                "text": "Never"
              }
            ],
            "correct": "c",
            "explanation": "Every state is a valid subset. We add current subset at each recursive call.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To avoid duplicate subsets like [1,2] and [2,1]:",
            "options": [
              {
                "id": "a",
                "text": "Sort the result"
              },
              {
                "id": "b",
                "text": "Always process in increasing index order"
              },
              {
                "id": "c",
                "text": "Use a hash set"
              },
              {
                "id": "d",
                "text": "Check before adding"
              }
            ],
            "correct": "b",
            "explanation": "By only considering elements at index >= current, we avoid revisiting earlier elements.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "For each element: include or skip. Process in order (start index) to avoid duplicates. Backtrack after each choice.",
        "pattern": "Backtracking",
        "keyInsight": "For each element, make a binary choice: include it or not.",
        "timeComplexity": "O(n * 2^n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "subsets",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def subsets(nums: List[int]) -> List[List[int]]:\n    result = []\n    \n    def backtrack(start, current):\n        result.append(current[:])\n        \n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    backtrack(0, [])\n    return result"
      },
      {
        "id": "02-combination-sum",
        "slug": "combination-sum",
        "title": "Combination Sum",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "combination-sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order.\n\nThe same number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.",
        "examples": [
          {
            "input": "candidates = [2,3,6,7], target = 7",
            "output": "[[2,2,3],[7]]",
            "explanation": "2+2+3 = 7, 7 = 7"
          },
          {
            "input": "candidates = [2,3,5], target = 8",
            "output": "[[2,2,2,2],[2,3,3],[3,5]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "After choosing candidates[i], the next choice can:",
            "options": [
              {
                "id": "a",
                "text": "Only be candidates[i+1] or later"
              },
              {
                "id": "b",
                "text": "Be candidates[i] again"
              },
              {
                "id": "c",
                "text": "Only be candidates[i-1]"
              },
              {
                "id": "d",
                "text": "Only be from remaining candidates"
              }
            ],
            "correct": "b",
            "explanation": "\"Unlimited times\" means we can pick the same element again.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To avoid duplicate combinations like [2,3] and [3,2]:",
            "options": [
              {
                "id": "a",
                "text": "Sort before returning"
              },
              {
                "id": "b",
                "text": "Only pick elements at index >= current"
              },
              {
                "id": "c",
                "text": "Use a hash set"
              },
              {
                "id": "d",
                "text": "Skip odd indices"
              }
            ],
            "correct": "b",
            "explanation": "By never going backward, we get only one ordering.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We stop exploring when:",
            "options": [
              {
                "id": "a",
                "text": "Current sum > target"
              },
              {
                "id": "b",
                "text": "Current sum == target"
              },
              {
                "id": "c",
                "text": "We've seen all candidates"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "Stop if exceeded (invalid), found solution, or no more candidates.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We add current combination to result when:",
            "options": [
              {
                "id": "a",
                "text": "Current sum equals target"
              },
              {
                "id": "b",
                "text": "Current sum exceeds target"
              },
              {
                "id": "c",
                "text": "We've used all candidates"
              },
              {
                "id": "d",
                "text": "Combination has exactly target elements"
              }
            ],
            "correct": "a",
            "explanation": "We want exact sum. Add only when target reached.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "If candidates are sorted and current candidate > remaining:",
            "options": [
              {
                "id": "a",
                "text": "Continue anyway"
              },
              {
                "id": "b",
                "text": "Skip this and all larger candidates"
              },
              {
                "id": "c",
                "text": "Double the candidate"
              },
              {
                "id": "d",
                "text": "Reset"
              }
            ],
            "correct": "b",
            "explanation": "If this candidate alone exceeds remaining, so will all larger ones (if sorted).",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "After finding a valid combination:",
            "options": [
              {
                "id": "a",
                "text": "Stop searching"
              },
              {
                "id": "b",
                "text": "Continue exploring other possibilities"
              },
              {
                "id": "c",
                "text": "Clear the result"
              },
              {
                "id": "d",
                "text": "Start over"
              }
            ],
            "correct": "b",
            "explanation": "We want ALL combinations, not just one.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Like subsets, but pass same index (reuse allowed). Stop when sum = target (add result) or > target (prune). Move forward only to avoid duplicates.",
        "pattern": "Backtracking",
        "keyInsight": "Like subsets, but allow reusing elements and track sum against target.",
        "timeComplexity": "O(n^(target/min))",
        "spaceComplexity": "O(target/min)",
        "triggerWords": [
          "combination sum",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    result = []\n    \n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        if remaining < 0:\n            return\n        \n        for i in range(start, len(candidates)):\n            current.append(candidates[i])\n            backtrack(i, current, remaining - candidates[i])\n            current.pop()\n    \n    backtrack(0, [], target)\n    return result"
      },
      {
        "id": "03-permutations",
        "slug": "permutations",
        "title": "Permutations",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "permutations"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
            "explanation": ""
          },
          {
            "input": "nums = [0,1]",
            "output": "[[0,1],[1,0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For n distinct elements, total permutations:",
            "options": [
              {
                "id": "a",
                "text": "2^n"
              },
              {
                "id": "b",
                "text": "n!"
              },
              {
                "id": "c",
                "text": "n^n"
              },
              {
                "id": "d",
                "text": "n^2"
              }
            ],
            "correct": "b",
            "explanation": "n choices for first, n-1 for second, ... = n!",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "In a permutation, each element:",
            "options": [
              {
                "id": "a",
                "text": "Can appear multiple times"
              },
              {
                "id": "b",
                "text": "Must appear exactly once"
              },
              {
                "id": "c",
                "text": "Can be skipped"
              },
              {
                "id": "d",
                "text": "Appears in fixed position"
              }
            ],
            "correct": "b",
            "explanation": "Permutation = rearrangement of ALL elements.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To ensure each element appears once, we:",
            "options": [
              {
                "id": "a",
                "text": "Remove elements from array"
              },
              {
                "id": "b",
                "text": "Track used indices/elements"
              },
              {
                "id": "c",
                "text": "Sort the array"
              },
              {
                "id": "d",
                "text": "Use fixed order"
              }
            ],
            "correct": "b",
            "explanation": "Know what's available vs. already placed.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We add current permutation when:",
            "options": [
              {
                "id": "a",
                "text": "It has length n"
              },
              {
                "id": "b",
                "text": "It has length 1"
              },
              {
                "id": "c",
                "text": "Any length is valid"
              },
              {
                "id": "d",
                "text": "All elements are used (same as A)"
              }
            ],
            "correct": "a",
            "explanation": "Permutation must include all n elements.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At each recursion level, we consider:",
            "options": [
              {
                "id": "a",
                "text": "Only elements after current index"
              },
              {
                "id": "b",
                "text": "All unused elements"
              },
              {
                "id": "c",
                "text": "Only adjacent elements"
              },
              {
                "id": "d",
                "text": "Random elements"
              }
            ],
            "correct": "b",
            "explanation": "Unlike subsets/combinations, order matters. Any unused element can go in current position.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "At each position, try all unused elements. Add to result when length = n. Unlike subsets, consider ALL unused elements at each level.",
        "pattern": "Backtracking",
        "keyInsight": "At each position, choose from remaining unused elements. Track what's been used.",
        "timeComplexity": "O(n * n!)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "permutations",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def permute(nums: List[int]) -> List[List[int]]:\n    result = []\n    \n    def backtrack(current, used):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        \n        for i in range(len(nums)):\n            if i in used:\n                continue\n            current.append(nums[i])\n            used.add(i)\n            backtrack(current, used)\n            current.pop()\n            used.remove(i)\n    \n    backtrack([], set())\n    return result"
      },
      {
        "id": "04-subsets-ii",
        "slug": "subsets-ii",
        "title": "Subsets II",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "subsets-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums` that may contain duplicates, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
        "examples": [
          {
            "input": "nums = [1,2,2]",
            "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
            "explanation": ""
          },
          {
            "input": "nums = [0]",
            "output": "[[],[0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Sorting the array helps because:",
            "options": [
              {
                "id": "a",
                "text": "It makes the output look nice"
              },
              {
                "id": "b",
                "text": "Duplicates become adjacent, easy to detect"
              },
              {
                "id": "c",
                "text": "It's faster"
              },
              {
                "id": "d",
                "text": "Required by the algorithm"
              }
            ],
            "correct": "b",
            "explanation": "After sorting, all 2s are together. We can skip consecutive same values.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We skip nums[i] if:",
            "options": [
              {
                "id": "a",
                "text": "It's the first element"
              },
              {
                "id": "b",
                "text": "nums[i] == nums[i-1] and i > start"
              },
              {
                "id": "c",
                "text": "It's negative"
              },
              {
                "id": "d",
                "text": "We've seen it before anywhere"
              }
            ],
            "correct": "b",
            "explanation": "If the previous element at THIS LEVEL was the same, we've already explored that branch.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "\"Same level\" means:",
            "options": [
              {
                "id": "a",
                "text": "Same depth in recursion"
              },
              {
                "id": "b",
                "text": "Same iteration of the for loop at current recursion"
              },
              {
                "id": "c",
                "text": "Same value"
              },
              {
                "id": "d",
                "text": "Same index"
              }
            ],
            "correct": "b",
            "explanation": "Within one call to backtrack, we loop through choices. Same-level duplicates happen in THIS loop.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "The condition i > start (not i > 0) is important because:",
            "options": [
              {
                "id": "a",
                "text": "We want to allow first element"
              },
              {
                "id": "b",
                "text": "start marks where valid choices begin for this level"
              },
              {
                "id": "c",
                "text": "It prevents index errors"
              },
              {
                "id": "d",
                "text": "0 is special"
              }
            ],
            "correct": "b",
            "explanation": "At recursion level with start=2, checking i>0 would wrongly skip element at i=2 if it matches i=1.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At the first level (start=0), for [1,2,2]:",
            "options": [
              {
                "id": "a",
                "text": "We try 1, 2, 2 (all three)"
              },
              {
                "id": "b",
                "text": "We try 1, then only the first 2"
              },
              {
                "id": "c",
                "text": "We skip all 2s"
              },
              {
                "id": "d",
                "text": "We only try 2"
              }
            ],
            "correct": "b",
            "explanation": "First 2 at index 1 is tried. Second 2 at index 2 is skipped (same as previous at same level).",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "After choosing first 2 (at index 1), from [1,2,2]:",
            "options": [
              {
                "id": "a",
                "text": "We can still choose the second 2"
              },
              {
                "id": "b",
                "text": "We must skip the second 2"
              },
              {
                "id": "c",
                "text": "We restart from 1"
              },
              {
                "id": "d",
                "text": "We stop"
              }
            ],
            "correct": "a",
            "explanation": "We moved to a new level (start=2). At THIS level, index 2 is the first choice, so not skipped.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Sort first. In backtrack loop, skip if nums[i] == nums[i-1] AND i > start. This avoids exploring duplicate branches at the same decision level.",
        "pattern": "Backtracking",
        "keyInsight": "Sort the array. Skip duplicates at the same decision level.",
        "timeComplexity": "O(n * 2^n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "subsets ii",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def subsetsWithDup(nums: List[int]) -> List[List[int]]:\n    nums.sort()\n    result = []\n    \n    def backtrack(start, current):\n        result.append(current[:])\n        \n        for i in range(start, len(nums)):\n            # Skip duplicates at same level\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    backtrack(0, [])\n    return result"
      },
      {
        "id": "05-combination-sum-ii",
        "slug": "combination-sum-ii",
        "title": "Combination Sum II",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "combination-sum-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.\n\nEach number in `candidates` may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.",
        "examples": [
          {
            "input": "candidates = [10,1,2,7,6,1,5], target = 8",
            "output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
            "explanation": ""
          },
          {
            "input": "candidates = [2,5,2,1,2], target = 5",
            "output": "[[1,2,2],[5]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "After choosing candidates[i], the next recursive call starts at:",
            "options": [
              {
                "id": "a",
                "text": "i (can reuse)"
              },
              {
                "id": "b",
                "text": "i + 1 (move forward)"
              },
              {
                "id": "c",
                "text": "0 (start over)"
              },
              {
                "id": "d",
                "text": "i - 1"
              }
            ],
            "correct": "b",
            "explanation": "Unlike Combination Sum I, each element can only be used once.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "For candidates = [1,1,2], to avoid duplicate [1,2]:",
            "options": [
              {
                "id": "a",
                "text": "Remove duplicates from input"
              },
              {
                "id": "b",
                "text": "Sort and skip same value at same level"
              },
              {
                "id": "c",
                "text": "Use a set"
              },
              {
                "id": "d",
                "text": "Ignore"
              }
            ],
            "correct": "b",
            "explanation": "Same pattern as Subsets II. Sort, then skip if nums[i] == nums[i-1] at same level.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We stop exploring when:",
            "options": [
              {
                "id": "a",
                "text": "Sum exceeds target"
              },
              {
                "id": "b",
                "text": "Sum equals target (after adding to result)"
              },
              {
                "id": "c",
                "text": "No more candidates (index out of bounds)"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "All are valid stopping conditions.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We skip candidates[i] if:",
            "options": [
              {
                "id": "a",
                "text": "candidates[i] > remaining target"
              },
              {
                "id": "b",
                "text": "i > start and candidates[i] == candidates[i-1]"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "We've already found a solution"
              }
            ],
            "correct": "c",
            "explanation": "Skip if too large (pruning) or duplicate at same level (dedup).",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "Sorting helps with:",
            "options": [
              {
                "id": "a",
                "text": "Early termination (larger elements after smaller)"
              },
              {
                "id": "b",
                "text": "Duplicate detection (same values adjacent)"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Sorting enables both optimizations.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "The key differences from Combination Sum I are:",
            "options": [
              {
                "id": "a",
                "text": "Use i+1 instead of i"
              },
              {
                "id": "b",
                "text": "Add duplicate skipping logic"
              },
              {
                "id": "c",
                "text": "Both A and B"
              },
              {
                "id": "d",
                "text": "Use a different data structure"
              }
            ],
            "correct": "c",
            "explanation": "Two changes: no reuse (i+1), and deduplication.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Combination Sum + Subsets II: move to i+1 (no reuse), skip if same as previous at same level (dedup), break if exceeds target (prune).",
        "pattern": "Backtracking",
        "keyInsight": "Combine Combination Sum's target tracking with Subsets II's duplicate skipping.",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "combination sum ii",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def combinationSum2(candidates: List[int], target: int) -> List[List[int]]:\n    candidates.sort()\n    result = []\n    \n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if candidates[i] > remaining:\n                break\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            current.append(candidates[i])\n            backtrack(i + 1, current, remaining - candidates[i])\n            current.pop()\n    \n    backtrack(0, [], target)\n    return result"
      },
      {
        "id": "06-word-search",
        "slug": "word-search",
        "title": "Word Search",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "word-search"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
        "examples": [
          {
            "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We start DFS from:",
            "options": [
              {
                "id": "a",
                "text": "Only (0,0)"
              },
              {
                "id": "b",
                "text": "Any cell matching word[0]"
              },
              {
                "id": "c",
                "text": "All cells"
              },
              {
                "id": "d",
                "text": "Random cells"
              }
            ],
            "correct": "b",
            "explanation": "Word could start anywhere. But only cells matching first character are valid starts.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "From each cell, we can move to:",
            "options": [
              {
                "id": "a",
                "text": "Only right and down"
              },
              {
                "id": "b",
                "text": "Only diagonal cells"
              },
              {
                "id": "c",
                "text": "All 4 adjacent cells (up, down, left, right)"
              },
              {
                "id": "d",
                "text": "8 surrounding cells"
              }
            ],
            "correct": "c",
            "explanation": "\"Adjacent\" = horizontal or vertical neighbors.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To prevent using the same cell twice:",
            "options": [
              {
                "id": "a",
                "text": "Delete the cell"
              },
              {
                "id": "b",
                "text": "Mark it temporarily during DFS"
              },
              {
                "id": "c",
                "text": "Use a global visited set"
              },
              {
                "id": "d",
                "text": "Check coordinates only"
              }
            ],
            "correct": "b",
            "explanation": "Mark during exploration, unmark during backtrack. Each path has its own visited state.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At cell (r,c) with word index i, we proceed if:",
            "options": [
              {
                "id": "a",
                "text": "board[r][c] == word[i]"
              },
              {
                "id": "b",
                "text": "board[r][c] == word[0]"
              },
              {
                "id": "c",
                "text": "Cell is not visited"
              },
              {
                "id": "d",
                "text": "Both A and C"
              }
            ],
            "correct": "d",
            "explanation": "Cell must match current character AND not be already used in this path.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We return True when:",
            "options": [
              {
                "id": "a",
                "text": "We've visited all cells"
              },
              {
                "id": "b",
                "text": "We've matched all characters of word"
              },
              {
                "id": "c",
                "text": "We reach the bottom-right corner"
              },
              {
                "id": "d",
                "text": "We find any path"
              }
            ],
            "correct": "b",
            "explanation": "index == len(word) means we've matched every character.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "When a path fails (no valid continuation):",
            "options": [
              {
                "id": "a",
                "text": "Return False and let parent try another direction"
              },
              {
                "id": "b",
                "text": "Start over from beginning"
              },
              {
                "id": "c",
                "text": "Give up entirely"
              },
              {
                "id": "d",
                "text": "Skip to next cell"
              }
            ],
            "correct": "a",
            "explanation": "Backtrack to previous cell, try other directions. Classic DFS.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "DFS from each cell matching word[0]. At each step: check bounds, check match, mark visited, explore 4 directions, unmark (backtrack). Return True if all matched.",
        "pattern": "Backtracking",
        "keyInsight": "DFS from each cell that matches first letter. Mark visited cells to avoid reuse. Backtrack on failure.",
        "timeComplexity": "O(m * n * 4^L)",
        "spaceComplexity": "O(L)",
        "triggerWords": [
          "word search",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def exist(board: List[List[str]], word: str) -> bool:\n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c, index):\n        if index == len(word):\n            return True\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return False\n        if board[r][c] != word[index]:\n            return False\n        \n        # Mark visited\n        temp = board[r][c]\n        board[r][c] = '#'\n        \n        # Explore 4 directions\n        found = (dfs(r+1, c, index+1) or dfs(r-1, c, index+1) or\n                 dfs(r, c+1, index+1) or dfs(r, c-1, index+1))\n        \n        # Backtrack\n        board[r][c] = temp\n        return found\n    \n    for r in range(rows):\n        for c in range(cols):\n            if dfs(r, c, 0):\n                return True\n    return False"
      },
      {
        "id": "07-palindrome-partitioning",
        "slug": "palindrome-partitioning",
        "title": "Palindrome Partitioning",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "palindrome-partitioning"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of `s`.",
        "examples": [
          {
            "input": "s = \"aab\"",
            "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
            "explanation": ""
          },
          {
            "input": "s = \"a\"",
            "output": "[[\"a\"]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At position i, we choose:",
            "options": [
              {
                "id": "a",
                "text": "Whether to include character i"
              },
              {
                "id": "b",
                "text": "How far to extend the current palindrome"
              },
              {
                "id": "c",
                "text": "Which character to use"
              },
              {
                "id": "d",
                "text": "Whether to skip characters"
              }
            ],
            "correct": "b",
            "explanation": "We try all possible ending positions j where s[i:j] is a palindrome.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We add current partition to result when:",
            "options": [
              {
                "id": "a",
                "text": "We have n pieces"
              },
              {
                "id": "b",
                "text": "Current piece is a palindrome"
              },
              {
                "id": "c",
                "text": "We've processed the entire string"
              },
              {
                "id": "d",
                "text": "We found \"aa\""
              }
            ],
            "correct": "c",
            "explanation": "When start index reaches end of string, we've successfully partitioned everything.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We can extend from position i to j if:",
            "options": [
              {
                "id": "a",
                "text": "j > i"
              },
              {
                "id": "b",
                "text": "s[i:j+1] is a palindrome"
              },
              {
                "id": "c",
                "text": "s[i:j+1] has all same characters"
              },
              {
                "id": "d",
                "text": "j == len(s) - 1"
              }
            ],
            "correct": "b",
            "explanation": "Each piece must be a palindrome. We only proceed if the piece from i to j is valid.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "After choosing s[i:j] as a piece, we:",
            "options": [
              {
                "id": "a",
                "text": "Move to position j and continue"
              },
              {
                "id": "b",
                "text": "Start over from 0"
              },
              {
                "id": "c",
                "text": "Skip j characters"
              },
              {
                "id": "d",
                "text": "End the partition"
              }
            ],
            "correct": "a",
            "explanation": "We've used characters 0 to j-1. Now partition the rest starting at j.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To check if s[i:j] is a palindrome:",
            "options": [
              {
                "id": "a",
                "text": "Compare with reverse"
              },
              {
                "id": "b",
                "text": "Check if all characters are same"
              },
              {
                "id": "c",
                "text": "Check length"
              },
              {
                "id": "d",
                "text": "Use hash"
              }
            ],
            "correct": "a",
            "explanation": "A palindrome reads same forwards and backwards.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "For string \"aaa\", the number of valid partitions is:",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "3"
              },
              {
                "id": "c",
                "text": "4"
              },
              {
                "id": "d",
                "text": "8"
              }
            ],
            "correct": "c",
            "explanation": "[\"a\",\"a\",\"a\"], [\"a\",\"aa\"], [\"aa\",\"a\"], [\"aaa\"]. 4 ways.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "At each position, try all possible lengths. If s[i:j] is palindrome, take it and partition s[j:]. Add to result when string fully consumed.",
        "pattern": "Backtracking",
        "keyInsight": "At each position, try all possible palindrome prefixes. Then recursively partition the rest.",
        "timeComplexity": "O(n * 2^n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "palindrome partitioning",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def partition(s: str) -> List[List[str]]:\n    result = []\n    \n    def is_palindrome(sub):\n        return sub == sub[::-1]\n    \n    def backtrack(start, current):\n        if start == len(s):\n            result.append(current[:])\n            return\n        \n        for end in range(start + 1, len(s) + 1):\n            substring = s[start:end]\n            if is_palindrome(substring):\n                current.append(substring)\n                backtrack(end, current)\n                current.pop()\n    \n    backtrack(0, [])\n    return result"
      },
      {
        "id": "08-n-queens",
        "slug": "n-queens",
        "title": "N-Queens",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "n-queens"
        ],
        "estimatedTime": 5,
        "problemStatement": "The n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.",
        "examples": [
          {
            "input": "n = 4",
            "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
            "explanation": ""
          },
          {
            "input": "n = 1",
            "output": "[[\"Q\"]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A queen can attack another queen if they share:",
            "options": [
              {
                "id": "a",
                "text": "Same row"
              },
              {
                "id": "b",
                "text": "Same column"
              },
              {
                "id": "c",
                "text": "Same diagonal"
              },
              {
                "id": "d",
                "text": "Any of the above"
              }
            ],
            "correct": "d",
            "explanation": "Queens attack horizontally, vertically, and diagonally.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "Since each queen attacks its entire row, each row can have:",
            "options": [
              {
                "id": "a",
                "text": "0 queens"
              },
              {
                "id": "b",
                "text": "Exactly 1 queen"
              },
              {
                "id": "c",
                "text": "2 queens"
              },
              {
                "id": "d",
                "text": "Any number"
              }
            ],
            "correct": "b",
            "explanation": "More than one queen in a row = they attack each other. We need exactly n queens in n rows.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To ensure no two queens share a column:",
            "options": [
              {
                "id": "a",
                "text": "Sort the queens"
              },
              {
                "id": "b",
                "text": "Track which columns are used"
              },
              {
                "id": "c",
                "text": "Check board after placing all"
              },
              {
                "id": "d",
                "text": "Use diagonals"
              }
            ],
            "correct": "b",
            "explanation": "Keep a set of occupied columns. Skip columns already used.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "Cells on the same diagonal share:",
            "options": [
              {
                "id": "a",
                "text": "Same row - column value (for one diagonal direction)"
              },
              {
                "id": "b",
                "text": "Same row + column value (for other diagonal)"
              },
              {
                "id": "c",
                "text": "Both A and B identify the two diagonal directions"
              },
              {
                "id": "d",
                "text": "Nothing in common"
              }
            ],
            "correct": "c",
            "explanation": "(r-c) is constant on one diagonal, (r+c) on the other.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We backtrack when:",
            "options": [
              {
                "id": "a",
                "text": "No column in current row is safe"
              },
              {
                "id": "b",
                "text": "We've placed one queen"
              },
              {
                "id": "c",
                "text": "Row index exceeds n"
              },
              {
                "id": "d",
                "text": "All columns tried in first row"
              }
            ],
            "correct": "a",
            "explanation": "If no valid placement in current row, previous choices were wrong. Undo and try different.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We found a valid solution when:",
            "options": [
              {
                "id": "a",
                "text": "All columns are used"
              },
              {
                "id": "b",
                "text": "All n rows have a queen"
              },
              {
                "id": "c",
                "text": "Board looks symmetric"
              },
              {
                "id": "d",
                "text": "No queens attack"
              }
            ],
            "correct": "b",
            "explanation": "If we successfully place a queen in each of n rows, we have a valid configuration.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Row by row: for each column, check if column, (row-col), and (row+col) are free. Place queen, recurse, backtrack. Found when row == n.",
        "pattern": "Backtracking",
        "keyInsight": "Place one queen per row. Track which columns and diagonals are occupied.",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "n-queens",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def solveNQueens(n: int) -> List[List[str]]:\n    result = []\n    cols = set()\n    pos_diag = set()  # r + c\n    neg_diag = set()  # r - c\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    \n    def backtrack(row):\n        if row == n:\n            result.append([''.join(r) for r in board])\n            return\n        \n        for col in range(n):\n            if col in cols or (row + col) in pos_diag or (row - col) in neg_diag:\n                continue\n            \n            cols.add(col)\n            pos_diag.add(row + col)\n            neg_diag.add(row - col)\n            board[row][col] = 'Q'\n            \n            backtrack(row + 1)\n            \n            cols.remove(col)\n            pos_diag.remove(row + col)\n            neg_diag.remove(row - col)\n            board[row][col] = '.'\n    \n    backtrack(0)\n    return result"
      }
    ],
    "heap": [
      {
        "id": "01-kth-largest-element-in-stream",
        "slug": "kth-largest-element-in-stream",
        "title": "Kth Largest Element in a Stream",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "kth-largest-element-in-a-stream"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a class to find the `k`th largest element in a stream. Note that it is the `k`th largest element in the sorted order, not the `k`th distinct element.\n\nImplement `KthLargest` class:\n- `KthLargest(int k, int[] nums)` Initializes the object with the integer `k` and the stream of integers `nums`.\n- `int add(int val)` Appends the integer `val` to the stream and returns the element representing the `k`th largest element in the stream.",
        "examples": [
          {
            "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]",
            "output": "[null, 4, 5, 5, 8, 8]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For kth largest, we use min-heap because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "Root gives us the smallest of the k largest = kth largest"
              },
              {
                "id": "c",
                "text": "We want minimum element"
              },
              {
                "id": "d",
                "text": "Heaps only come in min form"
              }
            ],
            "correct": "b",
            "explanation": "With k elements in min-heap, root is smallest = kth largest overall.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "We maintain heap of size:",
            "options": [
              {
                "id": "a",
                "text": "n (all elements)"
              },
              {
                "id": "b",
                "text": "k"
              },
              {
                "id": "c",
                "text": "n - k"
              },
              {
                "id": "d",
                "text": "1"
              }
            ],
            "correct": "b",
            "explanation": "Only keep the k largest. Anything smaller isn't relevant.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If new element > heap root and heap has k elements:",
            "options": [
              {
                "id": "a",
                "text": "Ignore new element"
              },
              {
                "id": "b",
                "text": "Pop root, push new element"
              },
              {
                "id": "c",
                "text": "Push without popping"
              },
              {
                "id": "d",
                "text": "Clear heap"
              }
            ],
            "correct": "b",
            "explanation": "New element should be in top k. Old minimum is no longer in top k.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If new element < heap root and heap has k elements:",
            "options": [
              {
                "id": "a",
                "text": "Pop root, push new element"
              },
              {
                "id": "b",
                "text": "Ignore new element"
              },
              {
                "id": "c",
                "text": "Replace all elements"
              },
              {
                "id": "d",
                "text": "Push anyway"
              }
            ],
            "correct": "b",
            "explanation": "New element isn't in top k. Don't add it.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If nums has fewer than k elements initially:",
            "options": [
              {
                "id": "a",
                "text": "Error"
              },
              {
                "id": "b",
                "text": "Push all, wait for more elements"
              },
              {
                "id": "c",
                "text": "Fill with zeros"
              },
              {
                "id": "d",
                "text": "Return -1"
              }
            ],
            "correct": "b",
            "explanation": "Start with what we have. Add more as they come.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "The kth largest is:",
            "options": [
              {
                "id": "a",
                "text": "Heap root"
              },
              {
                "id": "b",
                "text": "Sum of heap"
              },
              {
                "id": "c",
                "text": "Largest in heap"
              },
              {
                "id": "d",
                "text": "Random element"
              }
            ],
            "correct": "a",
            "explanation": "Min-heap root = smallest in heap = kth largest overall.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Min-heap of size k: if new element > root, replace root. Root always gives kth largest.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Use a min-heap of size k. The root is always the kth largest.",
        "timeComplexity": "O(log k) per add",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "kth largest element in a stream",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = nums\n        heapq.heapify(self.heap)\n        \n        while len(self.heap) > k:\n            heapq.heappop(self.heap)\n    \n    def add(self, val: int) -> int:\n        heapq.heappush(self.heap, val)\n        \n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n        \n        return self.heap[0]"
      },
      {
        "id": "02-last-stone-weight",
        "slug": "last-stone-weight",
        "title": "Last Stone Weight",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "last-stone-weight"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of integers `stones` where `stones[i]` is the weight of the `i`th stone.\n\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n- If `x == y`, both stones are destroyed.\n- If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is at most one stone left.\n\nReturn the weight of the last remaining stone. If there are no stones left, return `0`.",
        "examples": [
          {
            "input": "stones = [2,7,4,1,8,1]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We use a heap because:",
            "options": [
              {
                "id": "a",
                "text": "We need sorted order"
              },
              {
                "id": "b",
                "text": "We need quick access to maximum elements"
              },
              {
                "id": "c",
                "text": "Heaps are faster than arrays"
              },
              {
                "id": "d",
                "text": "Problem says to use heap"
              }
            ],
            "correct": "b",
            "explanation": "Extracting two max elements repeatedly = heap's strength.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "We need:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap (default in Python)"
              },
              {
                "id": "b",
                "text": "Max-heap"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "b",
            "explanation": "We want the two heaviest. Max-heap gives max at root.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Python's heapq is a min-heap. To simulate max-heap:",
            "options": [
              {
                "id": "a",
                "text": "Use a different library"
              },
              {
                "id": "b",
                "text": "Negate all values"
              },
              {
                "id": "c",
                "text": "Sort the list"
              },
              {
                "id": "d",
                "text": "Reverse the heap"
              }
            ],
            "correct": "b",
            "explanation": "Negating turns max into min. pop gives -max = actual max.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "After smashing stones x and y (x <= y):",
            "options": [
              {
                "id": "a",
                "text": "Always push y-x"
              },
              {
                "id": "b",
                "text": "Push y-x only if y-x > 0"
              },
              {
                "id": "c",
                "text": "Push x-y"
              },
              {
                "id": "d",
                "text": "Push both"
              }
            ],
            "correct": "b",
            "explanation": "If y == x, both destroyed (nothing to push). Otherwise push remainder.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "We stop when:",
            "options": [
              {
                "id": "a",
                "text": "Heap is empty"
              },
              {
                "id": "b",
                "text": "Heap has 1 element"
              },
              {
                "id": "c",
                "text": "Heap has <= 1 element"
              },
              {
                "id": "d",
                "text": "After 10 iterations"
              }
            ],
            "correct": "c",
            "explanation": "With 0 stones, answer is 0. With 1 stone, answer is its weight.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Final answer is:",
            "options": [
              {
                "id": "a",
                "text": "Heap root if heap has 1 element, else 0"
              },
              {
                "id": "b",
                "text": "Always 0"
              },
              {
                "id": "c",
                "text": "Sum of remaining"
              },
              {
                "id": "d",
                "text": "Last extracted value"
              }
            ],
            "correct": "a",
            "explanation": "Either one stone left or no stones left.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Max-heap for 'heaviest two' access. Pop two, push difference if nonzero. Return last remaining or 0.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Max-heap gives O(log n) access to largest elements.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "last stone weight",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef lastStoneWeight(stones: List[int]) -> int:\n    # Use negative values for max-heap\n    heap = [-s for s in stones]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        y = -heapq.heappop(heap)  # Largest\n        x = -heapq.heappop(heap)  # Second largest\n        \n        if y != x:\n            heapq.heappush(heap, -(y - x))\n    \n    return -heap[0] if heap else 0"
      },
      {
        "id": "03-k-closest-points-to-origin",
        "slug": "k-closest-points-to-origin",
        "title": "K Closest Points to Origin",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "k-closest-points-to-origin"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.\n\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., `sqrt((x1 - x2)^2 + (y1 - y2)^2)`).\n\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).",
        "examples": [
          {
            "input": "points = [[1,3],[-2,2]], k = 1",
            "output": "[[-2,2]]",
            "explanation": "Distance of (1,3) = sqrt(10), (-2,2) = sqrt(8). Closest is (-2,2)."
          },
          {
            "input": "points = [[3,3],[5,-1],[-2,4]], k = 2",
            "output": "[[3,3],[-2,4]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To compare distances without computing sqrt, we can use:",
            "options": [
              {
                "id": "a",
                "text": "sqrt(x^2 + y^2) exactly"
              },
              {
                "id": "b",
                "text": "x^2 + y^2 (squared distance)"
              },
              {
                "id": "c",
                "text": "|x| + |y|"
              },
              {
                "id": "d",
                "text": "max(|x|, |y|)"
              }
            ],
            "correct": "b",
            "explanation": "sqrt is monotonic. Comparing squared distances gives same ordering, avoids floating point.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For k closest, we use:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap of all points"
              },
              {
                "id": "b",
                "text": "Max-heap of size k"
              },
              {
                "id": "c",
                "text": "Min-heap of size k"
              },
              {
                "id": "d",
                "text": "Max-heap of all points"
              }
            ],
            "correct": "b",
            "explanation": "We want the k smallest. Max-heap lets us kick out the largest among our k candidates.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "The heap should store:",
            "options": [
              {
                "id": "a",
                "text": "Just distances"
              },
              {
                "id": "b",
                "text": "Just points"
              },
              {
                "id": "c",
                "text": "(distance, point) pairs"
              },
              {
                "id": "d",
                "text": "Point indices"
              }
            ],
            "correct": "c",
            "explanation": "Need distance for comparison, need point for final answer.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If new point is closer than heap root (and heap full):",
            "options": [
              {
                "id": "a",
                "text": "Ignore new point"
              },
              {
                "id": "b",
                "text": "Pop root (farthest), push new point"
              },
              {
                "id": "c",
                "text": "Push without popping"
              },
              {
                "id": "d",
                "text": "Clear and restart"
              }
            ],
            "correct": "b",
            "explanation": "New point deserves to be in top k. Current farthest doesn't.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "After processing all points, the answer is:",
            "options": [
              {
                "id": "a",
                "text": "Just the heap root"
              },
              {
                "id": "b",
                "text": "All points in the heap"
              },
              {
                "id": "c",
                "text": "Points not in the heap"
              },
              {
                "id": "d",
                "text": "The last k points added"
              }
            ],
            "correct": "b",
            "explanation": "Heap contains exactly the k closest points.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Another valid O(n) average approach is:",
            "options": [
              {
                "id": "a",
                "text": "Sorting"
              },
              {
                "id": "b",
                "text": "Quickselect"
              },
              {
                "id": "c",
                "text": "Binary search"
              },
              {
                "id": "d",
                "text": "Two pointers"
              }
            ],
            "correct": "b",
            "explanation": "Quickselect finds k smallest in O(n) average. Heap is O(n log k).",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Max-heap of size k for 'k smallest': root is farthest among candidates. If new point closer than root, swap. Final heap = k closest.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Use max-heap of size k. Keep only the k smallest distances.",
        "timeComplexity": "O(n log k)",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "k closest points to origin",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef kClosest(points: List[List[int]], k: int) -> List[List[int]]:\n    # Max-heap of size k (negate distances)\n    heap = []\n    \n    for x, y in points:\n        dist = -(x*x + y*y)  # Negative for max-heap\n        \n        if len(heap) < k:\n            heapq.heappush(heap, (dist, x, y))\n        elif dist > heap[0][0]:  # Closer than farthest\n            heapq.heapreplace(heap, (dist, x, y))\n    \n    return [[x, y] for _, x, y in heap]"
      },
      {
        "id": "04-kth-largest-element-in-array",
        "slug": "kth-largest-element-in-array",
        "title": "Kth Largest Element in an Array",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "kth-largest-element-in-an-array"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums` and an integer `k`, return the `k`th largest element in the array.\n\nNote that it is the `k`th largest element in the sorted order, not the `k`th distinct element.\n\nCan you solve it without sorting?",
        "examples": [
          {
            "input": "nums = [3,2,1,5,6,4], k = 2",
            "output": "5",
            "explanation": ""
          },
          {
            "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
            "output": "4",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Sort descending, return arr[k-1]:",
            "options": [
              {
                "id": "a",
                "text": "Doesn't work"
              },
              {
                "id": "b",
                "text": "Works, O(n log n)"
              },
              {
                "id": "c",
                "text": "Works, O(n)"
              },
              {
                "id": "d",
                "text": "Works, O(1)"
              }
            ],
            "correct": "b",
            "explanation": "Sorting works but isn't optimal. O(n log n) time.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Min-heap of size k gives kth largest because:",
            "options": [
              {
                "id": "a",
                "text": "Heap root is always kth largest"
              },
              {
                "id": "b",
                "text": "We need to negate values"
              },
              {
                "id": "c",
                "text": "K largest elements are in heap, smallest of them is kth largest"
              },
              {
                "id": "d",
                "text": "Both A and C"
              }
            ],
            "correct": "d",
            "explanation": "Heap keeps k largest. Min among them = kth largest overall.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Using heap of size n vs size k:",
            "options": [
              {
                "id": "a",
                "text": "Size n is faster"
              },
              {
                "id": "b",
                "text": "Size k is faster for k << n"
              },
              {
                "id": "c",
                "text": "Same speed"
              },
              {
                "id": "d",
                "text": "Size k uses more memory"
              }
            ],
            "correct": "b",
            "explanation": "O(n log k) vs O(n log n). When k is small, log k << log n.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Quickselect is like quicksort but:",
            "options": [
              {
                "id": "a",
                "text": "Sorts completely"
              },
              {
                "id": "b",
                "text": "Only recurses on one side"
              },
              {
                "id": "c",
                "text": "Uses merge instead"
              },
              {
                "id": "d",
                "text": "Is always O(n log n)"
              }
            ],
            "correct": "b",
            "explanation": "We only care about kth position. Recurse only on the side containing it.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "After partition around pivot, if pivot is at index p:",
            "options": [
              {
                "id": "a",
                "text": "If p == n-k, pivot is the answer"
              },
              {
                "id": "b",
                "text": "If p < n-k, recurse right"
              },
              {
                "id": "c",
                "text": "If p > n-k, recurse left"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "Partition puts pivot in correct sorted position. Compare with target position n-k.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For guaranteed O(n log k) with simple code:",
            "options": [
              {
                "id": "a",
                "text": "Sorting"
              },
              {
                "id": "b",
                "text": "Heap"
              },
              {
                "id": "c",
                "text": "Quickselect"
              },
              {
                "id": "d",
                "text": "Linear scan"
              }
            ],
            "correct": "b",
            "explanation": "Quickselect is O(n) average but O(n^2) worst. Heap is reliably O(n log k).",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Min-heap of size k: process all elements, keeping k largest. Root is kth largest. Quickselect for O(n) average.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Min-heap of size k: process all elements, keeping k largest. Root is kth largest.",
        "timeComplexity": "O(n log k)",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "kth largest element in an array",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef findKthLargest(nums: List[int], k: int) -> int:\n    # Min-heap of size k\n    heap = []\n    \n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return heap[0]"
      },
      {
        "id": "05-task-scheduler",
        "slug": "task-scheduler",
        "title": "Task Scheduler",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "task-scheduler"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n\nHowever, there is a non-negative integer `n` that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least `n` units of time between any two same tasks.\n\nReturn the least number of units of times that the CPU will take to finish all the given tasks.",
        "examples": [
          {
            "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
            "output": "8",
            "explanation": "A -> B -> idle -> A -> B -> idle -> A -> B"
          },
          {
            "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0",
            "output": "6",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At each time unit, we should pick:",
            "options": [
              {
                "id": "a",
                "text": "Random available task"
              },
              {
                "id": "b",
                "text": "Task with highest remaining count"
              },
              {
                "id": "c",
                "text": "Alphabetically first task"
              },
              {
                "id": "d",
                "text": "Task used longest ago"
              }
            ],
            "correct": "b",
            "explanation": "Processing frequent tasks early gives more flexibility to schedule them with gaps.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "Greedy picks most frequent because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "It minimizes idle slots needed"
              },
              {
                "id": "c",
                "text": "It's alphabetically first"
              },
              {
                "id": "d",
                "text": "Random choice"
              }
            ],
            "correct": "b",
            "explanation": "High-frequency tasks need the most gaps. Handle them first to fill gaps optimally.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "To respect cooldown, we:",
            "options": [
              {
                "id": "a",
                "text": "Sort by last used time"
              },
              {
                "id": "b",
                "text": "Track when each task becomes available"
              },
              {
                "id": "c",
                "text": "Only use one task"
              },
              {
                "id": "d",
                "text": "Ignore cooldown"
              }
            ],
            "correct": "b",
            "explanation": "A task used at time t is available again at time t + n + 1.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "We idle when:",
            "options": [
              {
                "id": "a",
                "text": "There are tasks but none are available due to cooldown"
              },
              {
                "id": "b",
                "text": "All tasks are done"
              },
              {
                "id": "c",
                "text": "We've been working too long"
              },
              {
                "id": "d",
                "text": "Random"
              }
            ],
            "correct": "a",
            "explanation": "If all remaining tasks are on cooldown, must idle.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Max-heap helps because:",
            "options": [
              {
                "id": "a",
                "text": "O(log k) access to most frequent task"
              },
              {
                "id": "b",
                "text": "It tracks cooldown"
              },
              {
                "id": "c",
                "text": "It's faster than sorting"
              },
              {
                "id": "d",
                "text": "It stores time"
              }
            ],
            "correct": "a",
            "explanation": "We repeatedly need the task with max remaining count.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "A queue can track:",
            "options": [
              {
                "id": "a",
                "text": "Tasks currently on cooldown"
              },
              {
                "id": "b",
                "text": "All tasks"
              },
              {
                "id": "c",
                "text": "Completed tasks"
              },
              {
                "id": "d",
                "text": "Time elapsed"
              }
            ],
            "correct": "a",
            "explanation": "Queue holds (available_time, count) for tasks on cooldown. Pop when time arrives.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Greedy: always pick most frequent available task. Use formula: max(total_tasks, (maxFreq-1)*(n+1) + count_of_max_freq_tasks).",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Greedy: always process the most frequent task available.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "task scheduler",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import Counter\n\ndef leastInterval(tasks: List[str], n: int) -> int:\n    counts = Counter(tasks)\n    max_freq = max(counts.values())\n    max_freq_count = sum(1 for c in counts.values() if c == max_freq)\n    \n    # Formula: (max_freq - 1) cycles of (n + 1) slots + final tasks\n    min_time = (max_freq - 1) * (n + 1) + max_freq_count\n    \n    # At least need time for all tasks\n    return max(min_time, len(tasks))"
      },
      {
        "id": "06-design-twitter",
        "slug": "design-twitter",
        "title": "Design Twitter",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "design-twitter"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and see the 10 most recent tweets in the user's news feed.\n\nImplement the `Twitter` class:\n- `Twitter()` Initializes your twitter object.\n- `void postTweet(int userId, int tweetId)` Composes a new tweet with ID `tweetId` by the user `userId`. Each call to this function will be made with a unique `tweetId`.\n- `List<Integer> getNewsFeed(int userId)` Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themselves. Tweets must be ordered from most recent to least recent.\n- `void follow(int followerId, int followeeId)` The user with ID `followerId` started following the user with ID `followeeId`.\n- `void unfollow(int followerId, int followeeId)` The user with ID `followerId` started unfollowing the user with ID `followeeId`.",
        "examples": [
          {
            "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]",
            "output": "[null, null, [5], null, [6, 5], null, [5]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Each user's tweets should be stored as:",
            "options": [
              {
                "id": "a",
                "text": "Hash set"
              },
              {
                "id": "b",
                "text": "List ordered by time"
              },
              {
                "id": "c",
                "text": "Single most recent only"
              },
              {
                "id": "d",
                "text": "Linked list with random order"
              }
            ],
            "correct": "b",
            "explanation": "Need to retrieve by recency. Newest first (or append and iterate backwards).",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "User's followees should be stored as:",
            "options": [
              {
                "id": "a",
                "text": "List"
              },
              {
                "id": "b",
                "text": "Set"
              },
              {
                "id": "c",
                "text": "Queue"
              },
              {
                "id": "d",
                "text": "Stack"
              }
            ],
            "correct": "b",
            "explanation": "Need O(1) add, remove, and lookup. Set provides all three.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "To get 10 most recent from k users:",
            "options": [
              {
                "id": "a",
                "text": "Collect all tweets, sort, take 10"
              },
              {
                "id": "b",
                "text": "Use heap to merge k sorted lists"
              },
              {
                "id": "c",
                "text": "Take 10 from each user"
              },
              {
                "id": "d",
                "text": "Random selection"
              }
            ],
            "correct": "b",
            "explanation": "Merge k sorted lists is the classic heap problem. O(k log k) for 10 items.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For merging k tweet lists to get most recent:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap"
              },
              {
                "id": "b",
                "text": "Max-heap"
              },
              {
                "id": "c",
                "text": "Either works"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "b",
            "explanation": "We want the most recent (largest timestamp). Max-heap by timestamp.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Getting 10 tweets from k followed users:",
            "options": [
              {
                "id": "a",
                "text": "O(k)"
              },
              {
                "id": "b",
                "text": "O(k log k) for 10 items = O(k log k)"
              },
              {
                "id": "c",
                "text": "O(10 log k) = O(log k)"
              },
              {
                "id": "d",
                "text": "O(n) for all tweets"
              }
            ],
            "correct": "b",
            "explanation": "Initialize heap with k users' latest tweets: O(k). Extract 10: O(10 log k).",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Merge k sorted tweet lists using heap. Each user's tweets are time-ordered. Heap holds one 'pointer' per user, extracting top 10.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "NewsFeed = merge k sorted lists (each user's tweets are time-ordered).",
        "timeComplexity": "O(k log k) for getNewsFeed",
        "spaceComplexity": "O(users + tweets)",
        "triggerWords": [
          "design twitter",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)  # userId -> [(time, tweetId)]\n        self.following = defaultdict(set)  # userId -> set of followeeIds\n    \n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n    \n    def getNewsFeed(self, userId: int) -> List[int]:\n        # Get tweets from user and all followees\n        heap = []\n        users = self.following[userId] | {userId}\n        \n        for uid in users:\n            if self.tweets[uid]:\n                idx = len(self.tweets[uid]) - 1\n                time, tweetId = self.tweets[uid][idx]\n                heap.append((-time, tweetId, uid, idx))\n        \n        heapq.heapify(heap)\n        result = []\n        \n        while heap and len(result) < 10:\n            _, tweetId, uid, idx = heapq.heappop(heap)\n            result.append(tweetId)\n            \n            if idx > 0:\n                time, tweetId = self.tweets[uid][idx - 1]\n                heapq.heappush(heap, (-time, tweetId, uid, idx - 1))\n        \n        return result\n    \n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n    \n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].discard(followeeId)"
      },
      {
        "id": "07-find-median-from-data-stream",
        "slug": "find-median-from-data-stream",
        "title": "Find Median from Data Stream",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "find-median-from-data-stream"
        ],
        "estimatedTime": 5,
        "problemStatement": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nImplement the `MedianFinder` class:\n- `MedianFinder()` initializes the MedianFinder object.\n- `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far.",
        "examples": [
          {
            "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]",
            "output": "[null, null, null, 1.5, null, 2.0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Using a sorted list for each insert:",
            "options": [
              {
                "id": "a",
                "text": "O(1) insert, O(n) find median"
              },
              {
                "id": "b",
                "text": "O(n) insert, O(1) find median"
              },
              {
                "id": "c",
                "text": "O(log n) for both"
              },
              {
                "id": "d",
                "text": "Doesn't work"
              }
            ],
            "correct": "b",
            "explanation": "Inserting into sorted list is O(n). We want O(log n) insert.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For the smaller half, we use:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap"
              },
              {
                "id": "b",
                "text": "Max-heap"
              },
              {
                "id": "c",
                "text": "Either"
              },
              {
                "id": "d",
                "text": "Not a heap"
              }
            ],
            "correct": "b",
            "explanation": "We need quick access to the LARGEST of the smaller half. Max-heap gives max at root.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For the larger half, we use:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap"
              },
              {
                "id": "b",
                "text": "Max-heap"
              },
              {
                "id": "c",
                "text": "Either"
              },
              {
                "id": "d",
                "text": "Not a heap"
              }
            ],
            "correct": "a",
            "explanation": "We need quick access to the SMALLEST of the larger half. Min-heap gives min at root.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "The heaps should be balanced such that:",
            "options": [
              {
                "id": "a",
                "text": "Sizes are exactly equal"
              },
              {
                "id": "b",
                "text": "Sizes differ by at most 1"
              },
              {
                "id": "c",
                "text": "Left is always larger"
              },
              {
                "id": "d",
                "text": "Right is always larger"
              }
            ],
            "correct": "b",
            "explanation": "For odd count, one heap has one extra element (median is its top). For even, both same size.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If total count is odd, median is:",
            "options": [
              {
                "id": "a",
                "text": "Top of larger heap"
              },
              {
                "id": "b",
                "text": "Top of smaller heap"
              },
              {
                "id": "c",
                "text": "Top of the heap with more elements"
              },
              {
                "id": "d",
                "text": "Average of tops"
              }
            ],
            "correct": "c",
            "explanation": "The extra element is the median. Whichever heap has n/2+1 elements has the median.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If total count is even, median is:",
            "options": [
              {
                "id": "a",
                "text": "Top of max-heap"
              },
              {
                "id": "b",
                "text": "Top of min-heap"
              },
              {
                "id": "c",
                "text": "Average of both tops"
              },
              {
                "id": "d",
                "text": "Sum of both tops"
              }
            ],
            "correct": "c",
            "explanation": "Two middle elements are at the boundary. Average them.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Two heaps: max-heap for smaller half, min-heap for larger half. Keep balanced (sizes differ <= 1). Median = top of larger heap or average of tops.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Use two heaps: max-heap for smaller half, min-heap for larger half.",
        "timeComplexity": "O(log n) add, O(1) find",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "find median from data stream",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # Max-heap (negated values)\n        self.large = []  # Min-heap\n    \n    def addNum(self, num: int) -> None:\n        # Add to max-heap (smaller half)\n        heapq.heappush(self.small, -num)\n        \n        # Balance: move largest from small to large\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        \n        # Ensure small has >= elements as large\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    \n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2"
      }
    ],
    "graphs": [
      {
        "id": "01-number-of-islands",
        "slug": "number-of-islands",
        "title": "Number of Islands",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "number-of-islands"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
        "examples": [
          {
            "input": "grid = [",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "grid = [",
            "output": "3",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "An island is:",
            "options": [
              {
                "id": "a",
                "text": "Any single '1'"
              },
              {
                "id": "b",
                "text": "A connected group of '1's"
              },
              {
                "id": "c",
                "text": "All '1's in the grid"
              },
              {
                "id": "d",
                "text": "'1's on the edge"
              }
            ],
            "correct": "b",
            "explanation": "Adjacent '1's (up/down/left/right) form one island.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Each '1' cell is:",
            "options": [
              {
                "id": "a",
                "text": "An edge"
              },
              {
                "id": "b",
                "text": "A node with edges to adjacent '1's"
              },
              {
                "id": "c",
                "text": "Not part of the graph"
              },
              {
                "id": "d",
                "text": "Always isolated"
              }
            ],
            "correct": "b",
            "explanation": "Think of it as a graph. Nodes = land cells. Edges = adjacency.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "To count islands, we:",
            "options": [
              {
                "id": "a",
                "text": "Count all '1's"
              },
              {
                "id": "b",
                "text": "Count connected components of '1's"
              },
              {
                "id": "c",
                "text": "Count '0's between '1's"
              },
              {
                "id": "d",
                "text": "Count rows with '1's"
              }
            ],
            "correct": "b",
            "explanation": "Each connected component = one island.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We can use:",
            "options": [
              {
                "id": "a",
                "text": "DFS"
              },
              {
                "id": "b",
                "text": "BFS"
              },
              {
                "id": "c",
                "text": "Union-Find"
              },
              {
                "id": "d",
                "text": "Any of the above"
              }
            ],
            "correct": "d",
            "explanation": "All three work. DFS is simplest. Union-Find is elegant for component counting.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "To avoid counting the same island twice:",
            "options": [
              {
                "id": "a",
                "text": "Use a separate visited matrix"
              },
              {
                "id": "b",
                "text": "Modify the grid in-place (change '1' to '0')"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "Don't track visited"
              }
            ],
            "correct": "c",
            "explanation": "Both work. In-place saves space but modifies input.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We increment island count when:",
            "options": [
              {
                "id": "a",
                "text": "We find any '1'"
              },
              {
                "id": "b",
                "text": "We find an unvisited '1'"
              },
              {
                "id": "c",
                "text": "We finish traversing an island"
              },
              {
                "id": "d",
                "text": "Both B and C"
              }
            ],
            "correct": "d",
            "explanation": "We increment when starting a new island (unvisited '1'). This is also when we finish that we've counted it.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Count connected components: for each unvisited '1', increment count and flood-fill to mark the entire island.",
        "pattern": "Graph Traversal",
        "keyInsight": "When you find a '1', mark the entire island (all connected '1's) as visited. Count how many times you start a new island.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m × n)",
        "triggerWords": [
          "number of islands",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def numIslands(grid: List[List[str]]) -> int:\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if grid[r][c] != '1':\n            return\n        \n        grid[r][c] = '0'  # Mark visited\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                count += 1\n                dfs(r, c)\n    \n    return count"
      },
      {
        "id": "02-clone-graph",
        "slug": "clone-graph",
        "title": "Clone Graph",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "clone-graph"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Copying node.neighbors directly fails because:",
            "options": [
              {
                "id": "a",
                "text": "It copies the list"
              },
              {
                "id": "b",
                "text": "It still points to original nodes"
              },
              {
                "id": "c",
                "text": "Neighbors don't exist"
              },
              {
                "id": "d",
                "text": "Values are wrong"
              }
            ],
            "correct": "b",
            "explanation": "We need neighbors to point to NEW cloned nodes, not originals.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "The old→new hashmap:",
            "options": [
              {
                "id": "a",
                "text": "Stores node values"
              },
              {
                "id": "b",
                "text": "Maps original nodes to their clones"
              },
              {
                "id": "c",
                "text": "Counts visits"
              },
              {
                "id": "d",
                "text": "Stores edges"
              }
            ],
            "correct": "b",
            "explanation": "When we need the clone of a node, we look it up in the map.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "For cycles (node A's neighbor is B, B's neighbor is A):",
            "options": [
              {
                "id": "a",
                "text": "Skip duplicate nodes"
              },
              {
                "id": "b",
                "text": "Check hashmap before creating new clone"
              },
              {
                "id": "c",
                "text": "Only process once"
              },
              {
                "id": "d",
                "text": "B and C"
              }
            ],
            "correct": "d",
            "explanation": "If we've already cloned a node (it's in hashmap), reuse that clone instead of creating another.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We can traverse the graph using:",
            "options": [
              {
                "id": "a",
                "text": "DFS"
              },
              {
                "id": "b",
                "text": "BFS"
              },
              {
                "id": "c",
                "text": "Either"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Both work. We just need to visit all nodes.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We create a clone:",
            "options": [
              {
                "id": "a",
                "text": "Before visiting a node"
              },
              {
                "id": "b",
                "text": "When we first visit a node"
              },
              {
                "id": "c",
                "text": "After visiting all neighbors"
              },
              {
                "id": "d",
                "text": "Only for leaf nodes"
              }
            ],
            "correct": "b",
            "explanation": "Create clone immediately, add to hashmap, then process neighbors.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "For clone of node N, its neighbors are:",
            "options": [
              {
                "id": "a",
                "text": "Copies of N.neighbors"
              },
              {
                "id": "b",
                "text": "Clones of each neighbor (from hashmap)"
              },
              {
                "id": "c",
                "text": "Empty list"
              },
              {
                "id": "d",
                "text": "Same as N.neighbors"
              }
            ],
            "correct": "b",
            "explanation": "Each neighbor must be the cloned version, which we look up (or create).",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "DFS/BFS with old→new hashmap. For each node: create clone if not in map, then set neighbors to cloned versions (lookup in map).",
        "pattern": "Graph Traversal",
        "keyInsight": "Map old nodes to new nodes. When setting neighbors, look up the clone.",
        "timeComplexity": "O(V + E)",
        "spaceComplexity": "O(V)",
        "triggerWords": [
          "clone graph",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def cloneGraph(node: 'Node') -> 'Node':\n    if not node:\n        return None\n    \n    old_to_new = {}\n    \n    def dfs(node):\n        if node in old_to_new:\n            return old_to_new[node]\n        \n        # Create clone\n        copy = Node(node.val)\n        old_to_new[node] = copy\n        \n        # Clone neighbors\n        for neighbor in node.neighbors:\n            copy.neighbors.append(dfs(neighbor))\n        \n        return copy\n    \n    return dfs(node)"
      },
      {
        "id": "03-pacific-atlantic-water-flow",
        "slug": "pacific-atlantic-water-flow",
        "title": "Pacific Atlantic Water Flow",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "pacific-atlantic-water-flow"
        ],
        "estimatedTime": 5,
        "problemStatement": "There is an `m x n` rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\n\nThe island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the height above sea level of the cell at coordinate `(r, c)`.\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\nReturn a 2D list of grid coordinates `result` where `result[i] = [ri, ci]` denotes that rain water can flow from cell `(ri, ci)` to both the Pacific and Atlantic oceans.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Water flows from cell A to B if:",
            "options": [
              {
                "id": "a",
                "text": "A's height > B's height"
              },
              {
                "id": "b",
                "text": "A's height >= B's height (water flows downhill or flat)"
              },
              {
                "id": "c",
                "text": "A's height < B's height"
              },
              {
                "id": "d",
                "text": "They're adjacent"
              }
            ],
            "correct": "b",
            "explanation": "Water flows to equal or lower heights.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Searching \"uphill\" from ocean means:",
            "options": [
              {
                "id": "a",
                "text": "Move to cells with lower height"
              },
              {
                "id": "b",
                "text": "Move to cells with >= height"
              },
              {
                "id": "c",
                "text": "Always move up"
              },
              {
                "id": "d",
                "text": "Move to cells with exactly equal height"
              }
            ],
            "correct": "b",
            "explanation": "Reverse of downhill. If water can flow from B to A, we can reach B from A when going uphill.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Starting from oceans is better because:",
            "options": [
              {
                "id": "a",
                "text": "Fewer starting points (only edges)"
              },
              {
                "id": "b",
                "text": "It's the same as starting from each cell"
              },
              {
                "id": "c",
                "text": "Water only flows to oceans"
              },
              {
                "id": "d",
                "text": "It's faster to go uphill"
              }
            ],
            "correct": "a",
            "explanation": "Edge cells are O(m+n), vs O(mn) interior cells. Two DFS from edges, then intersect.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Pacific-adjacent cells are:",
            "options": [
              {
                "id": "a",
                "text": "Top row only"
              },
              {
                "id": "b",
                "text": "Left column only"
              },
              {
                "id": "c",
                "text": "Top row and left column"
              },
              {
                "id": "d",
                "text": "All edge cells"
              }
            ],
            "correct": "c",
            "explanation": "Pacific touches top and left edges.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "A cell is in the answer if:",
            "options": [
              {
                "id": "a",
                "text": "Reachable from Pacific"
              },
              {
                "id": "b",
                "text": "Reachable from Atlantic"
              },
              {
                "id": "c",
                "text": "Reachable from both"
              },
              {
                "id": "d",
                "text": "Reachable from neither"
              }
            ],
            "correct": "c",
            "explanation": "Must be able to flow to BOTH oceans.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We run DFS:",
            "options": [
              {
                "id": "a",
                "text": "Once from all ocean cells together"
              },
              {
                "id": "b",
                "text": "Once from Pacific edges, once from Atlantic edges"
              },
              {
                "id": "c",
                "text": "From every cell"
              },
              {
                "id": "d",
                "text": "Only from corners"
              }
            ],
            "correct": "b",
            "explanation": "Track reachability separately, then find intersection.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Reverse the flow: DFS 'uphill' from Pacific edges, DFS 'uphill' from Atlantic edges. Answer = intersection of both reachable sets.",
        "pattern": "Graph Traversal",
        "keyInsight": "Reverse the flow: start from oceans and flow \"uphill.\"",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m × n)",
        "triggerWords": [
          "pacific atlantic water flow",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def pacificAtlantic(heights: List[List[int]]) -> List[List[int]]:\n    rows, cols = len(heights), len(heights[0])\n    pacific, atlantic = set(), set()\n    \n    def dfs(r, c, visit, prev_height):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or\n            (r, c) in visit or heights[r][c] < prev_height):\n            return\n        \n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])\n    \n    for c in range(cols):\n        dfs(0, c, pacific, 0)        # Top row (Pacific)\n        dfs(rows - 1, c, atlantic, 0) # Bottom row (Atlantic)\n    \n    for r in range(rows):\n        dfs(r, 0, pacific, 0)        # Left col (Pacific)\n        dfs(r, cols - 1, atlantic, 0) # Right col (Atlantic)\n    \n    return list(pacific & atlantic)"
      },
      {
        "id": "04-course-schedule",
        "slug": "course-schedule",
        "title": "Course Schedule",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "course-schedule"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.",
        "examples": [
          {
            "input": "numCourses = 2, prerequisites = [[1,0]]",
            "output": "true",
            "explanation": "Take course 0 first, then course 1."
          },
          {
            "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
            "output": "false",
            "explanation": "Circular dependency. Can't finish either."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "prerequisites = [[1,0], [2,1]] means:",
            "options": [
              {
                "id": "a",
                "text": "0→1→2 (edges)"
              },
              {
                "id": "b",
                "text": "To take 1, need 0; to take 2, need 1"
              },
              {
                "id": "c",
                "text": "1→0 and 2→1 (edges)"
              },
              {
                "id": "d",
                "text": "Both B and C"
              }
            ],
            "correct": "d",
            "explanation": "[a,b] means b must come before a. Edge from b to a, or \"b→a\".",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "A cycle in prerequisites means:",
            "options": [
              {
                "id": "a",
                "text": "Some courses have no prereqs"
              },
              {
                "id": "b",
                "text": "Some courses form a circular dependency"
              },
              {
                "id": "c",
                "text": "All courses are independent"
              },
              {
                "id": "d",
                "text": "There are too many courses"
              }
            ],
            "correct": "b",
            "explanation": "A→B→C→A means you can't start any of them.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "To detect cycles in directed graph:",
            "options": [
              {
                "id": "a",
                "text": "BFS only"
              },
              {
                "id": "b",
                "text": "DFS with visited states"
              },
              {
                "id": "c",
                "text": "Count edges"
              },
              {
                "id": "d",
                "text": "Sort nodes"
              }
            ],
            "correct": "b",
            "explanation": "DFS with \"visiting\" (in current path) and \"visited\" (fully processed) states.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "In cycle detection DFS, each node can be:",
            "options": [
              {
                "id": "a",
                "text": "Visited or unvisited (2 states)"
              },
              {
                "id": "b",
                "text": "Unvisited, visiting, visited (3 states)"
              },
              {
                "id": "c",
                "text": "Red, blue, green"
              },
              {
                "id": "d",
                "text": "Open, closed"
              }
            ],
            "correct": "b",
            "explanation": "Unvisited = not seen. Visiting = in current DFS path. Visited = fully processed.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "A cycle exists if during DFS we reach:",
            "options": [
              {
                "id": "a",
                "text": "An unvisited node"
              },
              {
                "id": "b",
                "text": "A visited (completed) node"
              },
              {
                "id": "c",
                "text": "A \"visiting\" node"
              },
              {
                "id": "d",
                "text": "The start node"
              }
            ],
            "correct": "c",
            "explanation": "Reaching a node that's currently in our path = we've found a back edge = cycle.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Using Kahn's algorithm (BFS topological sort):",
            "options": [
              {
                "id": "a",
                "text": "If queue empties before all nodes processed, there's a cycle"
              },
              {
                "id": "b",
                "text": "If queue empties, no cycle"
              },
              {
                "id": "c",
                "text": "Queue length indicates cycle length"
              },
              {
                "id": "d",
                "text": "BFS doesn't detect cycles"
              }
            ],
            "correct": "a",
            "explanation": "Kahn's removes nodes with 0 in-degree. If cycle exists, some nodes never reach 0 in-degree.",
            "conceptId": "topological-sort"
          }
        ],
        "oneLiner": "Cycle in directed graph = can't finish. DFS with 3 states (unvisited/visiting/visited): if we reach a 'visiting' node, cycle found. Or use Kahn's: if completed < numCourses, cycle exists.",
        "pattern": "Graph Traversal",
        "keyInsight": "If there's a cycle in prerequisites, you can't finish. No cycle = can finish.",
        "timeComplexity": "O(V + E)",
        "spaceComplexity": "O(V + E)",
        "triggerWords": [
          "course schedule",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n    # Build adjacency list\n    graph = {i: [] for i in range(numCourses)}\n    for course, prereq in prerequisites:\n        graph[course].append(prereq)\n    \n    # 0 = unvisited, 1 = visiting, 2 = visited\n    state = [0] * numCourses\n    \n    def dfs(course):\n        if state[course] == 1:  # Cycle detected\n            return False\n        if state[course] == 2:  # Already processed\n            return True\n        \n        state[course] = 1  # Mark visiting\n        \n        for prereq in graph[course]:\n            if not dfs(prereq):\n                return False\n        \n        state[course] = 2  # Mark visited\n        return True\n    \n    for course in range(numCourses):\n        if not dfs(course):\n            return False\n    \n    return True"
      },
      {
        "id": "05-course-schedule-ii",
        "slug": "course-schedule-ii",
        "title": "Course Schedule II",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "course-schedule-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\n\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
        "examples": [
          {
            "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
            "output": "[0,2,1,3] or [0,1,2,3]",
            "explanation": ""
          },
          {
            "input": "numCourses = 1, prerequisites = []",
            "output": "[0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A topological order of a DAG is:",
            "options": [
              {
                "id": "a",
                "text": "Alphabetical order"
              },
              {
                "id": "b",
                "text": "Order where all prerequisites come before dependents"
              },
              {
                "id": "c",
                "text": "Shortest path order"
              },
              {
                "id": "d",
                "text": "Random order"
              }
            ],
            "correct": "b",
            "explanation": "If A must come before B, A appears earlier in topological order.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "DFS topological sort uses:",
            "options": [
              {
                "id": "a",
                "text": "Pre-order traversal"
              },
              {
                "id": "b",
                "text": "Post-order traversal (then reverse)"
              },
              {
                "id": "c",
                "text": "In-order traversal"
              },
              {
                "id": "d",
                "text": "Level-order traversal"
              }
            ],
            "correct": "b",
            "explanation": "We add nodes to result AFTER processing all descendants. Reversing gives correct order.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "Kahn's algorithm processes nodes in order of:",
            "options": [
              {
                "id": "a",
                "text": "Value"
              },
              {
                "id": "b",
                "text": "In-degree (starting with 0 in-degree)"
              },
              {
                "id": "c",
                "text": "Out-degree"
              },
              {
                "id": "d",
                "text": "Random"
              }
            ],
            "correct": "b",
            "explanation": "Nodes with no prerequisites can be taken first. Remove them, update in-degrees, repeat.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "If there's a cycle:",
            "options": [
              {
                "id": "a",
                "text": "We get a partial ordering"
              },
              {
                "id": "b",
                "text": "We can't produce any valid ordering"
              },
              {
                "id": "c",
                "text": "We include cycle nodes at the end"
              },
              {
                "id": "d",
                "text": "We ignore cycle nodes"
              }
            ],
            "correct": "b",
            "explanation": "Cyclic dependencies have no valid ordering. Return empty.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "For prerequisites [[1,0],[2,0]], valid orderings include:",
            "options": [
              {
                "id": "a",
                "text": "[0,1,2] only"
              },
              {
                "id": "b",
                "text": "[0,2,1] only"
              },
              {
                "id": "c",
                "text": "Both [0,1,2] and [0,2,1]"
              },
              {
                "id": "d",
                "text": "[1,2,0]"
              }
            ],
            "correct": "c",
            "explanation": "0 must come first, but 1 and 2 can be in either order.",
            "conceptId": "topological-sort"
          }
        ],
        "oneLiner": "Topological sort: DFS post-order (reversed) or Kahn's (process 0 in-degree first). If can't include all nodes, cycle exists, return empty.",
        "pattern": "Graph Traversal",
        "keyInsight": "Topological sort: order nodes so all edges go forward.",
        "timeComplexity": "O(V + E)",
        "spaceComplexity": "O(V + E)",
        "triggerWords": [
          "course schedule ii",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findOrder(numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n    graph = {i: [] for i in range(numCourses)}\n    for course, prereq in prerequisites:\n        graph[course].append(prereq)\n    \n    result = []\n    state = [0] * numCourses  # 0=unvisited, 1=visiting, 2=visited\n    \n    def dfs(course):\n        if state[course] == 1:  # Cycle\n            return False\n        if state[course] == 2:  # Already added\n            return True\n        \n        state[course] = 1\n        \n        for prereq in graph[course]:\n            if not dfs(prereq):\n                return False\n        \n        state[course] = 2\n        result.append(course)  # Post-order\n        return True\n    \n    for course in range(numCourses):\n        if not dfs(course):\n            return []\n    \n    return result  # Already in correct order (prereqs first)"
      },
      {
        "id": "06-rotting-oranges",
        "slug": "rotting-oranges",
        "title": "Rotting Oranges",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "rotting-oranges"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an `m x n` grid where each cell can have one of three values:\n- `0` representing an empty cell,\n- `1` representing a fresh orange, or\n- `2` representing a rotten orange.\n\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\n\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return `-1`.",
        "examples": [
          {
            "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
            "output": "4",
            "explanation": ""
          },
          {
            "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
            "output": "-1",
            "explanation": "Orange at (2,0) is isolated."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "BFS is preferred because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "It naturally processes in \"waves\" (levels)"
              },
              {
                "id": "c",
                "text": "DFS can't handle grids"
              },
              {
                "id": "d",
                "text": "BFS uses less memory"
              }
            ],
            "correct": "b",
            "explanation": "Each BFS level = 1 minute. All oranges at distance k rot at minute k.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We start BFS from:",
            "options": [
              {
                "id": "a",
                "text": "Top-left corner"
              },
              {
                "id": "b",
                "text": "All fresh oranges"
              },
              {
                "id": "c",
                "text": "All rotten oranges"
              },
              {
                "id": "d",
                "text": "Random cells"
              }
            ],
            "correct": "c",
            "explanation": "Rot spreads FROM rotten oranges. They're our sources.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Multi-source BFS means:",
            "options": [
              {
                "id": "a",
                "text": "Multiple separate BFS runs"
              },
              {
                "id": "b",
                "text": "All sources start in queue at once"
              },
              {
                "id": "c",
                "text": "Sources take turns"
              },
              {
                "id": "d",
                "text": "Only one source at a time"
              }
            ],
            "correct": "b",
            "explanation": "All rotten oranges start in queue at time 0. BFS processes them together.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We track time/minutes by:",
            "options": [
              {
                "id": "a",
                "text": "A separate timer variable"
              },
              {
                "id": "b",
                "text": "Processing level by level"
              },
              {
                "id": "c",
                "text": "Counting total pops"
              },
              {
                "id": "d",
                "text": "Random increments"
              }
            ],
            "correct": "b",
            "explanation": "One level = one minute. After processing all oranges at time t, move to time t+1.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We return -1 when:",
            "options": [
              {
                "id": "a",
                "text": "Grid is empty"
              },
              {
                "id": "b",
                "text": "There are no rotten oranges"
              },
              {
                "id": "c",
                "text": "Fresh oranges remain after BFS"
              },
              {
                "id": "d",
                "text": "Grid has zeros"
              }
            ],
            "correct": "c",
            "explanation": "If any fresh orange is unreachable from rotten ones, it stays fresh forever.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Multi-source BFS: start from all rotten oranges, spread level by level. Each level = 1 minute. If fresh remain after BFS, return -1.",
        "pattern": "Graph Traversal",
        "keyInsight": "Start BFS from ALL rotten oranges simultaneously. Each wave = 1 minute.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m × n)",
        "triggerWords": [
          "rotting oranges",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import deque\n\ndef orangesRotting(grid: List[List[int]]) -> int:\n    rows, cols = len(grid), len(grid[0])\n    queue = deque()\n    fresh = 0\n    \n    # Find all rotten oranges and count fresh\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 2:\n                queue.append((r, c))\n            elif grid[r][c] == 1:\n                fresh += 1\n    \n    minutes = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    while queue and fresh > 0:\n        minutes += 1\n        for _ in range(len(queue)):  # Process one level\n            r, c = queue.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    queue.append((nr, nc))\n    \n    return minutes if fresh == 0 else -1"
      },
      {
        "id": "07-surrounded-regions",
        "slug": "surrounded-regions",
        "title": "Surrounded Regions",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "surrounded-regions"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` matrix `board` containing `'X'` and `'O'`, capture all regions that are 4-directionally surrounded by `'X'`.\n\nA region is captured by flipping all `'O'`s into `'X'`s in that surrounded region.",
        "examples": [
          {
            "input": "board = [[\"X\",\"X\",\"X\",\"X\"],",
            "output": "[[\"X\",\"X\",\"X\",\"X\"],",
            "explanation": "'O' at (3,1) is not surrounded (touches edge)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "An 'O' is surrounded if:",
            "options": [
              {
                "id": "a",
                "text": "It's not on the boundary"
              },
              {
                "id": "b",
                "text": "It's not connected to any boundary 'O'"
              },
              {
                "id": "c",
                "text": "It has 4 'X' neighbors"
              },
              {
                "id": "d",
                "text": "It's alone"
              }
            ],
            "correct": "b",
            "explanation": "If connected to boundary (directly or through other 'O's), it reaches the edge = not surrounded.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Checking from each 'O' whether it reaches boundary:",
            "options": [
              {
                "id": "a",
                "text": "Works perfectly"
              },
              {
                "id": "b",
                "text": "Is inefficient — O(m×n) per 'O'"
              },
              {
                "id": "c",
                "text": "Doesn't work"
              },
              {
                "id": "d",
                "text": "Is optimal"
              }
            ],
            "correct": "b",
            "explanation": "Each 'O' might need to traverse to check. Better to mark from boundary.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Instead of finding surrounded, we:",
            "options": [
              {
                "id": "a",
                "text": "Find all 'O's"
              },
              {
                "id": "b",
                "text": "Find 'O's connected to boundary (safe)"
              },
              {
                "id": "c",
                "text": "Count 'X's"
              },
              {
                "id": "d",
                "text": "Random selection"
              }
            ],
            "correct": "b",
            "explanation": "Mark safe 'O's first, then flip the rest.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We start DFS/BFS from:",
            "options": [
              {
                "id": "a",
                "text": "All 'O's"
              },
              {
                "id": "b",
                "text": "Corner 'O's only"
              },
              {
                "id": "c",
                "text": "All boundary 'O's"
              },
              {
                "id": "d",
                "text": "Center"
              }
            ],
            "correct": "c",
            "explanation": "Only 'O's on the four edges. Any 'O' connected to them is safe.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Reverse: DFS from boundary 'O's to mark safe. Then flip all remaining 'O' to 'X'. Restore safe back to 'O'.",
        "pattern": "Graph Traversal",
        "keyInsight": "Reverse thinking: mark 'O's connected to boundary as \"safe,\" then flip everything else.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m × n)",
        "triggerWords": [
          "surrounded regions",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def solve(board: List[List[str]]) -> None:\n    if not board:\n        return\n    \n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if board[r][c] != 'O':\n            return\n        \n        board[r][c] = 'T'  # Mark as safe (temporary)\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    # Mark all 'O's connected to boundary\n    for r in range(rows):\n        dfs(r, 0)\n        dfs(r, cols - 1)\n    for c in range(cols):\n        dfs(0, c)\n        dfs(rows - 1, c)\n    \n    # Flip remaining 'O' to 'X', restore 'T' to 'O'\n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == 'O':\n                board[r][c] = 'X'\n            elif board[r][c] == 'T':\n                board[r][c] = 'O'"
      },
      {
        "id": "08-graph-valid-tree",
        "slug": "graph-valid-tree",
        "title": "Graph Valid Tree",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "graph-valid-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given an integer `n` and a list of edges where `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in the graph.\n\nReturn `true` if the edges of the given graph make up a valid tree, or `false` otherwise.",
        "examples": [
          {
            "input": "n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]",
            "output": "false (has cycle: 1-2-3-1)",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A tree with n nodes has exactly:",
            "options": [
              {
                "id": "a",
                "text": "n edges"
              },
              {
                "id": "b",
                "text": "n - 1 edges"
              },
              {
                "id": "c",
                "text": "n + 1 edges"
              },
              {
                "id": "d",
                "text": "2n edges"
              }
            ],
            "correct": "b",
            "explanation": "Tree is minimally connected. n-1 edges for n nodes.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "If len(edges) != n - 1:",
            "options": [
              {
                "id": "a",
                "text": "It could still be a tree"
              },
              {
                "id": "b",
                "text": "It's definitely not a tree"
              },
              {
                "id": "c",
                "text": "Need more checks"
              },
              {
                "id": "d",
                "text": "It's always a tree"
              }
            ],
            "correct": "b",
            "explanation": "Too few edges = disconnected. Too many = cycle.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "If len(edges) == n - 1:",
            "options": [
              {
                "id": "a",
                "text": "It's always a tree"
              },
              {
                "id": "b",
                "text": "It's a tree iff connected"
              },
              {
                "id": "c",
                "text": "It could have cycles"
              },
              {
                "id": "d",
                "text": "It's always connected"
              }
            ],
            "correct": "b",
            "explanation": "n-1 edges and connected → no cycles (exactly enough edges). n-1 edges and disconnected → some component has extra edges (cycle).",
            "conceptId": "union-find"
          },
          {
            "type": "mcq",
            "question": "To check if all nodes are connected:",
            "options": [
              {
                "id": "a",
                "text": "DFS/BFS from any node, count visited"
              },
              {
                "id": "b",
                "text": "Count edges"
              },
              {
                "id": "c",
                "text": "Check degrees"
              },
              {
                "id": "d",
                "text": "Sort nodes"
              }
            ],
            "correct": "a",
            "explanation": "If DFS visits all n nodes, graph is connected.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Using Union-Find to check valid tree:",
            "options": [
              {
                "id": "a",
                "text": "Union all edges, check if n-1 merges and no cycles"
              },
              {
                "id": "b",
                "text": "If any union fails (same parent), there's a cycle"
              },
              {
                "id": "c",
                "text": "Count components at end = 1"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Union-Find detects cycles (union nodes already connected) and counts components.",
            "conceptId": "union-find"
          }
        ],
        "oneLiner": "Valid tree: exactly n-1 edges AND connected. Check edge count first, then verify all nodes reachable via DFS/BFS.",
        "pattern": "Graph Traversal",
        "keyInsight": "A tree has exactly n-1 edges, is connected, and has no cycles.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "graph valid tree",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def validTree(n: int, edges: List[List[int]]) -> bool:\n    # Tree must have exactly n-1 edges\n    if len(edges) != n - 1:\n        return False\n    \n    # Build adjacency list\n    graph = {i: [] for i in range(n)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Check if all nodes are connected (DFS from node 0)\n    visited = set()\n    \n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n    \n    dfs(0)\n    \n    return len(visited) == n"
      }
    ],
    "advanced-graphs": [
      {
        "id": "01-min-cost-to-connect-all-points",
        "slug": "min-cost-to-connect-all-points",
        "title": "Min Cost to Connect All Points",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "min-cost-to-connect-all-points"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the manhattan distance between them: `|xi - xj| + |yi - yj|`.\n\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.",
        "examples": [
          {
            "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
            "output": "20",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A Minimum Spanning Tree:",
            "options": [
              {
                "id": "a",
                "text": "Contains all nodes with minimum edges (n-1)"
              },
              {
                "id": "b",
                "text": "Has minimum total edge weight"
              },
              {
                "id": "c",
                "text": "Connects all nodes without cycles"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "MST has n-1 edges, minimum total weight, and no cycles.",
            "conceptId": "union-find"
          },
          {
            "type": "mcq",
            "question": "For dense graphs (many edges), prefer:",
            "options": [
              {
                "id": "a",
                "text": "Prim's with min-heap"
              },
              {
                "id": "b",
                "text": "Kruskal's with sorting"
              },
              {
                "id": "c",
                "text": "Either is same"
              },
              {
                "id": "d",
                "text": "Neither works"
              }
            ],
            "correct": "a",
            "explanation": "Kruskal's sorts all edges O(E log E). Prim's processes O(V) nodes with heap.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "MST problem: Prim's (grow tree greedily from one node) or Kruskal's (add smallest edges that don't form cycles). Both give minimum total edge weight.",
        "pattern": "Advanced Graphs",
        "keyInsight": "This is classic MST: connect all nodes with minimum total edge weight.",
        "timeComplexity": "O(n² log n)",
        "spaceComplexity": "O(n²)",
        "triggerWords": [
          "min cost to connect all points",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef minCostConnectPoints(points: List[List[int]]) -> int:\n    n = len(points)\n    if n <= 1:\n        return 0\n    \n    # Prim's algorithm\n    visited = set()\n    min_heap = [(0, 0)]  # (cost, point_index)\n    total_cost = 0\n    \n    while len(visited) < n:\n        cost, i = heapq.heappop(min_heap)\n        \n        if i in visited:\n            continue\n        \n        visited.add(i)\n        total_cost += cost\n        \n        # Add edges to all unvisited points\n        for j in range(n):\n            if j not in visited:\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(min_heap, (dist, j))\n    \n    return total_cost"
      },
      {
        "id": "02-network-delay-time",
        "slug": "network-delay-time",
        "title": "Network Delay Time",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "network-delay-time"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return the minimum time it takes for all the `n` nodes to receive the signal. If it is impossible for all the `n` nodes to receive the signal, return `-1`.",
        "examples": [
          {
            "input": "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2",
            "output": "2",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Dijkstra's is used because:",
            "options": [
              {
                "id": "a",
                "text": "We need shortest paths from a single source"
              },
              {
                "id": "b",
                "text": "Edge weights are non-negative"
              },
              {
                "id": "c",
                "text": "We need paths to ALL nodes"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Dijkstra's finds shortest paths from one source to all nodes with non-negative weights.",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "We maintain for each node:",
            "options": [
              {
                "id": "a",
                "text": "Shortest distance from source"
              },
              {
                "id": "b",
                "text": "Whether it's been finalized"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Number of paths"
              }
            ],
            "correct": "c",
            "explanation": "Signal reaches all when the farthest node receives it.",
            "conceptId": "dijkstra"
          }
        ],
        "oneLiner": "Dijkstra from source k to find shortest paths to all nodes. Answer = max shortest path. If any node unreachable, return -1.",
        "pattern": "Advanced Graphs",
        "keyInsight": "Dijkstra's algorithm: find shortest path from source to all nodes.",
        "timeComplexity": "O((V + E) log V)",
        "spaceComplexity": "O(V + E)",
        "triggerWords": [
          "network delay time",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\nfrom collections import defaultdict\n\ndef networkDelayTime(times: List[List[int]], n: int, k: int) -> int:\n    # Build adjacency list\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    # Dijkstra's algorithm\n    min_heap = [(0, k)]  # (time, node)\n    dist = {}\n    \n    while min_heap:\n        time, node = heapq.heappop(min_heap)\n        \n        if node in dist:\n            continue\n        \n        dist[node] = time\n        \n        for neighbor, weight in graph[node]:\n            if neighbor not in dist:\n                heapq.heappush(min_heap, (time + weight, neighbor))\n    \n    # Check if all nodes reached\n    if len(dist) == n:\n        return max(dist.values())\n    return -1"
      },
      {
        "id": "03-swim-in-rising-water",
        "slug": "swim-in-rising-water",
        "title": "Swim in Rising Water",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "swim-in-rising-water"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.\n\nThe rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares is at most `t`.\n\nReturn the least time until you can reach the bottom right square `(n - 1, n - 1)` starting from the top left square `(0, 0)`.",
        "examples": [
          {
            "input": "grid = [[0,2],[1,3]]",
            "output": "3",
            "explanation": "At time 3, we can swim anywhere."
          },
          {
            "input": "grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]",
            "output": "16",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We can traverse a cell when:",
            "options": [
              {
                "id": "a",
                "text": "Water level >= our current elevation"
              },
              {
                "id": "b",
                "text": "Water level >= that cell's elevation"
              },
              {
                "id": "c",
                "text": "Water level >= sum of elevations"
              },
              {
                "id": "d",
                "text": "Water level >= average elevation"
              }
            ],
            "correct": "b",
            "explanation": "We can enter a cell only when water covers it.",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "The minimum time to reach destination:",
            "options": [
              {
                "id": "a",
                "text": "Sum of all elevations on path"
              },
              {
                "id": "b",
                "text": "Maximum elevation on any path"
              },
              {
                "id": "c",
                "text": "Minimum of (maximum elevation) across all paths"
              },
              {
                "id": "d",
                "text": "Shortest path length"
              }
            ],
            "correct": "c",
            "explanation": "We need water to cover the highest point on our path. We want the path with smallest \"highest point\".",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "For minimax path, use:",
            "options": [
              {
                "id": "a",
                "text": "BFS (all edges equal)"
              },
              {
                "id": "b",
                "text": "DFS (explore all paths)"
              },
              {
                "id": "c",
                "text": "Dijkstra with max instead of sum"
              },
              {
                "id": "d",
                "text": "Floyd-Warshall"
              }
            ],
            "correct": "c",
            "explanation": "Dijkstra's greedy approach works - always expand the cell with minimum \"max so far\".",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "The min-heap should store:",
            "options": [
              {
                "id": "a",
                "text": "(distance, position)"
              },
              {
                "id": "b",
                "text": "(max_elevation_to_reach, position)"
              },
              {
                "id": "c",
                "text": "(cell_elevation, position)"
              },
              {
                "id": "d",
                "text": "(path_length, position)"
              }
            ],
            "correct": "b",
            "explanation": "We prioritize by the maximum elevation needed to reach each cell.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "When moving to neighbor, the new \"cost\" is:",
            "options": [
              {
                "id": "a",
                "text": "current_cost + neighbor_elevation"
              },
              {
                "id": "b",
                "text": "max(current_cost, neighbor_elevation)"
              },
              {
                "id": "c",
                "text": "min(current_cost, neighbor_elevation)"
              },
              {
                "id": "d",
                "text": "neighbor_elevation only"
              }
            ],
            "correct": "b",
            "explanation": "The cost to reach neighbor is the max of (cost to reach current, neighbor's elevation).",
            "conceptId": "dijkstra"
          }
        ],
        "oneLiner": "Minimax path problem: Dijkstra's where we minimize the maximum elevation along the path. Priority = max elevation needed to reach each cell.",
        "pattern": "Advanced Graphs",
        "keyInsight": "This is \"minimax path\" - minimize the maximum edge weight. Use modified Dijkstra's.",
        "timeComplexity": "O(n² log n)",
        "spaceComplexity": "O(n²)",
        "triggerWords": [
          "swim in rising water",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef swimInWater(grid: List[List[int]]) -> int:\n    n = len(grid)\n    visited = set()\n    min_heap = [(grid[0][0], 0, 0)]  # (max_elevation, row, col)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while min_heap:\n        max_elev, r, c = heapq.heappop(min_heap)\n        \n        if (r, c) in visited:\n            continue\n        \n        visited.add((r, c))\n        \n        # Reached destination\n        if r == n - 1 and c == n - 1:\n            return max_elev\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited:\n                # New cost is max of current max and neighbor's elevation\n                new_max = max(max_elev, grid[nr][nc])\n                heapq.heappush(min_heap, (new_max, nr, nc))\n    \n    return -1"
      },
      {
        "id": "04-alien-dictionary",
        "slug": "alien-dictionary",
        "title": "Alien Dictionary",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "alien-dictionary"
        ],
        "estimatedTime": 5,
        "problemStatement": "There is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you.\n\nYou are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are sorted lexicographically by the rules of this new language.\n\nReturn a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return `\"\"`. If there are multiple solutions, return any of them.",
        "examples": [
          {
            "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
            "output": "\"wertf\"",
            "explanation": ""
          },
          {
            "input": "words = [\"z\",\"x\"]",
            "output": "\"zx\"",
            "explanation": ""
          },
          {
            "input": "words = [\"z\",\"x\",\"z\"]",
            "output": "\"\" (invalid - z can't come before and after x)",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "From sorted words [\"abc\", \"abd\"]:",
            "options": [
              {
                "id": "a",
                "text": "a < b < c < d"
              },
              {
                "id": "b",
                "text": "c < d (only)"
              },
              {
                "id": "c",
                "text": "a = a, b = b, c < d"
              },
              {
                "id": "d",
                "text": "Nothing"
              }
            ],
            "correct": "b",
            "explanation": "First difference is at position 2: 'c' vs 'd'. So c comes before d.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "For words [\"ab\", \"a\"]:",
            "options": [
              {
                "id": "a",
                "text": "b comes first"
              },
              {
                "id": "b",
                "text": "This is invalid ordering"
              },
              {
                "id": "c",
                "text": "a comes first"
              },
              {
                "id": "d",
                "text": "No constraint"
              }
            ],
            "correct": "b",
            "explanation": "A prefix (\"a\") should come BEFORE a longer word (\"ab\"). This violates that.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "From n sorted words, we get:",
            "options": [
              {
                "id": "a",
                "text": "n constraints"
              },
              {
                "id": "b",
                "text": "At most n-1 constraints"
              },
              {
                "id": "c",
                "text": "n² constraints"
              },
              {
                "id": "d",
                "text": "Exactly 26 constraints"
              }
            ],
            "correct": "b",
            "explanation": "We compare adjacent pairs. n words = n-1 pairs = at most n-1 constraints.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "We have edges like (a→b means a before b). Next:",
            "options": [
              {
                "id": "a",
                "text": "Sort alphabetically"
              },
              {
                "id": "b",
                "text": "Topological sort"
              },
              {
                "id": "c",
                "text": "BFS"
              },
              {
                "id": "d",
                "text": "Binary search"
              }
            ],
            "correct": "b",
            "explanation": "Constraints form a directed graph. Topological sort gives valid ordering.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "No valid ordering exists when:",
            "options": [
              {
                "id": "a",
                "text": "Graph has a cycle"
              },
              {
                "id": "b",
                "text": "Graph is disconnected"
              },
              {
                "id": "c",
                "text": "Multiple valid orderings"
              },
              {
                "id": "d",
                "text": "All characters appear"
              }
            ],
            "correct": "a",
            "explanation": "Cycle means a < b < ... < a, which is impossible.",
            "conceptId": "topological-sort"
          }
        ],
        "oneLiner": "Compare adjacent words to extract 'char A before char B' edges. Build graph. Topological sort. Cycle = invalid.",
        "pattern": "Advanced Graphs",
        "keyInsight": "Compare adjacent words to extract \"char A comes before char B\" relationships. Then topological sort.",
        "timeComplexity": "O(C)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "alien dictionary",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import defaultdict, deque\n\ndef alienOrder(words: List[str]) -> str:\n    # Build graph\n    graph = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    \n    # Compare adjacent words\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        min_len = min(len(w1), len(w2))\n        \n        # Check for invalid case: prefix comes after longer word\n        if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n            return \"\"\n        \n        # Find first difference\n        for j in range(min_len):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    in_degree[w2[j]] += 1\n                break\n    \n    # Topological sort (Kahn's algorithm)\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    result = []\n    \n    while queue:\n        c = queue.popleft()\n        result.append(c)\n        for neighbor in graph[c]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check for cycle\n    if len(result) != len(in_degree):\n        return \"\"\n    \n    return \"\".join(result)"
      },
      {
        "id": "05-cheapest-flights-within-k-stops",
        "slug": "cheapest-flights-within-k-stops",
        "title": "Cheapest Flights Within K Stops",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "cheapest-flights-within-k-stops"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return the cheapest price from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`.",
        "examples": [
          {
            "input": "n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1",
            "output": "700",
            "explanation": "0 → 1 → 3 with 1 stop costs 700."
          },
          {
            "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1",
            "output": "200",
            "explanation": "0 → 1 → 2 with 1 stop costs 200."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Standard Dijkstra fails here because:",
            "options": [
              {
                "id": "a",
                "text": "Negative edges"
              },
              {
                "id": "b",
                "text": "It ignores the stop constraint"
              },
              {
                "id": "c",
                "text": "Multiple destinations"
              },
              {
                "id": "d",
                "text": "Undirected graph"
              }
            ],
            "correct": "b",
            "explanation": "Dijkstra prunes paths greedily. A path with more stops but lower cost might be optimal.",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "At each node, we need to know:",
            "options": [
              {
                "id": "a",
                "text": "Just the minimum cost"
              },
              {
                "id": "b",
                "text": "Cost AND number of stops"
              },
              {
                "id": "c",
                "text": "Just the number of stops"
              },
              {
                "id": "d",
                "text": "Previous node only"
              }
            ],
            "correct": "b",
            "explanation": "A node might be reached cheaply with many stops, or expensively with few stops. Both matter.",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "Bellman-Ford after k+1 iterations gives:",
            "options": [
              {
                "id": "a",
                "text": "Shortest path of any length"
              },
              {
                "id": "b",
                "text": "Shortest path using at most k+1 edges"
              },
              {
                "id": "c",
                "text": "Shortest path using exactly k+1 edges"
              },
              {
                "id": "d",
                "text": "Longest path"
              }
            ],
            "correct": "b",
            "explanation": "Each iteration extends paths by one edge. k+1 iterations = paths of at most k+1 edges.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For modified Dijkstra, heap stores:",
            "options": [
              {
                "id": "a",
                "text": "(cost, node)"
              },
              {
                "id": "b",
                "text": "(cost, node, stops)"
              },
              {
                "id": "c",
                "text": "(stops, node)"
              },
              {
                "id": "d",
                "text": "(node, cost)"
              }
            ],
            "correct": "b",
            "explanation": "We need to track stops to enforce the constraint.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Skip processing if:",
            "options": [
              {
                "id": "a",
                "text": "Cost is higher than current best"
              },
              {
                "id": "b",
                "text": "Stops exceed k"
              },
              {
                "id": "c",
                "text": "Node already visited"
              },
              {
                "id": "d",
                "text": "Node is destination"
              }
            ],
            "correct": "b",
            "explanation": "We can revisit nodes with fewer stops. Only skip if we've exceeded stop limit.",
            "conceptId": "dijkstra"
          }
        ],
        "oneLiner": "Bellman-Ford with k+1 iterations finds shortest path using at most k+1 edges. Each iteration extends paths by one hop.",
        "pattern": "Advanced Graphs",
        "keyInsight": "Bellman-Ford for k+1 iterations OR modified Dijkstra tracking stops.",
        "timeComplexity": "O(k × E)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "cheapest flights within k stops",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findCheapestPrice(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    # Bellman-Ford with k+1 iterations\n    # prices[i] = min cost to reach city i\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    # k stops means k+1 edges\n    for _ in range(k + 1):\n        # Use copy to avoid using updated values in same iteration\n        temp = prices.copy()\n        \n        for u, v, cost in flights:\n            if prices[u] != float('inf'):\n                temp[v] = min(temp[v], prices[u] + cost)\n        \n        prices = temp\n    \n    return prices[dst] if prices[dst] != float('inf') else -1"
      },
      {
        "id": "06-reconstruct-itinerary",
        "slug": "reconstruct-itinerary",
        "title": "Reconstruct Itinerary",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "reconstruct-itinerary"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a list of airline `tickets` where `tickets[i] = [fromi, toi]` represent the departure and arrival airports of one flight. Reconstruct the itinerary in order and return it.\n\nAll the tickets belong to a man who departs from `\"JFK\"`, thus, the itinerary must begin with `\"JFK\"`. If there are multiple valid itineraries, return the itinerary that has the smallest lexical order when read as a single string.\n\nYou must use all the tickets once and only once.",
        "examples": [
          {
            "input": "tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
            "output": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]",
            "explanation": ""
          },
          {
            "input": "tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]",
            "output": "[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]",
            "explanation": "Another valid itinerary is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it's lexicographically larger."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Using every ticket (edge) exactly once is:",
            "options": [
              {
                "id": "a",
                "text": "Hamiltonian path (every node once)"
              },
              {
                "id": "b",
                "text": "Eulerian path (every edge once)"
              },
              {
                "id": "c",
                "text": "Shortest path"
              },
              {
                "id": "d",
                "text": "Minimum spanning tree"
              }
            ],
            "correct": "b",
            "explanation": "We must traverse every edge (ticket) exactly once.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Simple DFS from JFK might fail because:",
            "options": [
              {
                "id": "a",
                "text": "Can get stuck before using all tickets"
              },
              {
                "id": "b",
                "text": "Too slow"
              },
              {
                "id": "c",
                "text": "Can't handle cycles"
              },
              {
                "id": "d",
                "text": "Wrong starting point"
              }
            ],
            "correct": "a",
            "explanation": "Greedy DFS might take a path that doesn't use all edges. Need to backtrack or use Hierholzer's.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Hierholzer's algorithm:",
            "options": [
              {
                "id": "a",
                "text": "Pre-order traversal"
              },
              {
                "id": "b",
                "text": "Post-order collection + reverse"
              },
              {
                "id": "c",
                "text": "Level-order traversal"
              },
              {
                "id": "d",
                "text": "In-order traversal"
              }
            ],
            "correct": "b",
            "explanation": "Add node to path AFTER visiting all its neighbors. Reverse at end. Handles dead-ends correctly.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "To ensure smallest lexical order:",
            "options": [
              {
                "id": "a",
                "text": "Sort result at end"
              },
              {
                "id": "b",
                "text": "Visit neighbors in sorted order"
              },
              {
                "id": "c",
                "text": "Random order"
              },
              {
                "id": "d",
                "text": "Reverse alphabetical"
              }
            ],
            "correct": "b",
            "explanation": "Process neighbors in sorted order, so we always try the lexicographically smaller option first.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Adding to result after all neighbors are processed:",
            "options": [
              {
                "id": "a",
                "text": "Puts dead-ends first in reversed result"
              },
              {
                "id": "b",
                "text": "Ensures we use all edges before finalizing"
              },
              {
                "id": "c",
                "text": "Is just a coincidence"
              },
              {
                "id": "d",
                "text": "Only works for trees"
              }
            ],
            "correct": "b",
            "explanation": "A node only gets added when all its outgoing edges are used. Dead-ends added first, start added last, then reverse.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Eulerian path with Hierholzer's: DFS with post-order collection (add node after visiting all edges). Process neighbors in sorted order. Reverse result at end.",
        "pattern": "Advanced Graphs",
        "keyInsight": "Hierholzer's algorithm: DFS with post-order collection. Visit neighbors in sorted order for lexicographic result.",
        "timeComplexity": "O(E log E)",
        "spaceComplexity": "O(E)",
        "triggerWords": [
          "reconstruct itinerary",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import defaultdict\n\ndef findItinerary(tickets: List[List[str]]) -> List[str]:\n    # Build adjacency list with sorted destinations\n    graph = defaultdict(list)\n    for src, dst in sorted(tickets, reverse=True):\n        graph[src].append(dst)\n    \n    result = []\n    \n    def dfs(airport):\n        while graph[airport]:\n            # Pop from end (smallest lexicographically due to reverse sort)\n            next_airport = graph[airport].pop()\n            dfs(next_airport)\n        result.append(airport)  # Post-order\n    \n    dfs(\"JFK\")\n    \n    return result[::-1]  # Reverse for correct order"
      }
    ],
    "1d-dp": [
      {
        "id": "01-climbing-stairs",
        "slug": "climbing-stairs",
        "title": "Climbing Stairs",
        "category": "1d-dp",
        "difficulty": "easy",
        "tags": [
          "1d-dp",
          "climbing-stairs"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
        "examples": [
          {
            "input": "n = 2",
            "output": "2",
            "explanation": "(1+1) or (2)"
          },
          {
            "input": "n = 3",
            "output": "3",
            "explanation": "(1+1+1), (1+2), (2+1)"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To reach step n, the last move was:",
            "options": [
              {
                "id": "a",
                "text": "Always 1 step"
              },
              {
                "id": "b",
                "text": "Always 2 steps"
              },
              {
                "id": "c",
                "text": "Either 1 or 2 steps"
              },
              {
                "id": "d",
                "text": "Depends on n"
              }
            ],
            "correct": "c",
            "explanation": "From any step, you can take 1 or 2 steps. So you arrived from n-1 or n-2.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "ways(n) equals:",
            "options": [
              {
                "id": "a",
                "text": "ways(n-1) * 2"
              },
              {
                "id": "b",
                "text": "ways(n-1) + ways(n-2)"
              },
              {
                "id": "c",
                "text": "ways(n-1) * ways(n-2)"
              },
              {
                "id": "d",
                "text": "ways(n/2) * 2"
              }
            ],
            "correct": "b",
            "explanation": "Ways from n-1 (then take 1 step) PLUS ways from n-2 (then take 2 steps).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Base cases are:",
            "options": [
              {
                "id": "a",
                "text": "ways(0) = 0, ways(1) = 1"
              },
              {
                "id": "b",
                "text": "ways(0) = 1, ways(1) = 1"
              },
              {
                "id": "c",
                "text": "ways(1) = 1, ways(2) = 1"
              },
              {
                "id": "d",
                "text": "ways(1) = 2, ways(2) = 2"
              }
            ],
            "correct": "b",
            "explanation": "ways(1)=1 (one way: take 1 step). ways(0)=1 (one way: do nothing - you're there).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "The sequence 1, 1, 2, 3, 5, 8, 13... is:",
            "options": [
              {
                "id": "a",
                "text": "Powers of 2"
              },
              {
                "id": "b",
                "text": "Fibonacci sequence"
              },
              {
                "id": "c",
                "text": "Triangular numbers"
              },
              {
                "id": "d",
                "text": "Primes"
              }
            ],
            "correct": "b",
            "explanation": "Each term is sum of previous two. Classic Fibonacci.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Instead of array, we only need:",
            "options": [
              {
                "id": "a",
                "text": "One variable"
              },
              {
                "id": "b",
                "text": "Two variables"
              },
              {
                "id": "c",
                "text": "Three variables"
              },
              {
                "id": "d",
                "text": "Full array"
              }
            ],
            "correct": "b",
            "explanation": "Only need previous two values to compute current.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "To reach step n, add ways to reach n-1 and n-2. It's Fibonacci.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "To reach step n, you either came from step n-1 (took 1 step) or step n-2 (took 2 steps).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "climbing stairs",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def climbStairs(n: int) -> int:\n    if n <= 2:\n        return n\n    \n    # Only need previous two values\n    prev2, prev1 = 1, 2\n    \n    for i in range(3, n + 1):\n        curr = prev1 + prev2\n        prev2 = prev1\n        prev1 = curr\n    \n    return prev1"
      },
      {
        "id": "02-min-cost-climbing-stairs",
        "slug": "min-cost-climbing-stairs",
        "title": "Min Cost Climbing Stairs",
        "category": "1d-dp",
        "difficulty": "easy",
        "tags": [
          "1d-dp",
          "min-cost-climbing-stairs"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index `0`, or the step with index `1`.\n\nReturn the minimum cost to reach the top of the floor.",
        "examples": [
          {
            "input": "cost = [10,15,20]",
            "output": "15",
            "explanation": "Start at index 1, pay 15, climb two steps to reach the top."
          },
          {
            "input": "cost = [1,100,1,1,1,100,1,1,100,1]",
            "output": "6",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For cost = [10, 15, 20], the top is:",
            "options": [
              {
                "id": "a",
                "text": "Index 2"
              },
              {
                "id": "b",
                "text": "Beyond index 2 (index 3)"
              },
              {
                "id": "c",
                "text": "Index 0"
              },
              {
                "id": "d",
                "text": "Sum of all costs"
              }
            ],
            "correct": "b",
            "explanation": "We need to go PAST the last step. Top is at index n (one beyond array).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "We pay cost[i] when:",
            "options": [
              {
                "id": "a",
                "text": "We arrive at step i"
              },
              {
                "id": "b",
                "text": "We leave step i"
              },
              {
                "id": "c",
                "text": "We look at step i"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "b",
            "explanation": "Pay the cost of the step you're standing on to climb away from it.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Minimum cost to reach step i:",
            "options": [
              {
                "id": "a",
                "text": "min(dp[i-1], dp[i-2])"
              },
              {
                "id": "b",
                "text": "dp[i-1] + dp[i-2]"
              },
              {
                "id": "c",
                "text": "cost[i-1] + cost[i-2]"
              },
              {
                "id": "d",
                "text": "min(cost[i-1], cost[i-2])"
              }
            ],
            "correct": "a",
            "explanation": "Come from i-1 (paying cost[i-1]) or from i-2 (paying cost[i-2]). Take minimum.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0] and dp[1] are:",
            "options": [
              {
                "id": "a",
                "text": "cost[0] and cost[1]"
              },
              {
                "id": "b",
                "text": "0 and 0"
              },
              {
                "id": "c",
                "text": "0 and cost[0]"
              },
              {
                "id": "d",
                "text": "cost[0] and 0"
              }
            ],
            "correct": "b",
            "explanation": "We can START at step 0 or 1 for free. We pay when we LEAVE, not arrive.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "The answer is:",
            "options": [
              {
                "id": "a",
                "text": "dp[n-1]"
              },
              {
                "id": "b",
                "text": "dp[n]"
              },
              {
                "id": "c",
                "text": "min(dp[n-1], dp[n])"
              },
              {
                "id": "d",
                "text": "dp[n] + cost[n-1]"
              }
            ],
            "correct": "b",
            "explanation": "We want to reach the \"top\" which is position n (beyond the array).",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "dp[i] = min cost to reach step i. dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]). Answer is dp[n].",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "dp[i] = min cost to reach step i. To reach step i, pay either cost[i-1] from step i-1 or cost[i-2] from step i-2.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "min cost climbing stairs",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minCostClimbingStairs(cost: List[int]) -> int:\n    n = len(cost)\n    \n    # dp[i] = min cost to reach step i\n    # Only need previous two values\n    prev2, prev1 = 0, 0\n    \n    for i in range(2, n + 1):\n        curr = min(prev1 + cost[i - 1], prev2 + cost[i - 2])\n        prev2 = prev1\n        prev1 = curr\n    \n    return prev1"
      },
      {
        "id": "03-house-robber",
        "slug": "house-robber",
        "title": "House Robber",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "house-robber"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
        "examples": [
          {
            "input": "nums = [1,2,3,1]",
            "output": "4",
            "explanation": "Rob house 0 (1) + house 2 (3) = 4"
          },
          {
            "input": "nums = [2,7,9,3,1]",
            "output": "12",
            "explanation": "Rob house 0 (2) + house 2 (9) + house 4 (1) = 12"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At house i, you can:",
            "options": [
              {
                "id": "a",
                "text": "Rob it (can't rob i-1)"
              },
              {
                "id": "b",
                "text": "Skip it (keep previous best)"
              },
              {
                "id": "c",
                "text": "Rob both i and i-1"
              },
              {
                "id": "d",
                "text": "A and B both valid"
              }
            ],
            "correct": "d",
            "explanation": "At each house, choose: rob this one (skip i-1) or skip this one (keep i-1's best).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you rob house i, the best you can add to is:",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1] (include i-1)"
              },
              {
                "id": "b",
                "text": "dp[i-2] (skip i-1)"
              },
              {
                "id": "c",
                "text": "dp[i-3]"
              },
              {
                "id": "d",
                "text": "0"
              }
            ],
            "correct": "b",
            "explanation": "Can't rob adjacent. So if you rob i, you can only add to best result up to i-2.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you skip house i:",
            "options": [
              {
                "id": "a",
                "text": "You get dp[i-1]"
              },
              {
                "id": "b",
                "text": "You get dp[i-2]"
              },
              {
                "id": "c",
                "text": "You get 0"
              },
              {
                "id": "d",
                "text": "You must rob i-1"
              }
            ],
            "correct": "a",
            "explanation": "Skipping i means the best up to i is same as best up to i-1.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i] = ?",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1] + dp[i-2]"
              },
              {
                "id": "b",
                "text": "max(dp[i-1], dp[i-2])"
              },
              {
                "id": "c",
                "text": "max(nums[i] + dp[i-2], dp[i-1])"
              },
              {
                "id": "d",
                "text": "nums[i] + max(dp[i-1], dp[i-2])"
              }
            ],
            "correct": "c",
            "explanation": "Rob house i (nums[i] + dp[i-2]) OR skip it (dp[i-1]). Take max.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For one house nums[0]:",
            "options": [
              {
                "id": "a",
                "text": "dp[0] = 0"
              },
              {
                "id": "b",
                "text": "dp[0] = nums[0]"
              },
              {
                "id": "c",
                "text": "dp[0] = max(0, nums[0])"
              },
              {
                "id": "d",
                "text": "Depends on neighbors"
              }
            ],
            "correct": "b",
            "explanation": "With only one house, rob it.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "At each house: rob it (add to dp[i-2]) or skip it (keep dp[i-1]). Take the max.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "For each house: either rob it (add to best from 2 houses back) or skip it (take best from 1 house back).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "house robber",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def rob(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    # prev2 = max profit up to i-2\n    # prev1 = max profit up to i-1\n    prev2, prev1 = 0, nums[0]\n    \n    for i in range(1, len(nums)):\n        # Rob current (nums[i] + prev2) or skip (prev1)\n        curr = max(nums[i] + prev2, prev1)\n        prev2 = prev1\n        prev1 = curr\n    \n    return prev1"
      },
      {
        "id": "04-house-robber-ii",
        "slug": "house-robber-ii",
        "title": "House Robber II",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "house-robber-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
        "examples": [
          {
            "input": "nums = [2,3,2]",
            "output": "3",
            "explanation": "Cannot rob house 0 and 2 (adjacent in circle). Rob house 1."
          },
          {
            "input": "nums = [1,2,3,1]",
            "output": "4",
            "explanation": "Rob house 0 (1) + house 2 (3) = 4"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "In a circle, houses 0 and n-1 are:",
            "options": [
              {
                "id": "a",
                "text": "Independent"
              },
              {
                "id": "b",
                "text": "Adjacent (can't both be robbed)"
              },
              {
                "id": "c",
                "text": "The same house"
              },
              {
                "id": "d",
                "text": "Always robbed together"
              }
            ],
            "correct": "b",
            "explanation": "Circle means first and last are neighbors.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "We can split this into:",
            "options": [
              {
                "id": "a",
                "text": "Rob first OR rob last"
              },
              {
                "id": "b",
                "text": "Consider houses [0, n-2] OR [1, n-1]"
              },
              {
                "id": "c",
                "text": "Just use House Robber I solution"
              },
              {
                "id": "d",
                "text": "Divide into two equal halves"
              }
            ],
            "correct": "b",
            "explanation": "If we exclude last house, first can be robbed. If we exclude first, last can be robbed. One of these is optimal.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "max(rob[0..n-2], rob[1..n-1]) is correct because:",
            "options": [
              {
                "id": "a",
                "text": "One range includes first, other includes last"
              },
              {
                "id": "b",
                "text": "They don't overlap"
              },
              {
                "id": "c",
                "text": "They cover all houses"
              },
              {
                "id": "d",
                "text": "It's a heuristic"
              }
            ],
            "correct": "a",
            "explanation": "[0..n-2] allows robbing first but not last. [1..n-1] allows robbing last but not first. The optimal answer falls into one of these.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Middle houses (not first or last):",
            "options": [
              {
                "id": "a",
                "text": "Are in both ranges"
              },
              {
                "id": "b",
                "text": "Are excluded"
              },
              {
                "id": "c",
                "text": "Are special cases"
              },
              {
                "id": "d",
                "text": "Need separate handling"
              }
            ],
            "correct": "a",
            "explanation": "Both ranges include middle houses. They can be robbed in either scenario.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "With only one house:",
            "options": [
              {
                "id": "a",
                "text": "Return 0"
              },
              {
                "id": "b",
                "text": "Return nums[0]"
              },
              {
                "id": "c",
                "text": "Return -1"
              },
              {
                "id": "d",
                "text": "Not possible"
              }
            ],
            "correct": "b",
            "explanation": "One house has no neighbors (including itself). Rob it.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Circle = first and last adjacent. Break it: max(rob houses 0 to n-2, rob houses 1 to n-1). Solve two linear House Robber problems.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "Break the circle: either skip the first house OR skip the last house. Solve two linear problems.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "house robber ii",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def rob(nums: List[int]) -> int:\n    if len(nums) == 1:\n        return nums[0]\n    \n    def rob_linear(houses):\n        prev2, prev1 = 0, 0\n        for money in houses:\n            curr = max(money + prev2, prev1)\n            prev2 = prev1\n            prev1 = curr\n        return prev1\n    \n    # Skip last house OR skip first house\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"
      },
      {
        "id": "05-longest-palindromic-substring",
        "slug": "longest-palindromic-substring",
        "title": "Longest Palindromic Substring",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "longest-palindromic-substring"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s`, return the longest palindromic substring in `s`.",
        "examples": [
          {
            "input": "s = \"babad\"",
            "output": "\"bab\" (or \"aba\")",
            "explanation": ""
          },
          {
            "input": "s = \"cbbd\"",
            "output": "\"bb\"",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "\"aba\" has center at:",
            "options": [
              {
                "id": "a",
                "text": "'a' (index 0)"
              },
              {
                "id": "b",
                "text": "'b' (index 1)"
              },
              {
                "id": "c",
                "text": "'a' (index 2)"
              },
              {
                "id": "d",
                "text": "Between characters"
              }
            ],
            "correct": "b",
            "explanation": "Odd-length palindromes have a single character center.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "\"abba\" has center:",
            "options": [
              {
                "id": "a",
                "text": "At 'b' (index 1)"
              },
              {
                "id": "b",
                "text": "At 'b' (index 2)"
              },
              {
                "id": "c",
                "text": "Between the two 'b's"
              },
              {
                "id": "d",
                "text": "Doesn't have a center"
              }
            ],
            "correct": "c",
            "explanation": "Even-length palindromes have center between two characters.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "For string of length n, total possible centers:",
            "options": [
              {
                "id": "a",
                "text": "n"
              },
              {
                "id": "b",
                "text": "n - 1"
              },
              {
                "id": "c",
                "text": "2n - 1"
              },
              {
                "id": "d",
                "text": "n²"
              }
            ],
            "correct": "c",
            "explanation": "n single-char centers + (n-1) between-char centers = 2n - 1.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "When expanding from center (left, right):",
            "options": [
              {
                "id": "a",
                "text": "Expand if s[left] == s[right]"
              },
              {
                "id": "b",
                "text": "Expand if left < right"
              },
              {
                "id": "c",
                "text": "Expand if palindrome found"
              },
              {
                "id": "d",
                "text": "Always expand once"
              }
            ],
            "correct": "a",
            "explanation": "Keep expanding while characters match. Stop when mismatch or boundary.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Expand around center vs DP:",
            "options": [
              {
                "id": "a",
                "text": "DP is O(n²) time AND space"
              },
              {
                "id": "b",
                "text": "Expand is O(n²) time, O(1) space"
              },
              {
                "id": "c",
                "text": "They're the same"
              },
              {
                "id": "d",
                "text": "DP is faster"
              }
            ],
            "correct": "b",
            "explanation": "Expand around center is more space-efficient for this problem.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Every palindrome has a center. Try all 2n-1 centers, expand outward while characters match. Track longest.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "Expand around center: every palindrome has a center (one char for odd length, two chars for even length).",
        "timeComplexity": "O(n²)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "longest palindromic substring",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def longestPalindrome(s: str) -> str:\n    result = \"\"\n    \n    def expand(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    for i in range(len(s)):\n        # Odd length palindrome (single char center)\n        odd = expand(i, i)\n        if len(odd) > len(result):\n            result = odd\n        \n        # Even length palindrome (between chars center)\n        even = expand(i, i + 1)\n        if len(even) > len(result):\n            result = even\n    \n    return result"
      },
      {
        "id": "06-palindromic-substrings",
        "slug": "palindromic-substrings",
        "title": "Palindromic Substrings",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "palindromic-substrings"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s`, return the number of palindromic substrings in it.\n\nA string is a palindrome when it reads the same backward as forward.\n\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
          {
            "input": "s = \"abc\"",
            "output": "3",
            "explanation": "\"a\", \"b\", \"c\" (each single char is a palindrome)"
          },
          {
            "input": "s = \"aaa\"",
            "output": "6",
            "explanation": "\"a\" (3 times), \"aa\" (2 times), \"aaa\" (1 time)"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Each single character is:",
            "options": [
              {
                "id": "a",
                "text": "Not a palindrome"
              },
              {
                "id": "b",
                "text": "Always a palindrome"
              },
              {
                "id": "c",
                "text": "Sometimes a palindrome"
              },
              {
                "id": "d",
                "text": "A center only"
              }
            ],
            "correct": "b",
            "explanation": "Any single character reads same forwards and backwards.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "When expanding from center and s[left] == s[right]:",
            "options": [
              {
                "id": "a",
                "text": "Found one palindrome, stop"
              },
              {
                "id": "b",
                "text": "Found one palindrome, continue expanding"
              },
              {
                "id": "c",
                "text": "Not a palindrome yet"
              },
              {
                "id": "d",
                "text": "Found all palindromes"
              }
            ],
            "correct": "b",
            "explanation": "Each successful expansion is a NEW palindrome. \"a\", \"aba\", \"cabac\" are all different palindromes from same center.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Palindromic substrings in \"aba\":",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "2"
              },
              {
                "id": "c",
                "text": "3"
              },
              {
                "id": "d",
                "text": "4"
              }
            ],
            "correct": "d",
            "explanation": "\"a\" (pos 0), \"b\", \"a\" (pos 2), \"aba\" = 4 palindromes.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "The expand function should return:",
            "options": [
              {
                "id": "a",
                "text": "True/False"
              },
              {
                "id": "b",
                "text": "Length of palindrome"
              },
              {
                "id": "c",
                "text": "Count of palindromes found"
              },
              {
                "id": "d",
                "text": "Starting index"
              }
            ],
            "correct": "c",
            "explanation": "Each expansion step = one palindrome. Return total count from this center.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Total palindromes = sum of:",
            "options": [
              {
                "id": "a",
                "text": "Palindromes from each odd center + even center"
              },
              {
                "id": "b",
                "text": "All substrings"
              },
              {
                "id": "c",
                "text": "Unique characters"
              },
              {
                "id": "d",
                "text": "Longest palindrome"
              }
            ],
            "correct": "a",
            "explanation": "Try all 2n-1 centers, sum up palindromes found from each.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Expand from each of 2n-1 centers. Each successful expansion = one more palindrome. Sum all counts.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "Same as Longest Palindromic Substring: expand around each center, but COUNT instead of track max.",
        "timeComplexity": "O(n²)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "palindromic substrings",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def countSubstrings(s: str) -> int:\n    count = 0\n    \n    def expand(left, right):\n        nonlocal count\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    \n    for i in range(len(s)):\n        expand(i, i)      # Odd length\n        expand(i, i + 1)  # Even length\n    \n    return count"
      },
      {
        "id": "07-decode-ways",
        "slug": "decode-ways",
        "title": "Decode Ways",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "decode-ways"
        ],
        "estimatedTime": 5,
        "problemStatement": "A message containing letters from `A-Z` can be encoded into numbers using the following mapping:\n\n```\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nGiven a string `s` containing only digits, return the number of ways to decode it.",
        "examples": [
          {
            "input": "s = \"12\"",
            "output": "2",
            "explanation": "\"12\" can be decoded as \"AB\" (1 2) or \"L\" (12)."
          },
          {
            "input": "s = \"226\"",
            "output": "3",
            "explanation": "\"226\" can be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
          },
          {
            "input": "s = \"06\"",
            "output": "0",
            "explanation": "\"06\" cannot be decoded. \"6\" is valid but not \"06\"."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A single digit is valid if:",
            "options": [
              {
                "id": "a",
                "text": "It's 0-9"
              },
              {
                "id": "b",
                "text": "It's 1-9"
              },
              {
                "id": "c",
                "text": "It's 1-26"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "b",
            "explanation": "'0' alone has no letter. Only '1'-'9' map to 'A'-'I'.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Two digits \"XY\" are valid if:",
            "options": [
              {
                "id": "a",
                "text": "10 ≤ XY ≤ 26"
              },
              {
                "id": "b",
                "text": "1 ≤ XY ≤ 26"
              },
              {
                "id": "c",
                "text": "XY ≤ 26"
              },
              {
                "id": "d",
                "text": "X is not 0"
              }
            ],
            "correct": "a",
            "explanation": "Must be 10-26. Numbers like \"01\", \"05\" are invalid (leading zero).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i] = number of ways to decode s[0:i]. dp[i] = ?",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1] + dp[i-2]"
              },
              {
                "id": "b",
                "text": "dp[i-1] (if s[i-1] valid) + dp[i-2] (if s[i-2:i] valid)"
              },
              {
                "id": "c",
                "text": "max(dp[i-1], dp[i-2])"
              },
              {
                "id": "d",
                "text": "dp[i-1] * dp[i-2]"
              }
            ],
            "correct": "b",
            "explanation": "Add ways from using 1 digit (if valid) and from using 2 digits (if valid).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "How many ways to decode \"06\"?",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "2"
              },
              {
                "id": "c",
                "text": "0"
              },
              {
                "id": "d",
                "text": "6"
              }
            ],
            "correct": "c",
            "explanation": "\"0\" is invalid single digit. \"06\" is invalid (leading zero). No valid decoding.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0] (empty string) should be:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "Undefined"
              },
              {
                "id": "d",
                "text": "-1"
              }
            ],
            "correct": "b",
            "explanation": "One way to decode empty string: do nothing. Needed for recurrence to work.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Like climbing stairs, but with validity checks. dp[i] = dp[i-1] (if single digit valid) + dp[i-2] (if two digits valid).",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "At each position: either take 1 digit (if valid) or 2 digits (if valid). Similar to climbing stairs with conditions.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "decode ways",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def numDecodings(s: str) -> int:\n    if not s or s[0] == '0':\n        return 0\n    \n    # prev2 = dp[i-2], prev1 = dp[i-1]\n    prev2, prev1 = 1, 1\n    \n    for i in range(1, len(s)):\n        curr = 0\n        \n        # Single digit valid (1-9)\n        if s[i] != '0':\n            curr += prev1\n        \n        # Two digits valid (10-26)\n        two_digit = int(s[i-1:i+1])\n        if 10 <= two_digit <= 26:\n            curr += prev2\n        \n        prev2 = prev1\n        prev1 = curr\n    \n    return prev1"
      },
      {
        "id": "08-word-break",
        "slug": "word-break",
        "title": "Word Break",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "word-break"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.",
        "examples": [
          {
            "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
            "output": "true",
            "explanation": "\"leetcode\" = \"leet\" + \"code\""
          },
          {
            "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
            "output": "true",
            "explanation": "\"applepenapple\" = \"apple\" + \"pen\" + \"apple\""
          },
          {
            "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "dp[i] represents:",
            "options": [
              {
                "id": "a",
                "text": "Number of ways to segment s[0:i]"
              },
              {
                "id": "b",
                "text": "Whether s[0:i] can be segmented"
              },
              {
                "id": "c",
                "text": "Length of longest word ending at i"
              },
              {
                "id": "d",
                "text": "Number of words used"
              }
            ],
            "correct": "b",
            "explanation": "Boolean - can we successfully segment the first i characters?",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i] is True if:",
            "options": [
              {
                "id": "a",
                "text": "s[0:i] is in dictionary"
              },
              {
                "id": "b",
                "text": "For some j, dp[j] is True AND s[j:i] is in dictionary"
              },
              {
                "id": "c",
                "text": "s[i-1:i] is in dictionary"
              },
              {
                "id": "d",
                "text": "All characters are in dictionary"
              }
            ],
            "correct": "b",
            "explanation": "If we can segment s[0:j], and s[j:i] is a word, then s[0:i] is segmentable.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0] should be:",
            "options": [
              {
                "id": "a",
                "text": "False"
              },
              {
                "id": "b",
                "text": "True"
              },
              {
                "id": "c",
                "text": "Depends on first character"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "Empty string is \"trivially\" segmented. Needed for recurrence.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For dp[i], we check j from:",
            "options": [
              {
                "id": "a",
                "text": "0 to i-1"
              },
              {
                "id": "b",
                "text": "i-1 to 0"
              },
              {
                "id": "c",
                "text": "Only j = i-1"
              },
              {
                "id": "d",
                "text": "Random order"
              }
            ],
            "correct": "a",
            "explanation": "Try all possible \"last word\" lengths. Either order works, but forward is typical.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "We can optimize by:",
            "options": [
              {
                "id": "a",
                "text": "Using a set for wordDict"
              },
              {
                "id": "b",
                "text": "Only checking j where (i-j) ≤ max word length"
              },
              {
                "id": "c",
                "text": "Breaking early when dp[i] becomes True"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Set for O(1) lookup, limit j range by max word length, early exit.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "dp[i] = can s[0:i] be segmented? True if for any j < i, dp[j] is True AND s[j:i] is in dictionary.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "dp[i] = can s[0:i] be segmented? Check all possible last words.",
        "timeComplexity": "O(n² × m)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "word break",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def wordBreak(s: str, wordDict: List[str]) -> bool:\n    word_set = set(wordDict)\n    n = len(s)\n    \n    # dp[i] = can s[0:i] be segmented?\n    dp = [False] * (n + 1)\n    dp[0] = True  # Empty string\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            # If s[0:j] can be segmented and s[j:i] is a word\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[n]"
      }
    ],
    "2d-dp": [
      {
        "id": "01-unique-paths",
        "slug": "unique-paths",
        "title": "Unique Paths",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "unique-paths"
        ],
        "estimatedTime": 5,
        "problemStatement": "There is a robot on an `m x n` grid. The robot is initially located at the top-left corner (i.e., `grid[0][0]`). The robot tries to move to the bottom-right corner (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
        "examples": [
          {
            "input": "m = 3, n = 7",
            "output": "28",
            "explanation": ""
          },
          {
            "input": "m = 3, n = 2",
            "output": "3",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To reach cell (i, j), you came from:",
            "options": [
              {
                "id": "a",
                "text": "(i-1, j) only"
              },
              {
                "id": "b",
                "text": "(i, j-1) only"
              },
              {
                "id": "c",
                "text": "(i-1, j) or (i, j-1)"
              },
              {
                "id": "d",
                "text": "Any adjacent cell"
              }
            ],
            "correct": "c",
            "explanation": "Can only move right or down. So you arrived from above or from left.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] = ?",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1][j] × dp[i][j-1]"
              },
              {
                "id": "b",
                "text": "dp[i-1][j] + dp[i][j-1]"
              },
              {
                "id": "c",
                "text": "max(dp[i-1][j], dp[i][j-1])"
              },
              {
                "id": "d",
                "text": "min(dp[i-1][j], dp[i][j-1])"
              }
            ],
            "correct": "b",
            "explanation": "Total ways = ways from top + ways from left.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For cells in the first row (i=0):",
            "options": [
              {
                "id": "a",
                "text": "dp[0][j] = 0"
              },
              {
                "id": "b",
                "text": "dp[0][j] = 1"
              },
              {
                "id": "c",
                "text": "dp[0][j] = j"
              },
              {
                "id": "d",
                "text": "dp[0][j] = j + 1"
              }
            ],
            "correct": "b",
            "explanation": "Only one way to reach any cell in first row: keep going right.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For cells in the first column (j=0):",
            "options": [
              {
                "id": "a",
                "text": "dp[i][0] = 0"
              },
              {
                "id": "b",
                "text": "dp[i][0] = 1"
              },
              {
                "id": "c",
                "text": "dp[i][0] = i"
              },
              {
                "id": "d",
                "text": "dp[i][0] = i + 1"
              }
            ],
            "correct": "b",
            "explanation": "Only one way to reach any cell in first column: keep going down.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "We can reduce space to O(n) because:",
            "options": [
              {
                "id": "a",
                "text": "We only need the previous row"
              },
              {
                "id": "b",
                "text": "We only need diagonal"
              },
              {
                "id": "c",
                "text": "We don't need any previous values"
              },
              {
                "id": "d",
                "text": "Grid is symmetric"
              }
            ],
            "correct": "a",
            "explanation": "Each row only depends on the row above it.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. First row and column are all 1s. Or use combinatorics: C(m+n-2, m-1).",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "To reach cell (i,j), you either came from (i-1,j) or (i,j-1).",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "unique paths",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def uniquePaths(m: int, n: int) -> int:\n    # Space-optimized 1D DP\n    dp = [1] * n\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[j] += dp[j - 1]\n    \n    return dp[n - 1]"
      },
      {
        "id": "02-longest-common-subsequence",
        "slug": "longest-common-subsequence",
        "title": "Longest Common Subsequence",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "longest-common-subsequence"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `text1` and `text2`, return the length of their longest common subsequence. If there is no common subsequence, return `0`.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",
        "examples": [
          {
            "input": "text1 = \"abcde\", text2 = \"ace\"",
            "output": "3",
            "explanation": "The longest common subsequence is \"ace\"."
          },
          {
            "input": "text1 = \"abc\", text2 = \"abc\"",
            "output": "3",
            "explanation": ""
          },
          {
            "input": "text1 = \"abc\", text2 = \"def\"",
            "output": "0",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If text1[i-1] == text2[j-1], then:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j] = dp[i-1][j-1]"
              },
              {
                "id": "b",
                "text": "dp[i][j] = dp[i-1][j-1] + 1"
              },
              {
                "id": "c",
                "text": "dp[i][j] = dp[i-1][j] + dp[i][j-1]"
              },
              {
                "id": "d",
                "text": "dp[i][j] = 1"
              }
            ],
            "correct": "b",
            "explanation": "Matching characters extend the LCS by 1.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If text1[i-1] != text2[j-1], then:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j] = 0"
              },
              {
                "id": "b",
                "text": "dp[i][j] = dp[i-1][j-1]"
              },
              {
                "id": "c",
                "text": "dp[i][j] = max(dp[i-1][j], dp[i][j-1])"
              },
              {
                "id": "d",
                "text": "dp[i][j] = dp[i-1][j] + dp[i][j-1]"
              }
            ],
            "correct": "c",
            "explanation": "Characters don't match, so skip one character from either string. Take the better result.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0][j] and dp[i][0] should be:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "-1"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "a",
            "explanation": "Empty string has no common subsequence with anything. LCS = 0.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "When chars don't match, we try both dp[i-1][j] and dp[i][j-1] because:",
            "options": [
              {
                "id": "a",
                "text": "The optimal LCS might not include text1[i-1]"
              },
              {
                "id": "b",
                "text": "The optimal LCS might not include text2[j-1]"
              },
              {
                "id": "c",
                "text": "We don't know which exclusion leads to longer LCS"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Either character might be useless for the LCS. Try excluding each.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] represents LCS of:",
            "options": [
              {
                "id": "a",
                "text": "text1[0:i] and text2[0:j]"
              },
              {
                "id": "b",
                "text": "text1[i:] and text2[j:]"
              },
              {
                "id": "c",
                "text": "text1[i] and text2[j] only"
              },
              {
                "id": "d",
                "text": "First i and j characters respectively"
              }
            ],
            "correct": "a",
            "explanation": "1-indexed DP where dp[i][j] = LCS of first i chars of text1, first j chars of text2.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Match → dp[i-1][j-1] + 1. No match → max(dp[i-1][j], dp[i][j-1]). Classic 2D DP on two strings.",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "If characters match, extend LCS by 1. Otherwise, take max of excluding each character.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "longest common subsequence",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    \n    # Space-optimized: only need previous row\n    prev = [0] * (n + 1)\n    \n    for i in range(1, m + 1):\n        curr = [0] * (n + 1)\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                curr[j] = prev[j - 1] + 1\n            else:\n                curr[j] = max(prev[j], curr[j - 1])\n        prev = curr\n    \n    return prev[n]"
      },
      {
        "id": "03-best-time-to-buy-and-sell-stock-with-cooldown",
        "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "best-time-to-buy-and-sell-stock-with-cooldown"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n- After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "examples": [
          {
            "input": "prices = [1,2,3,0,2]",
            "output": "3",
            "explanation": "transactions = [buy, sell, cooldown, buy, sell]"
          },
          {
            "input": "prices = [1]",
            "output": "0",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At any day, you can be in state:",
            "options": [
              {
                "id": "a",
                "text": "Holding stock"
              },
              {
                "id": "b",
                "text": "Just sold (cooldown)"
              },
              {
                "id": "c",
                "text": "Resting (no stock, ready to buy)"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Three states capture all situations.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you're holding stock today, tomorrow you can:",
            "options": [
              {
                "id": "a",
                "text": "Keep holding"
              },
              {
                "id": "b",
                "text": "Sell (go to \"sold\" state)"
              },
              {
                "id": "c",
                "text": "Buy more"
              },
              {
                "id": "d",
                "text": "A and B only"
              }
            ],
            "correct": "d",
            "explanation": "Either keep holding or sell. Can't buy more (already holding).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you just sold today, tomorrow you MUST:",
            "options": [
              {
                "id": "a",
                "text": "Buy"
              },
              {
                "id": "b",
                "text": "Sell again"
              },
              {
                "id": "c",
                "text": "Rest (cooldown)"
              },
              {
                "id": "d",
                "text": "Any action"
              }
            ],
            "correct": "c",
            "explanation": "Cooldown forces you to rest the day after selling.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you're resting (no stock, not in cooldown), tomorrow you can:",
            "options": [
              {
                "id": "a",
                "text": "Buy"
              },
              {
                "id": "b",
                "text": "Keep resting"
              },
              {
                "id": "c",
                "text": "Sell"
              },
              {
                "id": "d",
                "text": "A and B only"
              }
            ],
            "correct": "d",
            "explanation": "Can buy or continue resting. Can't sell (no stock).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "hold[i] = max(hold[i-1], rest[i-1] - prices[i])\\nsold[i] = hold[i-1] + prices[i]\\nrest[i] = max(rest[i-1], sold[i-1])\\n\\nThe pattern is:",
            "options": [
              {
                "id": "a",
                "text": "Each state updates from previous states"
              },
              {
                "id": "b",
                "text": "Cooldown is encoded in sold→rest transition"
              },
              {
                "id": "c",
                "text": "Both"
              }
            ],
            "correct": "c",
            "explanation": "State machine DP where each state has specific transitions.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "State machine with 3 states: hold, sold (cooldown), rest. Sold must go to rest. Rest can go to hold. Each day update all states.",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "State machine: track whether you're holding stock or not, and if you just sold.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "best time to buy and sell stock with cooldown",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxProfit(prices: List[int]) -> int:\n    if not prices:\n        return 0\n    \n    # State machine: hold, sold, rest\n    hold = -prices[0]  # Bought stock\n    sold = 0           # Just sold (cooldown next)\n    rest = 0           # Resting (can buy)\n    \n    for i in range(1, len(prices)):\n        prev_hold = hold\n        hold = max(hold, rest - prices[i])  # Keep or buy\n        rest = max(rest, sold)              # Keep resting or cooldown done\n        sold = prev_hold + prices[i]        # Sell\n    \n    return max(sold, rest)"
      },
      {
        "id": "04-coin-change-ii",
        "slug": "coin-change-ii",
        "title": "Coin Change II",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "coin-change-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return `0`.\n\nYou may assume that you have an infinite number of each kind of coin.",
        "examples": [
          {
            "input": "amount = 5, coins = [1, 2, 5]",
            "output": "4",
            "explanation": "5=5, 5=2+2+1, 5=2+1+1+1, 5=1+1+1+1+1"
          },
          {
            "input": "amount = 3, coins = [2]",
            "output": "0",
            "explanation": ""
          },
          {
            "input": "amount = 10, coins = [10]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Why is this different from \"ways to reach amount\"?",
            "options": [
              {
                "id": "a",
                "text": "[1,2] and [2,1] are different in climbing stairs"
              },
              {
                "id": "b",
                "text": "[1,2] and [2,1] are same combination here"
              },
              {
                "id": "c",
                "text": "We need combinations, not permutations"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Order matters in permutations (stairs), not in combinations (coins).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "To count combinations only:",
            "options": [
              {
                "id": "a",
                "text": "Process amounts first, coins second (permutations)"
              },
              {
                "id": "b",
                "text": "Process coins first, amounts second (combinations)"
              },
              {
                "id": "c",
                "text": "Order doesn't matter"
              },
              {
                "id": "d",
                "text": "Use recursion only"
              }
            ],
            "correct": "b",
            "explanation": "Process each coin completely before moving to next. Ensures each combination counted once.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Outer loop on coins ensures:",
            "options": [
              {
                "id": "a",
                "text": "Each coin used at most once"
              },
              {
                "id": "b",
                "text": "Combinations like [1,2] and [2,1] counted once"
              },
              {
                "id": "c",
                "text": "Smaller coins first"
              },
              {
                "id": "d",
                "text": "Faster computation"
              }
            ],
            "correct": "b",
            "explanation": "By fixing coin order (coin1, then coin2, ...), we only count [coin1, coin1, coin2], never [coin2, coin1, coin1].",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[j] after considering coin:",
            "options": [
              {
                "id": "a",
                "text": "dp[j] + dp[j - coin]"
              },
              {
                "id": "b",
                "text": "dp[j] * dp[j - coin]"
              },
              {
                "id": "c",
                "text": "max(dp[j], dp[j - coin])"
              },
              {
                "id": "d",
                "text": "dp[j - coin] only"
              }
            ],
            "correct": "a",
            "explanation": "Ways without this coin + ways using at least one of this coin.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0] should be:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "Number of coins"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "One way to make amount 0: use no coins.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Unbounded knapsack for counting. Outer loop on coins (not amounts) ensures combinations, not permutations. dp[j] += dp[j - coin].",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "Process coins one at a time to avoid counting permutations.",
        "timeComplexity": "O(amount × coins)",
        "spaceComplexity": "O(amount)",
        "triggerWords": [
          "coin change ii",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def change(amount: int, coins: List[int]) -> int:\n    dp = [0] * (amount + 1)\n    dp[0] = 1  # One way to make 0: use nothing\n    \n    # Outer loop on coins = combinations (not permutations)\n    for coin in coins:\n        for j in range(coin, amount + 1):\n            dp[j] += dp[j - coin]\n    \n    return dp[amount]"
      },
      {
        "id": "05-target-sum",
        "slug": "target-sum",
        "title": "Target Sum",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "target-sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `nums` and an integer `target`.\n\nYou want to build an expression out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.\n\nReturn the number of different expressions that you can build, which evaluates to `target`.",
        "examples": [
          {
            "input": "nums = [1,1,1,1,1], target = 3",
            "output": "5",
            "explanation": ""
          },
          {
            "input": "nums = [1], target = 1",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Assigning +/- splits numbers into:",
            "options": [
              {
                "id": "a",
                "text": "Two equal groups"
              },
              {
                "id": "b",
                "text": "Positive group P and negative group N"
              },
              {
                "id": "c",
                "text": "Odd and even groups"
              },
              {
                "id": "d",
                "text": "Random groups"
              }
            ],
            "correct": "b",
            "explanation": "Numbers with + form P, numbers with - form N.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If P = sum of positive, N = sum of negative:",
            "options": [
              {
                "id": "a",
                "text": "P - N = target AND P + N = sum"
              },
              {
                "id": "b",
                "text": "P + N = target"
              },
              {
                "id": "c",
                "text": "P - N = sum"
              },
              {
                "id": "d",
                "text": "P × N = target"
              }
            ],
            "correct": "a",
            "explanation": "P - N gives target. P + N = total sum of all numbers.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "From P - N = target and P + N = sum:",
            "options": [
              {
                "id": "a",
                "text": "P = (sum + target) / 2"
              },
              {
                "id": "b",
                "text": "P = (sum - target) / 2"
              },
              {
                "id": "c",
                "text": "P = sum + target"
              },
              {
                "id": "d",
                "text": "P = target / 2"
              }
            ],
            "correct": "a",
            "explanation": "Adding equations: 2P = sum + target, so P = (sum + target) / 2.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "No solution exists if:",
            "options": [
              {
                "id": "a",
                "text": "(sum + target) is odd"
              },
              {
                "id": "b",
                "text": "|target| > sum"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "P must be integer (odd sum+target is impossible). Target beyond range is impossible.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "This becomes:",
            "options": [
              {
                "id": "a",
                "text": "Coin Change"
              },
              {
                "id": "b",
                "text": "Subset Sum counting"
              },
              {
                "id": "c",
                "text": "LCS"
              },
              {
                "id": "d",
                "text": "Knapsack"
              }
            ],
            "correct": "b",
            "explanation": "Count subsets with sum = (sum + target) / 2.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Transform: P - N = target, P + N = sum → P = (sum+target)/2. Count subsets summing to P. Classic 0/1 knapsack with reverse loop.",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "Split into two groups: positive (P) and negative (N). P - N = target, P + N = sum. Solve for P.",
        "timeComplexity": "O(n × sum)",
        "spaceComplexity": "O(sum)",
        "triggerWords": [
          "target sum",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findTargetSumWays(nums: List[int], target: int) -> int:\n    total = sum(nums)\n    \n    # P - N = target, P + N = total\n    # 2P = total + target, P = (total + target) / 2\n    if (total + target) % 2 != 0 or abs(target) > total:\n        return 0\n    \n    P = (total + target) // 2\n    \n    # Count subsets summing to P (0/1 knapsack)\n    dp = [0] * (P + 1)\n    dp[0] = 1\n    \n    for num in nums:\n        for j in range(P, num - 1, -1):  # Reverse to avoid reuse\n            dp[j] += dp[j - num]\n    \n    return dp[P]"
      },
      {
        "id": "06-interleaving-string",
        "slug": "interleaving-string",
        "title": "Interleaving String",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "interleaving-string"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an interleaving of `s1` and `s2`.\n\nAn interleaving of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that:\n\n- `s = s1 + s2 + ... + sn`\n- `t = t1 + t2 + ... + tm`\n- `|n - m| <= 1`\n- The interleaving is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`",
        "examples": [
          {
            "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
            "output": "true",
            "explanation": "One way: aa + dbbc + bc + a + c"
          },
          {
            "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If len(s1) + len(s2) != len(s3):",
            "options": [
              {
                "id": "a",
                "text": "Might still work"
              },
              {
                "id": "b",
                "text": "Definitely impossible"
              },
              {
                "id": "c",
                "text": "Need more checking"
              },
              {
                "id": "d",
                "text": "Only works for empty strings"
              }
            ],
            "correct": "b",
            "explanation": "Interleaving uses all characters from both strings exactly once.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] represents:",
            "options": [
              {
                "id": "a",
                "text": "LCS of s1[0:i] and s2[0:j]"
              },
              {
                "id": "b",
                "text": "Whether s1[0:i] + s2[0:j] equals s3[0:i+j]"
              },
              {
                "id": "c",
                "text": "Whether s1[0:i] and s2[0:j] can interleave to form s3[0:i+j]"
              },
              {
                "id": "d",
                "text": "Number of interleavings"
              }
            ],
            "correct": "c",
            "explanation": "Boolean - can we form s3[0:i+j] using exactly i chars from s1 and j chars from s2.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] is True if:",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1][j] and s1[i-1] == s3[i+j-1]"
              },
              {
                "id": "b",
                "text": "dp[i][j-1] and s2[j-1] == s3[i+j-1]"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "Both A and B must be true"
              }
            ],
            "correct": "c",
            "explanation": "s3[i+j-1] came from either s1[i-1] or s2[j-1]. Either path works.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0][0] should be:",
            "options": [
              {
                "id": "a",
                "text": "False"
              },
              {
                "id": "b",
                "text": "True"
              },
              {
                "id": "c",
                "text": "Depends on s3"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "Empty strings interleave to form empty string.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0][j] is True if:",
            "options": [
              {
                "id": "a",
                "text": "s2[0:j] == s3[0:j]"
              },
              {
                "id": "b",
                "text": "Always True"
              },
              {
                "id": "c",
                "text": "Always False"
              },
              {
                "id": "d",
                "text": "Random"
              }
            ],
            "correct": "a",
            "explanation": "Using 0 chars from s1, j chars from s2 must exactly match s3[0:j].",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "dp[i][j] = can s1[0:i] and s2[0:j] interleave to form s3[0:i+j]? Transition: next char in s3 comes from s1 or s2.",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "dp[i][j] = can first i chars of s1 and first j chars of s2 form first i+j chars of s3?",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "interleaving string",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isInterleave(s1: str, s2: str, s3: str) -> bool:\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n    \n    # Space-optimized 1D DP\n    dp = [False] * (n + 1)\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 and j == 0:\n                dp[j] = True\n            elif i == 0:\n                dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n            elif j == 0:\n                dp[j] = dp[j] and s1[i - 1] == s3[i - 1]\n            else:\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or \\\n                        (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n    \n    return dp[n]"
      },
      {
        "id": "07-edit-distance",
        "slug": "edit-distance",
        "title": "Edit Distance",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "edit-distance"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have the following three operations permitted on a word:\n- Insert a character\n- Delete a character\n- Replace a character",
        "examples": [
          {
            "input": "word1 = \"horse\", word2 = \"ros\"",
            "output": "3",
            "explanation": "horse → rorse (replace 'h' with 'r')"
          },
          {
            "input": "word1 = \"intention\", word2 = \"execution\"",
            "output": "5",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If word1[i-1] == word2[j-1]:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j] = dp[i-1][j-1]"
              },
              {
                "id": "b",
                "text": "dp[i][j] = dp[i-1][j-1] + 1"
              },
              {
                "id": "c",
                "text": "dp[i][j] = 0"
              },
              {
                "id": "d",
                "text": "dp[i][j] = min of three operations"
              }
            ],
            "correct": "a",
            "explanation": "Characters match, no operation needed. Same as previous state.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Inserting into word1 corresponds to:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j-1] + 1"
              },
              {
                "id": "b",
                "text": "dp[i-1][j] + 1"
              },
              {
                "id": "c",
                "text": "dp[i-1][j-1] + 1"
              },
              {
                "id": "d",
                "text": "dp[i][j] + 1"
              }
            ],
            "correct": "a",
            "explanation": "Insert char to match word2[j-1]. Now need to match word1[0:i] with word2[0:j-1].",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Deleting from word1 corresponds to:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j-1] + 1"
              },
              {
                "id": "b",
                "text": "dp[i-1][j] + 1"
              },
              {
                "id": "c",
                "text": "dp[i-1][j-1] + 1"
              },
              {
                "id": "d",
                "text": "dp[i][j] - 1"
              }
            ],
            "correct": "b",
            "explanation": "Delete word1[i-1]. Now need to match word1[0:i-1] with word2[0:j].",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Replacing in word1 corresponds to:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j-1] + 1"
              },
              {
                "id": "b",
                "text": "dp[i-1][j] + 1"
              },
              {
                "id": "c",
                "text": "dp[i-1][j-1] + 1"
              },
              {
                "id": "d",
                "text": "dp[i-1][j-1]"
              }
            ],
            "correct": "c",
            "explanation": "Replace word1[i-1] with word2[j-1]. Both chars now \"match\" (handled). Move diagonally.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][0] and dp[0][j] are:",
            "options": [
              {
                "id": "a",
                "text": "All 0"
              },
              {
                "id": "b",
                "text": "dp[i][0] = i, dp[0][j] = j"
              },
              {
                "id": "c",
                "text": "All 1"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "Transform word1[0:i] to empty = i deletions. Transform empty to word2[0:j] = j insertions.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Match → dp[i-1][j-1]. No match → 1 + min(insert dp[i][j-1], delete dp[i-1][j], replace dp[i-1][j-1]).",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "If characters match, no operation needed. Otherwise, try all three operations and take minimum.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "edit distance",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    \n    # Space-optimized: only need previous row\n    prev = list(range(n + 1))  # Base: dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        curr = [i] + [0] * n  # Base: dp[i][0] = i\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                curr[j] = prev[j - 1]\n            else:\n                curr[j] = 1 + min(\n                    curr[j - 1],   # Insert\n                    prev[j],       # Delete\n                    prev[j - 1]    # Replace\n                )\n        prev = curr\n    \n    return prev[n]"
      },
      {
        "id": "08-burst-balloons",
        "slug": "burst-balloons",
        "title": "Burst Balloons",
        "category": "2d-dp",
        "difficulty": "hard",
        "tags": [
          "2d-dp",
          "burst-balloons"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn the maximum coins you can collect by bursting the balloons wisely.",
        "examples": [
          {
            "input": "nums = [3,1,5,8]",
            "output": "167",
            "explanation": ""
          },
          {
            "input": "nums = [1,5]",
            "output": "10",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Thinking \"which balloon to burst first\" is hard because:",
            "options": [
              {
                "id": "a",
                "text": "Adjacent balloons change after each burst"
              },
              {
                "id": "b",
                "text": "Subproblems aren't independent"
              },
              {
                "id": "c",
                "text": "Can't use DP easily"
              },
              {
                "id": "d",
                "text": "A and B"
              }
            ],
            "correct": "d",
            "explanation": "After bursting, neighbors change. Left and right subproblems depend on what was burst.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "\"Which balloon to burst LAST in range\" works because:",
            "options": [
              {
                "id": "a",
                "text": "The last balloon sees the boundary balloons"
              },
              {
                "id": "b",
                "text": "Left and right subproblems become independent"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "It doesn't work"
              }
            ],
            "correct": "c",
            "explanation": "If k is last in (i,j), left side (i,k) and right side (k,j) are solved independently first.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If balloon k is burst last in range (i, j):",
            "options": [
              {
                "id": "a",
                "text": "Coins = nums[i] * nums[k] * nums[j]"
              },
              {
                "id": "b",
                "text": "Coins = nums[k-1] * nums[k] * nums[k+1]"
              },
              {
                "id": "c",
                "text": "Coins = nums[k] only"
              },
              {
                "id": "d",
                "text": "Depends on order"
              }
            ],
            "correct": "a",
            "explanation": "When k is last, all others are gone. k sees boundaries i and j.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] represents:",
            "options": [
              {
                "id": "a",
                "text": "Max coins for bursting balloons in original range"
              },
              {
                "id": "b",
                "text": "Max coins for balloons between indices i and j (exclusive)"
              },
              {
                "id": "c",
                "text": "Number of balloons"
              },
              {
                "id": "d",
                "text": "Min coins"
              }
            ],
            "correct": "b",
            "explanation": "Range (i, j) means balloons from i+1 to j-1. Boundaries i and j remain.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] = max over k of:",
            "options": [
              {
                "id": "a",
                "text": "nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j]"
              },
              {
                "id": "b",
                "text": "dp[i][k] * dp[k][j]"
              },
              {
                "id": "c",
                "text": "nums[k] + dp[i][k] + dp[k][j]"
              },
              {
                "id": "d",
                "text": "max(dp[i][k], dp[k][j])"
              }
            ],
            "correct": "a",
            "explanation": "Burst k last (gets i*k*j coins), plus best for left and right subranges.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Think backwards: which balloon k is burst LAST in range (i,j)? It sees boundaries i,j. Coins = nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j].",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "Think backwards: which balloon is burst LAST in a range?",
        "timeComplexity": "O(n³)",
        "spaceComplexity": "O(n²)",
        "triggerWords": [
          "burst balloons",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxCoins(nums: List[int]) -> int:\n    # Add boundary balloons with value 1\n    nums = [1] + nums + [1]\n    n = len(nums)\n    \n    # dp[i][j] = max coins for range (i, j) exclusive\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill by increasing range length\n    for length in range(2, n):  # length = j - i\n        for i in range(n - length):\n            j = i + length\n            # Try each k as last balloon to burst in (i, j)\n            for k in range(i + 1, j):\n                coins = nums[i] * nums[k] * nums[j]\n                dp[i][j] = max(dp[i][j], dp[i][k] + coins + dp[k][j])\n    \n    return dp[0][n - 1]"
      }
    ],
    "greedy": [
      {
        "id": "01-maximum-subarray",
        "slug": "maximum-subarray",
        "title": "Maximum Subarray",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "maximum-subarray"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.",
        "examples": [
          {
            "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
            "output": "6",
            "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
          },
          {
            "input": "nums = [1]",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "nums = [5,4,-1,7,8]",
            "output": "23",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At each element, we decide:",
            "options": [
              {
                "id": "a",
                "text": "Include in current subarray or start new"
              },
              {
                "id": "b",
                "text": "Skip or include"
              },
              {
                "id": "c",
                "text": "Add or subtract"
              },
              {
                "id": "d",
                "text": "Left or right"
              }
            ],
            "correct": "a",
            "explanation": "Either extend current subarray or this element starts a new one.",
            "conceptId": "kadane"
          },
          {
            "type": "mcq",
            "question": "We start a new subarray at nums[i] when:",
            "options": [
              {
                "id": "a",
                "text": "nums[i] is positive"
              },
              {
                "id": "b",
                "text": "current_sum + nums[i] < nums[i]"
              },
              {
                "id": "c",
                "text": "nums[i] is the largest"
              },
              {
                "id": "d",
                "text": "i is even"
              }
            ],
            "correct": "b",
            "explanation": "If adding to current sum makes it worse than just nums[i], start fresh.",
            "conceptId": "kadane"
          },
          {
            "type": "mcq",
            "question": "current_sum + nums[i] < nums[i] simplifies to:",
            "options": [
              {
                "id": "a",
                "text": "current_sum < 0"
              },
              {
                "id": "b",
                "text": "nums[i] < 0"
              },
              {
                "id": "c",
                "text": "current_sum > nums[i]"
              },
              {
                "id": "d",
                "text": "Always true"
              }
            ],
            "correct": "a",
            "explanation": "Subtract nums[i] from both sides: current_sum < 0.",
            "conceptId": "kadane"
          },
          {
            "type": "mcq",
            "question": "We need to track:",
            "options": [
              {
                "id": "a",
                "text": "Current running sum"
              },
              {
                "id": "b",
                "text": "Maximum sum seen so far"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Current sum for building subarray, max sum for the answer.",
            "conceptId": "kadane"
          },
          {
            "type": "mcq",
            "question": "For [-3, -1, -2]:",
            "options": [
              {
                "id": "a",
                "text": "Return 0"
              },
              {
                "id": "b",
                "text": "Return -1 (largest single element)"
              },
              {
                "id": "c",
                "text": "Return -6"
              },
              {
                "id": "d",
                "text": "Return empty"
              }
            ],
            "correct": "b",
            "explanation": "Must have at least one element. Best is the largest (least negative).",
            "conceptId": "kadane"
          }
        ],
        "oneLiner": "Kadane's: current_sum = max(nums[i], current_sum + nums[i]). If current sum is negative, start fresh.",
        "pattern": "Greedy",
        "keyInsight": "Kadane's Algorithm: If current sum becomes negative, start fresh.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "maximum subarray",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        # Either extend current subarray or start new\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"
      },
      {
        "id": "02-jump-game",
        "slug": "jump-game",
        "title": "Jump Game",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "jump-game"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` if you can reach the last index, or `false` otherwise.",
        "examples": [
          {
            "input": "nums = [2,3,1,1,4]",
            "output": "true",
            "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
          },
          {
            "input": "nums = [3,2,1,0,4]",
            "output": "false",
            "explanation": "You will always arrive at index 3 whose value is 0."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At position i, you can jump to:",
            "options": [
              {
                "id": "a",
                "text": "Exactly i + nums[i]"
              },
              {
                "id": "b",
                "text": "Any position from i+1 to i + nums[i]"
              },
              {
                "id": "c",
                "text": "Only i + 1"
              },
              {
                "id": "d",
                "text": "Anywhere"
              }
            ],
            "correct": "b",
            "explanation": "nums[i] is MAXIMUM jump. You can jump 1, 2, ..., up to nums[i] steps.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We greedily track:",
            "options": [
              {
                "id": "a",
                "text": "Number of jumps"
              },
              {
                "id": "b",
                "text": "Farthest reachable index"
              },
              {
                "id": "c",
                "text": "Current position"
              },
              {
                "id": "d",
                "text": "All reachable positions"
              }
            ],
            "correct": "b",
            "explanation": "If farthest_reachable >= last_index, we can reach the end.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "At position i, update farthest to:",
            "options": [
              {
                "id": "a",
                "text": "i + nums[i]"
              },
              {
                "id": "b",
                "text": "max(farthest, i + nums[i])"
              },
              {
                "id": "c",
                "text": "farthest + nums[i]"
              },
              {
                "id": "d",
                "text": "nums[i]"
              }
            ],
            "correct": "b",
            "explanation": "Farthest is the max of previous farthest and what we can reach from i.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We can't reach the end if:",
            "options": [
              {
                "id": "a",
                "text": "nums[i] = 0 at some point"
              },
              {
                "id": "b",
                "text": "i > farthest (we can't reach position i)"
              },
              {
                "id": "c",
                "text": "nums contains negative"
              },
              {
                "id": "d",
                "text": "Array is empty"
              }
            ],
            "correct": "b",
            "explanation": "If current position i is beyond farthest reachable, we're stuck.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We can return True early when:",
            "options": [
              {
                "id": "a",
                "text": "We see a large number"
              },
              {
                "id": "b",
                "text": "farthest >= last_index"
              },
              {
                "id": "c",
                "text": "We're past the midpoint"
              },
              {
                "id": "d",
                "text": "Never"
              }
            ],
            "correct": "b",
            "explanation": "If we can already reach or exceed the last index, we're done.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Track farthest reachable index. At each i, update farthest = max(farthest, i + nums[i]). If i > farthest, stuck.",
        "pattern": "Greedy",
        "keyInsight": "Track the farthest index you can reach. If you ever land on a position beyond your reach, return false.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "jump game",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def canJump(nums: List[int]) -> bool:\n    farthest = 0\n    \n    for i in range(len(nums)):\n        # Can't reach position i\n        if i > farthest:\n            return False\n        \n        farthest = max(farthest, i + nums[i])\n        \n        # Can reach the end\n        if farthest >= len(nums) - 1:\n            return True\n    \n    return True"
      },
      {
        "id": "03-jump-game-ii",
        "slug": "jump-game-ii",
        "title": "Jump Game II",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "jump-game-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a 0-indexed array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. Return the minimum number of jumps to reach `nums[n - 1]`.\n\nYou can assume that you can always reach `nums[n - 1]`.",
        "examples": [
          {
            "input": "nums = [2,3,1,1,4]",
            "output": "2",
            "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
          },
          {
            "input": "nums = [2,3,0,1,4]",
            "output": "2",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "This problem is like BFS where:",
            "options": [
              {
                "id": "a",
                "text": "Each position is a node"
              },
              {
                "id": "b",
                "text": "Jump count is the \"level\""
              },
              {
                "id": "c",
                "text": "We find shortest path to last index"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "BFS gives shortest path. \"Levels\" are positions reachable with same jump count.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We track:",
            "options": [
              {
                "id": "a",
                "text": "Current jump boundary (end of current level)"
              },
              {
                "id": "b",
                "text": "Farthest reachable in next level"
              },
              {
                "id": "c",
                "text": "Number of jumps"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Boundary tells when to increment jumps. Farthest becomes new boundary.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We increment jump count when:",
            "options": [
              {
                "id": "a",
                "text": "We see a large nums[i]"
              },
              {
                "id": "b",
                "text": "We reach the current boundary"
              },
              {
                "id": "c",
                "text": "nums[i] = 0"
              },
              {
                "id": "d",
                "text": "We're at odd index"
              }
            ],
            "correct": "b",
            "explanation": "Passing the boundary means we need another jump to go further.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "While traversing, farthest is updated to:",
            "options": [
              {
                "id": "a",
                "text": "max(farthest, i + nums[i])"
              },
              {
                "id": "b",
                "text": "i + nums[i] always"
              },
              {
                "id": "c",
                "text": "farthest + 1"
              },
              {
                "id": "d",
                "text": "end + nums[end]"
              }
            ],
            "correct": "a",
            "explanation": "Track the farthest we can reach from any position in current level.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We iterate i from 0 to:",
            "options": [
              {
                "id": "a",
                "text": "n - 1 (inclusive)"
              },
              {
                "id": "b",
                "text": "n - 2 (up to second-to-last)"
              },
              {
                "id": "c",
                "text": "n"
              },
              {
                "id": "d",
                "text": "Farthest"
              }
            ],
            "correct": "b",
            "explanation": "Don't need to process last index. If we reach it, we're done.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "BFS-like greedy: track current level's boundary. When you hit boundary, increment jumps and set new boundary to farthest reachable.",
        "pattern": "Greedy",
        "keyInsight": "BFS-like greedy: each \"level\" is all positions reachable with same number of jumps.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "jump game ii",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def jump(nums: List[int]) -> int:\n    n = len(nums)\n    if n <= 1:\n        return 0\n    \n    jumps = 0\n    end = 0       # Current level boundary\n    farthest = 0  # Farthest reachable in next level\n    \n    for i in range(n - 1):  # Don't need to process last index\n        farthest = max(farthest, i + nums[i])\n        \n        if i == end:  # Hit boundary, need another jump\n            jumps += 1\n            end = farthest\n    \n    return jumps"
      },
      {
        "id": "04-gas-station",
        "slug": "gas-station",
        "title": "Gas Station",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "gas-station"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return `-1`. If there exists a solution, it is guaranteed to be unique.",
        "examples": [
          {
            "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
            "output": "3",
            "explanation": "Start at station 3, tank = 4. Travel to station 4, tank = 4-1+5 = 8. Continue around."
          },
          {
            "input": "gas = [2,3,4], cost = [3,4,3]",
            "output": "-1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A solution exists if:",
            "options": [
              {
                "id": "a",
                "text": "gas[0] >= cost[0]"
              },
              {
                "id": "b",
                "text": "total_gas >= total_cost"
              },
              {
                "id": "c",
                "text": "max(gas) >= max(cost)"
              },
              {
                "id": "d",
                "text": "All gas[i] >= cost[i]"
              }
            ],
            "correct": "b",
            "explanation": "If total gas can cover total cost, you can complete the circuit from some starting point.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "At station i, the net effect is:",
            "options": [
              {
                "id": "a",
                "text": "gas[i] - cost[i]"
              },
              {
                "id": "b",
                "text": "gas[i] + cost[i]"
              },
              {
                "id": "c",
                "text": "gas[i] / cost[i]"
              },
              {
                "id": "d",
                "text": "cost[i] - gas[i]"
              }
            ],
            "correct": "a",
            "explanation": "You gain gas[i] but spend cost[i] to reach next station.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "If starting from station i, you can't reach station j (tank < 0):",
            "options": [
              {
                "id": "a",
                "text": "Try starting from i + 1"
              },
              {
                "id": "b",
                "text": "Station i is bad, try others"
              },
              {
                "id": "c",
                "text": "No station from i to j-1 can be the start"
              },
              {
                "id": "d",
                "text": "Start from j - 1"
              }
            ],
            "correct": "c",
            "explanation": "If you can't reach j from i with accumulated gas, you can't reach j from any station between i and j (you'd have less gas).",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When tank goes negative at station j:",
            "options": [
              {
                "id": "a",
                "text": "Start = j + 1, reset tank"
              },
              {
                "id": "b",
                "text": "Start = j, add more gas"
              },
              {
                "id": "c",
                "text": "Return -1 immediately"
              },
              {
                "id": "d",
                "text": "Skip station j"
              }
            ],
            "correct": "a",
            "explanation": "j and all stations before it in current attempt can't be the start. Try j+1.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "One pass is sufficient because:",
            "options": [
              {
                "id": "a",
                "text": "If total_gas >= total_cost, a valid start exists"
              },
              {
                "id": "b",
                "text": "We eliminate impossible starts greedily"
              },
              {
                "id": "c",
                "text": "The first valid start we find works"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Total check ensures solution. Greedy elimination finds it.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "If total_gas >= total_cost, solution exists. Greedily start from next station whenever tank goes negative. The last valid start is the answer.",
        "pattern": "Greedy",
        "keyInsight": "If total gas >= total cost, solution exists. If you can't reach station j from station i, start from j+1.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "gas station",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    # Check if solution exists\n    if sum(gas) < sum(cost):\n        return -1\n    \n    start = 0\n    tank = 0\n    \n    for i in range(len(gas)):\n        tank += gas[i] - cost[i]\n        \n        if tank < 0:  # Can't reach next station\n            start = i + 1  # Try starting from next\n            tank = 0\n    \n    return start"
      },
      {
        "id": "05-hand-of-straights",
        "slug": "hand-of-straights",
        "title": "Hand of Straights",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "hand-of-straights"
        ],
        "estimatedTime": 5,
        "problemStatement": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size `groupSize`, and consists of `groupSize` consecutive cards.\n\nGiven an integer array `hand` where `hand[i]` is the value written on the `ith` card and an integer `groupSize`, return `true` if she can rearrange the cards, or `false` otherwise.",
        "examples": [
          {
            "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
            "output": "true",
            "explanation": "[1,2,3], [2,3,4], [6,7,8]"
          },
          {
            "input": "hand = [1,2,3,4,5], groupSize = 4",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If len(hand) % groupSize != 0:",
            "options": [
              {
                "id": "a",
                "text": "Might still work"
              },
              {
                "id": "b",
                "text": "Definitely impossible"
              },
              {
                "id": "c",
                "text": "Always possible"
              },
              {
                "id": "d",
                "text": "Need more info"
              }
            ],
            "correct": "b",
            "explanation": "Can't divide cards evenly into groups.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "The smallest card must:",
            "options": [
              {
                "id": "a",
                "text": "Be skipped sometimes"
              },
              {
                "id": "b",
                "text": "Start some group"
              },
              {
                "id": "c",
                "text": "End some group"
              },
              {
                "id": "d",
                "text": "Be in the middle"
              }
            ],
            "correct": "b",
            "explanation": "No smaller card exists to have it continue a sequence. It must be a group's start.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "Best data structure for this problem:",
            "options": [
              {
                "id": "a",
                "text": "Array"
              },
              {
                "id": "b",
                "text": "Hash map (count of each card)"
              },
              {
                "id": "c",
                "text": "Linked list"
              },
              {
                "id": "d",
                "text": "Binary tree"
              }
            ],
            "correct": "b",
            "explanation": "Need to track how many of each card remain, efficiently check and decrement.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "We should process cards:",
            "options": [
              {
                "id": "a",
                "text": "In any order"
              },
              {
                "id": "b",
                "text": "In sorted order (smallest first)"
              },
              {
                "id": "c",
                "text": "Largest first"
              },
              {
                "id": "d",
                "text": "Random order"
              }
            ],
            "correct": "b",
            "explanation": "Smallest must start a group. After using it, the next smallest becomes the new \"must start\".",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When starting a group at card x:",
            "options": [
              {
                "id": "a",
                "text": "Need exactly x, x+1, ..., x+groupSize-1"
              },
              {
                "id": "b",
                "text": "Any groupSize cards work"
              },
              {
                "id": "c",
                "text": "Need x and any larger cards"
              },
              {
                "id": "d",
                "text": "Need x repeated groupSize times"
              }
            ],
            "correct": "a",
            "explanation": "Consecutive means exactly x, x+1, x+2, etc.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Greedy: smallest card must start a group. Process sorted cards, form groups of consecutive numbers, decrement counts. Fail if any needed card is missing.",
        "pattern": "Greedy",
        "keyInsight": "Greedy: always start a group with the smallest available card.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "hand of straights",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isNStraightHand(hand: List[int], groupSize: int) -> bool:\n    if len(hand) % groupSize != 0:\n        return False\n    \n    count = Counter(hand)\n    \n    for card in sorted(count):\n        if count[card] > 0:  # Start a group\n            need = count[card]\n            # Need consecutive cards\n            for i in range(groupSize):\n                if count[card + i] < need:\n                    return False\n                count[card + i] -= need\n    \n    return True"
      },
      {
        "id": "06-merge-triplets-to-form-target-triplet",
        "slug": "merge-triplets-to-form-target-triplet",
        "title": "Merge Triplets to Form Target Triplet",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "merge-triplets-to-form-target-triplet"
        ],
        "estimatedTime": 5,
        "problemStatement": "A triplet is an array of three integers. You are given a 2D integer array `triplets`, where `triplets[i] = [ai, bi, ci]` describes the `ith` triplet. You are also given an integer array `target = [x, y, z]` that describes the triplet you want to obtain.\n\nTo obtain `target`, you may apply the following operation on `triplets` any number of times:\n\nChoose two indices `i` and `j` (i != j) and update `triplets[j]` to become `[max(ai, aj), max(bi, bj), max(ci, cj)]`.\n\nReturn `true` if it is possible to obtain the `target` triplet `[x, y, z]` as an element of `triplets`, or `false` otherwise.",
        "examples": [
          {
            "input": "triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]",
            "output": "true",
            "explanation": "Merge triplets[0] and triplets[2]: [max(2,1), max(5,7), max(3,5)] = [2,7,5]"
          },
          {
            "input": "triplets = [[3,4,5],[4,5,6]], target = [3,2,5]",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "After taking max of two triplets:",
            "options": [
              {
                "id": "a",
                "text": "Values can only increase or stay same"
              },
              {
                "id": "b",
                "text": "Values can decrease"
              },
              {
                "id": "c",
                "text": "Values are averaged"
              },
              {
                "id": "d",
                "text": "Values are summed"
              }
            ],
            "correct": "a",
            "explanation": "max(a, b) >= a and max(a, b) >= b. Values never decrease.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "A triplet [a, b, c] is unusable if:",
            "options": [
              {
                "id": "a",
                "text": "Any value exceeds corresponding target"
              },
              {
                "id": "b",
                "text": "Sum exceeds target sum"
              },
              {
                "id": "c",
                "text": "All values are smaller"
              },
              {
                "id": "d",
                "text": "Any value equals target"
              }
            ],
            "correct": "a",
            "explanation": "If a > target[0], using this triplet will make result[0] > target[0], which we can never reduce.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We need to find valid triplets that together:",
            "options": [
              {
                "id": "a",
                "text": "Cover all target values exactly"
              },
              {
                "id": "b",
                "text": "Sum to target"
              },
              {
                "id": "c",
                "text": "Have same length as target"
              },
              {
                "id": "d",
                "text": "Are consecutive"
              }
            ],
            "correct": "a",
            "explanation": "We need some triplet with value = target[0], some with = target[1], some with = target[2].",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "For each valid triplet, we track:",
            "options": [
              {
                "id": "a",
                "text": "Which target positions it matches exactly"
              },
              {
                "id": "b",
                "text": "Its sum"
              },
              {
                "id": "c",
                "text": "Its average"
              },
              {
                "id": "d",
                "text": "Its index"
              }
            ],
            "correct": "a",
            "explanation": "If triplet[i] == target[i], this triplet can \"contribute\" that target value.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We succeed if:",
            "options": [
              {
                "id": "a",
                "text": "One triplet matches all"
              },
              {
                "id": "b",
                "text": "Valid triplets together cover all 3 positions"
              },
              {
                "id": "c",
                "text": "We have 3 triplets"
              },
              {
                "id": "d",
                "text": "Average matches target"
              }
            ],
            "correct": "b",
            "explanation": "Collectively, valid triplets must have each target value achievable.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Filter triplets where ALL values ≤ target (usable). Among usable ones, check if we can find each target value exactly. Max never decreases values.",
        "pattern": "Greedy",
        "keyInsight": "A triplet is usable only if ALL its values are ≤ corresponding target values.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "merge triplets to form target triplet",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def mergeTriplets(triplets: List[List[int]], target: List[int]) -> bool:\n    found = [False, False, False]\n    \n    for triplet in triplets:\n        # Skip if any value exceeds target\n        if triplet[0] > target[0] or triplet[1] > target[1] or triplet[2] > target[2]:\n            continue\n        \n        # Mark which target values this triplet can contribute\n        for i in range(3):\n            if triplet[i] == target[i]:\n                found[i] = True\n    \n    return all(found)"
      },
      {
        "id": "07-partition-labels",
        "slug": "partition-labels",
        "title": "Partition Labels",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "partition-labels"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn a list of integers representing the size of these parts.",
        "examples": [
          {
            "input": "s = \"ababcbacadefegdehijhklij\"",
            "output": "[9,7,8]",
            "explanation": "\"ababcbaca\", \"defegde\", \"hijhklij\""
          },
          {
            "input": "s = \"eccbbbbdec\"",
            "output": "[10]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If partition contains character 'a', it must:",
            "options": [
              {
                "id": "a",
                "text": "Start with 'a'"
              },
              {
                "id": "b",
                "text": "End with 'a'"
              },
              {
                "id": "c",
                "text": "Contain ALL occurrences of 'a'"
              },
              {
                "id": "d",
                "text": "Have 'a' in the middle"
              }
            ],
            "correct": "c",
            "explanation": "Each character appears in at most one part, so all its occurrences must be together.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "For each character, we need:",
            "options": [
              {
                "id": "a",
                "text": "First occurrence"
              },
              {
                "id": "b",
                "text": "Last occurrence"
              },
              {
                "id": "c",
                "text": "Count"
              },
              {
                "id": "d",
                "text": "ASCII value"
              }
            ],
            "correct": "b",
            "explanation": "Partition containing a character must extend at least to its last occurrence.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "As we traverse, we extend current partition to:",
            "options": [
              {
                "id": "a",
                "text": "First occurrence of current char"
              },
              {
                "id": "b",
                "text": "Last occurrence of current char"
              },
              {
                "id": "c",
                "text": "Next character"
              },
              {
                "id": "d",
                "text": "End of string"
              }
            ],
            "correct": "b",
            "explanation": "If we see char c, we must include everything up to c's last occurrence.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We can close the current partition when:",
            "options": [
              {
                "id": "a",
                "text": "We see a new character"
              },
              {
                "id": "b",
                "text": "Current index equals the partition's farthest required extent"
              },
              {
                "id": "c",
                "text": "We've seen all characters"
              },
              {
                "id": "d",
                "text": "At every index"
              }
            ],
            "correct": "b",
            "explanation": "If i == end, all characters in this partition have been fully included.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "The partition end is updated to:",
            "options": [
              {
                "id": "a",
                "text": "last[s[i]]"
              },
              {
                "id": "b",
                "text": "max(end, last[s[i]])"
              },
              {
                "id": "c",
                "text": "min(end, last[s[i]])"
              },
              {
                "id": "d",
                "text": "last[s[i]] + 1"
              }
            ],
            "correct": "b",
            "explanation": "End grows to accommodate all characters. Take max with current end.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Track last occurrence of each char. Extend partition end to max(end, last[current_char]). When index equals end, close partition.",
        "pattern": "Greedy",
        "keyInsight": "A partition must include ALL occurrences of any character it contains.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "partition labels",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def partitionLabels(s: str) -> List[int]:\n    # Find last occurrence of each character\n    last = {c: i for i, c in enumerate(s)}\n    \n    result = []\n    start = 0\n    end = 0\n    \n    for i, c in enumerate(s):\n        end = max(end, last[c])  # Extend partition\n        \n        if i == end:  # All chars in partition fully included\n            result.append(end - start + 1)\n            start = i + 1\n    \n    return result"
      },
      {
        "id": "08-valid-parenthesis-string",
        "slug": "valid-parenthesis-string",
        "title": "Valid Parenthesis String",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "valid-parenthesis-string"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s` containing only three types of characters: `'('`, `')'` and `'*'`, return `true` if `s` is valid.\n\nThe following rules define a valid string:\n- Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.\n- Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.\n- Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.\n- `'*'` could be treated as a single right parenthesis `')'` OR a single left parenthesis `'('` OR an empty string `\"\"`.",
        "examples": [
          {
            "input": "s = \"()\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"(*)\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"(*))\"",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We track a range [low, high] because:",
            "options": [
              {
                "id": "a",
                "text": "* can be (, ), or empty → multiple possibilities"
              },
              {
                "id": "b",
                "text": "We need exactly two values"
              },
              {
                "id": "c",
                "text": "It's more efficient"
              },
              {
                "id": "d",
                "text": "Standard approach for all problems"
              }
            ],
            "correct": "a",
            "explanation": "At any point, open count could be anywhere in a range depending on * choices.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When we see '(':",
            "options": [
              {
                "id": "a",
                "text": "low++, high++"
              },
              {
                "id": "b",
                "text": "low--, high--"
              },
              {
                "id": "c",
                "text": "low--, high++"
              },
              {
                "id": "d",
                "text": "Only high++"
              }
            ],
            "correct": "a",
            "explanation": "'(' definitely adds one open parenthesis.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When we see ')':",
            "options": [
              {
                "id": "a",
                "text": "low++, high++"
              },
              {
                "id": "b",
                "text": "low--, high--"
              },
              {
                "id": "c",
                "text": "low--, high++"
              },
              {
                "id": "d",
                "text": "Only low--"
              }
            ],
            "correct": "b",
            "explanation": "')' definitely closes one parenthesis.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When we see '*':",
            "options": [
              {
                "id": "a",
                "text": "low++, high++"
              },
              {
                "id": "b",
                "text": "low--, high--"
              },
              {
                "id": "c",
                "text": "low--, high++"
              },
              {
                "id": "d",
                "text": "No change"
              }
            ],
            "correct": "c",
            "explanation": "* as ')' decreases open count (low--), * as '(' increases it (high++).",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "String is valid if:",
            "options": [
              {
                "id": "a",
                "text": "high >= 0 always (not too many closing)"
              },
              {
                "id": "b",
                "text": "low <= 0 at end (can balance opens)   (after clamping low to 0)"
              },
              {
                "id": "c",
                "text": "low == 0 at end"
              },
              {
                "id": "d",
                "text": "A and C"
              }
            ],
            "correct": "d",
            "explanation": "If high < 0, too many ')'. At end, low must be 0 (all opens matched).",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Track [low, high] range of possible open counts. '(' increases both, ')' decreases both, '*' does both. If high < 0, fail. At end, low must be 0.",
        "pattern": "Greedy",
        "keyInsight": "Track range of possible open parentheses counts [low, high].",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "valid parenthesis string",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def checkValidString(s: str) -> bool:\n    low = 0   # Minimum possible open count\n    high = 0  # Maximum possible open count\n    \n    for c in s:\n        if c == '(':\n            low += 1\n            high += 1\n        elif c == ')':\n            low -= 1\n            high -= 1\n        else:  # '*'\n            low -= 1   # Treat as ')'\n            high += 1  # Treat as '('\n        \n        # Too many closing parens\n        if high < 0:\n            return False\n        \n        # low can't go negative (we'd just treat * as empty)\n        low = max(low, 0)\n    \n    return low == 0"
      }
    ],
    "intervals": [
      {
        "id": "01-insert-interval",
        "slug": "insert-interval",
        "title": "Insert Interval",
        "category": "intervals",
        "difficulty": "medium",
        "tags": [
          "intervals",
          "insert-interval"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.\n\nInsert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still has no overlapping intervals (merge overlapping intervals if necessary).\n\nReturn `intervals` after the insertion.",
        "examples": [
          {
            "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
            "output": "[[1,5],[6,9]]",
            "explanation": ""
          },
          {
            "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
            "output": "[[1,2],[3,10],[12,16]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Interval [a, b] is completely before newInterval [x, y] if:",
            "options": [
              {
                "id": "a",
                "text": "a < x"
              },
              {
                "id": "b",
                "text": "b < x"
              },
              {
                "id": "c",
                "text": "a < y"
              },
              {
                "id": "d",
                "text": "b < y"
              }
            ],
            "correct": "b",
            "explanation": "If interval ends before new starts, no overlap. Add to result as-is.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Interval [a, b] is completely after newInterval [x, y] if:",
            "options": [
              {
                "id": "a",
                "text": "a > y"
              },
              {
                "id": "b",
                "text": "b > y"
              },
              {
                "id": "c",
                "text": "a > x"
              },
              {
                "id": "d",
                "text": "b > x"
              }
            ],
            "correct": "a",
            "explanation": "If interval starts after new ends, no overlap. Add to result as-is.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Interval [a, b] overlaps with [x, y] if:",
            "options": [
              {
                "id": "a",
                "text": "a <= y AND b >= x"
              },
              {
                "id": "b",
                "text": "a < y AND b > x"
              },
              {
                "id": "c",
                "text": "a == x OR b == y"
              },
              {
                "id": "d",
                "text": "a <= x AND b >= y"
              }
            ],
            "correct": "a",
            "explanation": "Overlap when neither is completely before nor after the other.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "When merging [a, b] into [x, y]:",
            "options": [
              {
                "id": "a",
                "text": "new_start = min(a, x), new_end = max(b, y)"
              },
              {
                "id": "b",
                "text": "new_start = a, new_end = y"
              },
              {
                "id": "c",
                "text": "new_start = x, new_end = b"
              },
              {
                "id": "d",
                "text": "new_start = max(a, x), new_end = min(b, y)"
              }
            ],
            "correct": "a",
            "explanation": "Merged interval spans from earliest start to latest end.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "We process intervals:",
            "options": [
              {
                "id": "a",
                "text": "In any order"
              },
              {
                "id": "b",
                "text": "By start time (given sorted)"
              },
              {
                "id": "c",
                "text": "By end time"
              },
              {
                "id": "d",
                "text": "By length"
              }
            ],
            "correct": "b",
            "explanation": "Input is sorted by start. Process linearly: before, overlap, after.",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Three phases: (1) add intervals ending before new starts, (2) merge all overlapping intervals with new, (3) add intervals starting after new ends.",
        "pattern": "Intervals",
        "keyInsight": "Three phases: intervals before new (no overlap), merge with new (overlap), intervals after new (no overlap).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "insert interval",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n    result = []\n    i = 0\n    n = len(intervals)\n    \n    # Phase 1: Add intervals ending before newInterval starts\n    while i < n and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    # Phase 2: Merge overlapping intervals\n    while i < n and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    result.append(newInterval)\n    \n    # Phase 3: Add remaining intervals\n    while i < n:\n        result.append(intervals[i])\n        i += 1\n    \n    return result"
      },
      {
        "id": "02-merge-intervals",
        "slug": "merge-intervals",
        "title": "Merge Intervals",
        "category": "intervals",
        "difficulty": "medium",
        "tags": [
          "intervals",
          "merge-intervals"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
        "examples": [
          {
            "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
            "output": "[[1,6],[8,10],[15,18]]",
            "explanation": "[1,3] and [2,6] overlap, merge into [1,6]."
          },
          {
            "input": "intervals = [[1,4],[4,5]]",
            "output": "[[1,5]]",
            "explanation": "[1,4] and [4,5] overlap (touch at 4)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Sorting by start time ensures:",
            "options": [
              {
                "id": "a",
                "text": "Overlapping intervals become adjacent"
              },
              {
                "id": "b",
                "text": "Faster merging"
              },
              {
                "id": "c",
                "text": "No duplicates"
              },
              {
                "id": "d",
                "text": "Smaller output"
              }
            ],
            "correct": "a",
            "explanation": "If sorted by start, interval can only overlap with its predecessor in result.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "After sorting, [a, b] overlaps with [c, d] (where c >= a) if:",
            "options": [
              {
                "id": "a",
                "text": "a <= d"
              },
              {
                "id": "b",
                "text": "b >= c"
              },
              {
                "id": "c",
                "text": "a == c"
              },
              {
                "id": "d",
                "text": "b == d"
              }
            ],
            "correct": "b",
            "explanation": "Since intervals are sorted, c >= a. Overlap if previous end >= current start.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "When merging [a, b] with overlapping [c, d]:",
            "options": [
              {
                "id": "a",
                "text": "[a, max(b, d)]"
              },
              {
                "id": "b",
                "text": "[min(a, c), max(b, d)]"
              },
              {
                "id": "c",
                "text": "[a, d]"
              },
              {
                "id": "d",
                "text": "[c, b]"
              }
            ],
            "correct": "a",
            "explanation": "Since sorted, a <= c. So start is a. End is the farther of b and d.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Start a new merged interval when:",
            "options": [
              {
                "id": "a",
                "text": "Current doesn't overlap with result's last"
              },
              {
                "id": "b",
                "text": "Current has larger start"
              },
              {
                "id": "c",
                "text": "Current is longer"
              },
              {
                "id": "d",
                "text": "At even indices"
              }
            ],
            "correct": "a",
            "explanation": "No overlap means current interval is separate. Add it to result.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "[1,4] and [4,5] should:",
            "options": [
              {
                "id": "a",
                "text": "Remain separate"
              },
              {
                "id": "b",
                "text": "Merge to [1,5]"
              },
              {
                "id": "c",
                "text": "Error"
              },
              {
                "id": "d",
                "text": "Depends"
              }
            ],
            "correct": "b",
            "explanation": "They touch at 4. Typically treated as overlapping (b >= c means 4 >= 4).",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Sort by start. For each interval, if it overlaps with result's last (start <= last_end), merge. Otherwise, add new.",
        "pattern": "Intervals",
        "keyInsight": "Sort by start time. Then merge consecutive intervals if they overlap.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "merge intervals",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def merge(intervals: List[List[int]]) -> List[List[int]]:\n    if not intervals:\n        return []\n    \n    # Sort by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    result = [intervals[0]]\n    \n    for i in range(1, len(intervals)):\n        # If overlaps with last in result\n        if intervals[i][0] <= result[-1][1]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n    \n    return result"
      },
      {
        "id": "03-non-overlapping-intervals",
        "slug": "non-overlapping-intervals",
        "title": "Non-overlapping Intervals",
        "category": "intervals",
        "difficulty": "medium",
        "tags": [
          "intervals",
          "non-overlapping-intervals"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.",
        "examples": [
          {
            "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
            "output": "1",
            "explanation": "Remove [1,3] to make the rest non-overlapping."
          },
          {
            "input": "intervals = [[1,2],[1,2],[1,2]]",
            "output": "2",
            "explanation": ""
          },
          {
            "input": "intervals = [[1,2],[2,3]]",
            "output": "0",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Minimum removals = n - maximum non-overlapping. This is:",
            "options": [
              {
                "id": "a",
                "text": "Dynamic programming"
              },
              {
                "id": "b",
                "text": "Activity selection problem"
              },
              {
                "id": "c",
                "text": "Graph problem"
              },
              {
                "id": "d",
                "text": "String matching"
              }
            ],
            "correct": "b",
            "explanation": "Classic greedy activity selection. Maximize intervals we can keep.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "Sorting by end time:",
            "options": [
              {
                "id": "a",
                "text": "Groups overlapping intervals"
              },
              {
                "id": "b",
                "text": "Ensures we leave maximum room for future intervals"
              },
              {
                "id": "c",
                "text": "Is required for correctness"
              },
              {
                "id": "d",
                "text": "Makes code simpler"
              }
            ],
            "correct": "b",
            "explanation": "Picking interval that ends earliest leaves most time for remaining intervals.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When intervals overlap, we should remove:",
            "options": [
              {
                "id": "a",
                "text": "The one that starts first"
              },
              {
                "id": "b",
                "text": "The one that ends later"
              },
              {
                "id": "c",
                "text": "The shorter one"
              },
              {
                "id": "d",
                "text": "Random choice"
              }
            ],
            "correct": "b",
            "explanation": "Interval ending later \"blocks\" more future intervals. Remove it.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "After sorting by end, [a, b] overlaps with [c, d] if:",
            "options": [
              {
                "id": "a",
                "text": "c < b"
              },
              {
                "id": "b",
                "text": "c <= b"
              },
              {
                "id": "c",
                "text": "d > b"
              },
              {
                "id": "d",
                "text": "a < d"
              }
            ],
            "correct": "a",
            "explanation": "If next interval starts before current ends, they overlap. (Using strict < since [1,2],[2,3] don't overlap)",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "While iterating, we track:",
            "options": [
              {
                "id": "a",
                "text": "Last interval's start"
              },
              {
                "id": "b",
                "text": "Last interval's end (of kept intervals)"
              },
              {
                "id": "c",
                "text": "Number of removals"
              },
              {
                "id": "d",
                "text": "All intervals"
              }
            ],
            "correct": "b",
            "explanation": "Compare next interval's start with last kept interval's end.",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Activity selection: sort by end time. Greedily keep intervals that don't overlap with the last kept one. Removals = n - kept.",
        "pattern": "Intervals",
        "keyInsight": "Equivalent to: find maximum number of non-overlapping intervals (activity selection).",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "non-overlapping intervals",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def eraseOverlapIntervals(intervals: List[List[int]]) -> int:\n    if not intervals:\n        return 0\n    \n    # Sort by end time (activity selection)\n    intervals.sort(key=lambda x: x[1])\n    \n    kept = 1\n    end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] >= end:  # No overlap\n            kept += 1\n            end = intervals[i][1]\n    \n    return len(intervals) - kept"
      },
      {
        "id": "04-meeting-rooms",
        "slug": "meeting-rooms",
        "title": "Meeting Rooms",
        "category": "intervals",
        "difficulty": "easy",
        "tags": [
          "intervals",
          "meeting-rooms"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of meeting time intervals where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.",
        "examples": [
          {
            "input": "intervals = [[0,30],[5,10],[15,20]]",
            "output": "false",
            "explanation": "[0,30] overlaps with [5,10] and [15,20]."
          },
          {
            "input": "intervals = [[7,10],[2,4]]",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A person can attend all meetings if:",
            "options": [
              {
                "id": "a",
                "text": "Total meeting time < 24 hours"
              },
              {
                "id": "b",
                "text": "No two meetings overlap"
              },
              {
                "id": "c",
                "text": "Meetings are sorted"
              },
              {
                "id": "d",
                "text": "All meetings are short"
              }
            ],
            "correct": "b",
            "explanation": "Can't be in two places at once. No overlaps means all are attendable.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "After sorting by start time, we only need to check:",
            "options": [
              {
                "id": "a",
                "text": "First and last meetings"
              },
              {
                "id": "b",
                "text": "Consecutive pairs of meetings"
              },
              {
                "id": "c",
                "text": "All pairs"
              },
              {
                "id": "d",
                "text": "Random pairs"
              }
            ],
            "correct": "b",
            "explanation": "If sorted, meeting i can only overlap with i+1. If i overlaps with j (j > i+1), it must overlap with i+1 first.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Sorted meetings [a, b] and [c, d] (where a <= c) overlap if:",
            "options": [
              {
                "id": "a",
                "text": "b > c"
              },
              {
                "id": "b",
                "text": "b >= c"
              },
              {
                "id": "c",
                "text": "a < d"
              },
              {
                "id": "d",
                "text": "b == c"
              }
            ],
            "correct": "a",
            "explanation": "If meeting 1 ends after meeting 2 starts, overlap. (b > c, not >=, since [1,2],[2,3] don't overlap)",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "If we find one pair of overlapping meetings:",
            "options": [
              {
                "id": "a",
                "text": "Check more pairs"
              },
              {
                "id": "b",
                "text": "Return false immediately"
              },
              {
                "id": "c",
                "text": "Try to reschedule"
              },
              {
                "id": "d",
                "text": "Count overlaps"
              }
            ],
            "correct": "b",
            "explanation": "One overlap is enough to fail. Can't attend both.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "If 0 or 1 meetings:",
            "options": [
              {
                "id": "a",
                "text": "Return false"
              },
              {
                "id": "b",
                "text": "Return true"
              },
              {
                "id": "c",
                "text": "Error"
              },
              {
                "id": "d",
                "text": "Depends"
              }
            ],
            "correct": "b",
            "explanation": "No meetings or one meeting means no possible conflicts.",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Sort by start time. Check if any meeting starts before the previous ends. One overlap = can't attend all.",
        "pattern": "Intervals",
        "keyInsight": "Sort by start time. Check if any meeting starts before the previous one ends.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "meeting rooms",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def canAttendMeetings(intervals: List[List[int]]) -> bool:\n    if len(intervals) <= 1:\n        return True\n    \n    # Sort by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    for i in range(1, len(intervals)):\n        # If current starts before previous ends\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n    \n    return True"
      },
      {
        "id": "05-meeting-rooms-ii",
        "slug": "meeting-rooms-ii",
        "title": "Meeting Rooms II",
        "category": "intervals",
        "difficulty": "medium",
        "tags": [
          "intervals",
          "meeting-rooms-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.",
        "examples": [
          {
            "input": "intervals = [[0,30],[5,10],[15,20]]",
            "output": "2",
            "explanation": "[0,30] in room 1, [5,10] and [15,20] in room 2."
          },
          {
            "input": "intervals = [[7,10],[2,4]]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Minimum rooms needed equals:",
            "options": [
              {
                "id": "a",
                "text": "Total number of meetings"
              },
              {
                "id": "b",
                "text": "Maximum concurrent meetings at any time"
              },
              {
                "id": "c",
                "text": "Longest meeting"
              },
              {
                "id": "d",
                "text": "Number of overlaps"
              }
            ],
            "correct": "b",
            "explanation": "At peak concurrency, each meeting needs its own room.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "We treat starts and ends as:",
            "options": [
              {
                "id": "a",
                "text": "Two separate sorted arrays"
              },
              {
                "id": "b",
                "text": "Events on a timeline"
              },
              {
                "id": "c",
                "text": "Paired data"
              },
              {
                "id": "d",
                "text": "Weights"
              }
            ],
            "correct": "b",
            "explanation": "Start = +1 room needed. End = -1 room needed. Track running count.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "When a start and end are at same time:",
            "options": [
              {
                "id": "a",
                "text": "Process start first"
              },
              {
                "id": "b",
                "text": "Process end first"
              },
              {
                "id": "c",
                "text": "Doesn't matter"
              },
              {
                "id": "d",
                "text": "Skip both"
              }
            ],
            "correct": "b",
            "explanation": "If meeting ends at time t and another starts at t, same room can be reused. End frees room first.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Min-heap stores:",
            "options": [
              {
                "id": "a",
                "text": "Meeting start times"
              },
              {
                "id": "b",
                "text": "End times of active meetings"
              },
              {
                "id": "c",
                "text": "Meeting indices"
              },
              {
                "id": "d",
                "text": "Room numbers"
              }
            ],
            "correct": "b",
            "explanation": "Heap tracks when earliest active meeting ends. If new meeting starts after, reuse that room.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Add new room when:",
            "options": [
              {
                "id": "a",
                "text": "Heap is empty"
              },
              {
                "id": "b",
                "text": "New meeting starts before all current meetings end"
              },
              {
                "id": "c",
                "text": "Meeting is long"
              },
              {
                "id": "d",
                "text": "At every meeting"
              }
            ],
            "correct": "b",
            "explanation": "If start < heap.min (earliest end), can't reuse any room. Need new one.",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Sweep line: treat starts as +1, ends as -1. Max concurrent count = rooms needed. Or use min-heap of end times, reuse room if meeting ended.",
        "pattern": "Intervals",
        "keyInsight": "Sweep line: track starts and ends as events. Maximum concurrent meetings = minimum rooms needed.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "meeting rooms ii",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minMeetingRooms(intervals: List[List[int]]) -> int:\n    if not intervals:\n        return 0\n    \n    # Sweep line approach\n    events = []\n    for start, end in intervals:\n        events.append((start, 1))   # +1 room at start\n        events.append((end, -1))    # -1 room at end\n    \n    # Sort: by time, then ends before starts at same time\n    events.sort(key=lambda x: (x[0], x[1]))\n    \n    rooms = 0\n    max_rooms = 0\n    \n    for time, delta in events:\n        rooms += delta\n        max_rooms = max(max_rooms, rooms)\n    \n    return max_rooms"
      },
      {
        "id": "06-minimum-interval-to-include-each-query",
        "slug": "minimum-interval-to-include-each-query",
        "title": "Minimum Interval to Include Each Query",
        "category": "intervals",
        "difficulty": "hard",
        "tags": [
          "intervals",
          "minimum-interval-to-include-each-query"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a 2D integer array `intervals`, where `intervals[i] = [lefti, righti]` describes the `ith` interval starting at `lefti` and ending at `righti` (inclusive). The size of an interval is defined as the number of integers it contains, or more formally `righti - lefti + 1`.\n\nYou are also given an integer array `queries`. The answer to the `jth` query is the size of the smallest interval `i` such that `lefti <= queries[j] <= righti`. If no such interval exists, the answer is `-1`.\n\nReturn an array `answer` where `answer[j]` is the answer to the `jth` query.",
        "examples": [
          {
            "input": "intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",
            "output": "[3,3,1,4]",
            "explanation": ""
          },
          {
            "input": "intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",
            "output": "[2,-1,4,6]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Processing queries in sorted order:",
            "options": [
              {
                "id": "a",
                "text": "Required for correctness"
              },
              {
                "id": "b",
                "text": "Allows efficient interval management"
              },
              {
                "id": "c",
                "text": "Makes output sorted"
              },
              {
                "id": "d",
                "text": "Reduces space"
              }
            ],
            "correct": "b",
            "explanation": "Can add intervals as we move right, remove expired ones. Efficient sweeping.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "The min-heap stores:",
            "options": [
              {
                "id": "a",
                "text": "(start, end) pairs"
              },
              {
                "id": "b",
                "text": "(size, end) pairs"
              },
              {
                "id": "c",
                "text": "Just sizes"
              },
              {
                "id": "d",
                "text": "Just ends"
              }
            ],
            "correct": "b",
            "explanation": "Priority by size (want smallest). Need end to check if still valid.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Add interval to heap when:",
            "options": [
              {
                "id": "a",
                "text": "Interval start <= current query"
              },
              {
                "id": "b",
                "text": "Interval end >= current query"
              },
              {
                "id": "c",
                "text": "Interval contains query"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "a",
            "explanation": "If interval starts at or before query, it might contain query. Add to candidates.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Remove interval from heap when:",
            "options": [
              {
                "id": "a",
                "text": "It's been used"
              },
              {
                "id": "b",
                "text": "Its end < current query"
              },
              {
                "id": "c",
                "text": "It's too large"
              },
              {
                "id": "d",
                "text": "After each query"
              }
            ],
            "correct": "b",
            "explanation": "If end < query, interval can't contain query (or any future query since sorted).",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "After cleanup, answer is:",
            "options": [
              {
                "id": "a",
                "text": "Heap top's size (if heap non-empty)"
              },
              {
                "id": "b",
                "text": "Heap top's end"
              },
              {
                "id": "c",
                "text": "Sum of all sizes"
              },
              {
                "id": "d",
                "text": "Number of intervals"
              }
            ],
            "correct": "a",
            "explanation": "Min-heap by size, so top is smallest valid interval.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Sort intervals by start, queries by value. Sweep: add intervals starting <= query to min-heap (by size), remove expired ones (end < query). Heap top = answer.",
        "pattern": "Intervals",
        "keyInsight": "Sort intervals by start and queries by value. Use min-heap of (size, end) to track valid intervals.",
        "timeComplexity": "O((n + q) log n)",
        "spaceComplexity": "O(n + q)",
        "triggerWords": [
          "minimum interval to include each query",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minInterval(intervals: List[List[int]], queries: List[int]) -> List[int]:\n    # Sort intervals by start\n    intervals.sort()\n    \n    # Sort queries but keep original indices\n    sorted_queries = sorted(enumerate(queries), key=lambda x: x[1])\n    \n    result = [-1] * len(queries)\n    heap = []  # (size, end)\n    i = 0\n    \n    for idx, q in sorted_queries:\n        # Add all intervals that start <= query\n        while i < len(intervals) and intervals[i][0] <= q:\n            l, r = intervals[i]\n            heapq.heappush(heap, (r - l + 1, r))\n            i += 1\n        \n        # Remove expired intervals (end < query)\n        while heap and heap[0][1] < q:\n            heapq.heappop(heap)\n        \n        # Smallest valid interval\n        if heap:\n            result[idx] = heap[0][0]\n    \n    return result"
      }
    ],
    "bit-manipulation": [
      {
        "id": "01-single-number",
        "slug": "single-number",
        "title": "Single Number",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "single-number"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
        "examples": [
          {
            "input": "nums = [2,2,1]",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "nums = [4,1,2,1,2]",
            "output": "4",
            "explanation": ""
          },
          {
            "input": "nums = [1]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What is a ^ a (XOR of number with itself)?",
            "options": [
              {
                "id": "a",
                "text": "a"
              },
              {
                "id": "b",
                "text": "0"
              },
              {
                "id": "c",
                "text": "2a"
              },
              {
                "id": "d",
                "text": "1"
              }
            ],
            "correct": "b",
            "explanation": "XOR gives 1 only when bits differ. Same bits -> 0.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "What is a ^ 0?",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "a"
              },
              {
                "id": "c",
                "text": "1"
              },
              {
                "id": "d",
                "text": "-a"
              }
            ],
            "correct": "b",
            "explanation": "0 has no set bits. XOR with 0 preserves the original.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "a ^ b ^ a equals:",
            "options": [
              {
                "id": "a",
                "text": "a"
              },
              {
                "id": "b",
                "text": "b"
              },
              {
                "id": "c",
                "text": "0"
              },
              {
                "id": "d",
                "text": "2a ^ b"
              }
            ],
            "correct": "b",
            "explanation": "a ^ b ^ a = a ^ a ^ b = 0 ^ b = b. Order doesn't matter.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "XORing all elements works because:",
            "options": [
              {
                "id": "a",
                "text": "Pairs cancel to 0"
              },
              {
                "id": "b",
                "text": "Single number remains"
              },
              {
                "id": "c",
                "text": "Both A and B"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Each pair XORs to 0. Only the single number survives.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "This solution uses:",
            "options": [
              {
                "id": "a",
                "text": "O(n) space"
              },
              {
                "id": "b",
                "text": "O(n) hash set"
              },
              {
                "id": "c",
                "text": "O(1) space"
              },
              {
                "id": "d",
                "text": "O(log n) space"
              }
            ],
            "correct": "c",
            "explanation": "Only need one variable to accumulate XOR result.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "XOR all numbers. Pairs cancel (a^a=0), single number remains (a^0=a). Commutative and associative.",
        "pattern": "Bit Manipulation",
        "keyInsight": "XOR all numbers. Pairs cancel out (a ^ a = 0), leaving the single number.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "single number",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def singleNumber(nums: List[int]) -> int:\n    result = 0\n    for num in nums:\n        result ^= num\n    return result"
      },
      {
        "id": "02-number-of-1-bits",
        "slug": "number-of-1-bits",
        "title": "Number of 1 Bits",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "number-of-1-bits"
        ],
        "estimatedTime": 5,
        "problemStatement": "Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).",
        "examples": [
          {
            "input": "n = 00000000000000000000000000001011",
            "output": "3",
            "explanation": "Binary has three '1' bits."
          },
          {
            "input": "n = 00000000000000000000000010000000",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "n = 11111111111111111111111111111101",
            "output": "31",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "n & (n-1) does:",
            "options": [
              {
                "id": "a",
                "text": "Sets rightmost 0 to 1"
              },
              {
                "id": "b",
                "text": "Clears rightmost 1 bit"
              },
              {
                "id": "c",
                "text": "Doubles n"
              },
              {
                "id": "d",
                "text": "Halves n"
              }
            ],
            "correct": "b",
            "explanation": "n-1 flips all bits from rightmost 1 to right. AND with n clears that 1.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "If n = 12 (1100), n & (n-1) = ?",
            "options": [
              {
                "id": "a",
                "text": "8 (1000)"
              },
              {
                "id": "b",
                "text": "11 (1011)"
              },
              {
                "id": "c",
                "text": "4 (0100)"
              },
              {
                "id": "d",
                "text": "0"
              }
            ],
            "correct": "a",
            "explanation": "12 = 1100, 11 = 1011. 1100 & 1011 = 1000 = 8.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "To count 1s, we:",
            "options": [
              {
                "id": "a",
                "text": "Count iterations until n = 0"
              },
              {
                "id": "b",
                "text": "Convert to string"
              },
              {
                "id": "c",
                "text": "Use multiplication"
              },
              {
                "id": "d",
                "text": "Use division"
              }
            ],
            "correct": "a",
            "explanation": "Each n = n & (n-1) removes one 1-bit. Count how many removals.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "We can also:",
            "options": [
              {
                "id": "a",
                "text": "Check n & 1, then n >>= 1"
              },
              {
                "id": "b",
                "text": "Check 32 bits always"
              },
              {
                "id": "c",
                "text": "Both A and B"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Either works. n & 1 checks last bit, shift right to check next.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Brian Kernighan's method iterates:",
            "options": [
              {
                "id": "a",
                "text": "32 times always"
              },
              {
                "id": "b",
                "text": "Number of 1-bits times"
              },
              {
                "id": "c",
                "text": "n times"
              },
              {
                "id": "d",
                "text": "log(n) times"
              }
            ],
            "correct": "b",
            "explanation": "Each iteration removes one 1-bit. Runs exactly count(1s) times.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "n & (n-1) clears rightmost 1-bit. Count iterations until n = 0. Each iteration = one 1-bit.",
        "pattern": "Bit Manipulation",
        "keyInsight": "n & (n-1) clears the rightmost set bit. Count iterations until n becomes 0.",
        "timeComplexity": "O(k)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "number of 1 bits",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def hammingWeight(n: int) -> int:\n    count = 0\n    while n:\n        n &= n - 1  # Clear rightmost 1-bit\n        count += 1\n    return count"
      },
      {
        "id": "03-counting-bits",
        "slug": "counting-bits",
        "title": "Counting Bits",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "counting-bits"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (0 <= i <= n), `ans[i]` is the number of 1's in the binary representation of `i`.",
        "examples": [
          {
            "input": "n = 2",
            "output": "[0,1,1]",
            "explanation": "0=0, 1=1, 2=10"
          },
          {
            "input": "n = 5",
            "output": "[0,1,1,2,1,2]",
            "explanation": "0=0, 1=1, 2=10, 3=11, 4=100, 5=101"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "i >> 1 (right shift by 1):",
            "options": [
              {
                "id": "a",
                "text": "Doubles i"
              },
              {
                "id": "b",
                "text": "Halves i (integer division by 2)"
              },
              {
                "id": "c",
                "text": "Removes all 1s"
              },
              {
                "id": "d",
                "text": "Adds a 0 at the end"
              }
            ],
            "correct": "b",
            "explanation": "Right shift by 1 = divide by 2. Removes rightmost bit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "bits(i) compared to bits(i >> 1):",
            "options": [
              {
                "id": "a",
                "text": "Always same"
              },
              {
                "id": "b",
                "text": "Differs by at most 1"
              },
              {
                "id": "c",
                "text": "Always greater"
              },
              {
                "id": "d",
                "text": "Doubled"
              }
            ],
            "correct": "b",
            "explanation": "i >> 1 loses one bit (rightmost). If that bit was 1, count decreases by 1.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "bits(i) = ?",
            "options": [
              {
                "id": "a",
                "text": "bits(i - 1) + 1"
              },
              {
                "id": "b",
                "text": "bits(i >> 1) + (i & 1)"
              },
              {
                "id": "c",
                "text": "bits(i / 2) * 2"
              },
              {
                "id": "d",
                "text": "bits(i - 1) + bits(1)"
              }
            ],
            "correct": "b",
            "explanation": "bits(i>>1) gives count without last bit. Add (i & 1) for the last bit.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "bits(0) = ?",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "Undefined"
              },
              {
                "id": "d",
                "text": "-1"
              }
            ],
            "correct": "a",
            "explanation": "0 has no 1-bits.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "To compute bits(i), we need:",
            "options": [
              {
                "id": "a",
                "text": "bits(i - 1)"
              },
              {
                "id": "b",
                "text": "bits(i >> 1) (which is < i)"
              },
              {
                "id": "c",
                "text": "bits(i + 1)"
              },
              {
                "id": "d",
                "text": "bits(i * 2)"
              }
            ],
            "correct": "b",
            "explanation": "i >> 1 < i for i > 0. So compute in order 0, 1, 2, ..., n.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "DP: dp[i] = dp[i >> 1] + (i & 1). Right shift gives count without last bit, add 1 if last bit is set.",
        "pattern": "Bit Manipulation",
        "keyInsight": "DP: bits(i) = bits(i >> 1) + (i & 1)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "counting bits",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def countBits(n: int) -> List[int]:\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i >> 1] + (i & 1)\n    return dp"
      },
      {
        "id": "04-reverse-bits",
        "slug": "reverse-bits",
        "title": "Reverse Bits",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "reverse-bits"
        ],
        "estimatedTime": 5,
        "problemStatement": "Reverse bits of a given 32 bits unsigned integer.",
        "examples": [
          {
            "input": "n = 00000010100101000001111010011100",
            "output": "964176192 (00111001011110000010100101000000)",
            "explanation": ""
          },
          {
            "input": "n = 11111111111111111111111111111101",
            "output": "3221225471 (10111111111111111111111111111111)",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To extract the rightmost bit of n:",
            "options": [
              {
                "id": "a",
                "text": "n >> 1"
              },
              {
                "id": "b",
                "text": "n & 1"
              },
              {
                "id": "c",
                "text": "n | 1"
              },
              {
                "id": "d",
                "text": "n ^ 1"
              }
            ],
            "correct": "b",
            "explanation": "AND with 1 isolates the last bit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Each extracted bit should go:",
            "options": [
              {
                "id": "a",
                "text": "To the same position"
              },
              {
                "id": "b",
                "text": "To the mirrored position"
              },
              {
                "id": "c",
                "text": "To position 0 always"
              },
              {
                "id": "d",
                "text": "Random position"
              }
            ],
            "correct": "b",
            "explanation": "Bit at position 0 goes to position 31, etc. Reverse = mirror.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "For each of 32 bits:",
            "options": [
              {
                "id": "a",
                "text": "result = (result << 1) | (n & 1), then n >> 1"
              },
              {
                "id": "b",
                "text": "result = (result >> 1) | (n & 1), then n << 1"
              },
              {
                "id": "c",
                "text": "result += n & 1, then n >> 1"
              },
              {
                "id": "d",
                "text": "result = result ^ n"
              }
            ],
            "correct": "a",
            "explanation": "Shift result left to make room, OR with extracted bit, shift n right to get next bit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "We always iterate:",
            "options": [
              {
                "id": "a",
                "text": "Until n becomes 0"
              },
              {
                "id": "b",
                "text": "Exactly 32 times"
              },
              {
                "id": "c",
                "text": "log(n) times"
              },
              {
                "id": "d",
                "text": "n times"
              }
            ],
            "correct": "b",
            "explanation": "Need all 32 bits. Leading zeros in input become trailing zeros in output.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "If input has leading zeros:",
            "options": [
              {
                "id": "a",
                "text": "Ignore them"
              },
              {
                "id": "b",
                "text": "They become trailing zeros in output"
              },
              {
                "id": "c",
                "text": "Error"
              },
              {
                "id": "d",
                "text": "Skip them"
              }
            ],
            "correct": "b",
            "explanation": "Reversal means position 31 (leading) goes to position 0 (trailing).",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "Extract rightmost bit (n & 1), shift result left and add bit, shift n right. Repeat 32 times to reverse all bits.",
        "pattern": "Bit Manipulation",
        "keyInsight": "Extract rightmost bit, add to result (shifted left), shift input right. Repeat 32 times.",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reverse bits",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reverseBits(n: int) -> int:\n    result = 0\n    for _ in range(32):\n        result = (result << 1) | (n & 1)\n        n >>= 1\n    return result"
      },
      {
        "id": "05-missing-number",
        "slug": "missing-number",
        "title": "Missing Number",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "missing-number"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.",
        "examples": [
          {
            "input": "nums = [3,0,1]",
            "output": "2",
            "explanation": ""
          },
          {
            "input": "nums = [0,1]",
            "output": "2",
            "explanation": ""
          },
          {
            "input": "nums = [9,6,4,2,3,5,7,0,1]",
            "output": "8",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If we XOR all indices (0 to n) and all elements:",
            "options": [
              {
                "id": "a",
                "text": "Pairs will cancel (appear twice)"
              },
              {
                "id": "b",
                "text": "Missing number will remain (appears once)"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Each number except missing appears in both index set and array. Missing appears only in index set.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "For [3, 0, 1], we XOR: Indices: 0, 1, 2, 3 (n=3) Elements: 3, 0, 1",
            "options": [
              {
                "id": "a",
                "text": "0^1^2^3^3^0^1 = 2"
              },
              {
                "id": "b",
                "text": "3^0^1 = 2"
              },
              {
                "id": "c",
                "text": "0+1+2+3 - 3-0-1 = 2"
              },
              {
                "id": "d",
                "text": "A and C both work"
              }
            ],
            "correct": "d",
            "explanation": "XOR cancels pairs. Sum difference also works.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Expected sum 0+1+...+n = n(n+1)/2. Missing = ?",
            "options": [
              {
                "id": "a",
                "text": "expected - actual"
              },
              {
                "id": "b",
                "text": "actual - expected"
              },
              {
                "id": "c",
                "text": "expected / actual"
              },
              {
                "id": "d",
                "text": "expected * actual"
              }
            ],
            "correct": "a",
            "explanation": "Actual sum is missing one number. Difference gives that number.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Both XOR and sum methods use:",
            "options": [
              {
                "id": "a",
                "text": "O(n) space"
              },
              {
                "id": "b",
                "text": "O(1) space"
              },
              {
                "id": "c",
                "text": "O(n) for XOR, O(1) for sum"
              },
              {
                "id": "d",
                "text": "O(log n) space"
              }
            ],
            "correct": "b",
            "explanation": "Both only need a running accumulator.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Sum method might have:",
            "options": [
              {
                "id": "a",
                "text": "Integer overflow for large n"
              },
              {
                "id": "b",
                "text": "Floating point errors"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither (XOR is safer)"
              }
            ],
            "correct": "a",
            "explanation": "n(n+1)/2 can be large. XOR has no overflow issues.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "XOR all indices 0 to n with all array elements. Pairs cancel, missing number survives. Or: n(n+1)/2 - sum(nums).",
        "pattern": "Bit Manipulation",
        "keyInsight": "XOR all numbers 0 to n with all array elements. Pairs cancel, missing number remains.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "missing number",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def missingNumber(nums: List[int]) -> int:\n    n = len(nums)\n    result = n  # Start with n (last index)\n    \n    for i in range(n):\n        result ^= i ^ nums[i]\n    \n    return result"
      },
      {
        "id": "06-sum-of-two-integers",
        "slug": "sum-of-two-integers",
        "title": "Sum of Two Integers",
        "category": "bit-manipulation",
        "difficulty": "medium",
        "tags": [
          "bit-manipulation",
          "sum-of-two-integers"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two integers `a` and `b`, return the sum of the two integers without using the operators `+` and `-`.",
        "examples": [
          {
            "input": "a = 1, b = 2",
            "output": "3",
            "explanation": ""
          },
          {
            "input": "a = 2, b = 3",
            "output": "5",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "a ^ b gives:",
            "options": [
              {
                "id": "a",
                "text": "Sum without considering carries"
              },
              {
                "id": "b",
                "text": "Sum including carries"
              },
              {
                "id": "c",
                "text": "Only the carries"
              },
              {
                "id": "d",
                "text": "Difference of a and b"
              }
            ],
            "correct": "a",
            "explanation": "XOR adds bits without carry: 0+0=0, 0+1=1, 1+0=1, 1+1=0 (no carry).",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Carry happens when:",
            "options": [
              {
                "id": "a",
                "text": "Both bits are 0"
              },
              {
                "id": "b",
                "text": "Both bits are 1"
              },
              {
                "id": "c",
                "text": "Bits are different"
              },
              {
                "id": "d",
                "text": "Any bit is 1"
              }
            ],
            "correct": "b",
            "explanation": "1 + 1 = 10 in binary. Generates a carry to next position.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Carry from a + b is:",
            "options": [
              {
                "id": "a",
                "text": "a | b"
              },
              {
                "id": "b",
                "text": "a & b"
              },
              {
                "id": "c",
                "text": "a ^ b"
              },
              {
                "id": "d",
                "text": "a + b"
              }
            ],
            "correct": "b",
            "explanation": "AND finds positions where both bits are 1 (where carries occur).",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "The carry needs to be:",
            "options": [
              {
                "id": "a",
                "text": "Added at same position"
              },
              {
                "id": "b",
                "text": "Shifted left by 1"
              },
              {
                "id": "c",
                "text": "Shifted right by 1"
              },
              {
                "id": "d",
                "text": "Kept as is"
              }
            ],
            "correct": "b",
            "explanation": "Carry from position i affects position i+1. Shift left.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "We stop when:",
            "options": [
              {
                "id": "a",
                "text": "a becomes 0"
              },
              {
                "id": "b",
                "text": "Carry becomes 0"
              },
              {
                "id": "c",
                "text": "After 32 iterations"
              },
              {
                "id": "d",
                "text": "Sum equals original"
              }
            ],
            "correct": "b",
            "explanation": "When no carry, XOR is the final answer.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "XOR = sum without carry. (AND << 1) = carry bits. Add sum and carry repeatedly until carry is 0.",
        "pattern": "Bit Manipulation",
        "keyInsight": "XOR gives sum without carry. AND shifted left gives carry. Repeat until no carry.",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "sum of two integers",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def getSum(a: int, b: int) -> int:\n    # Use 32-bit mask for Python (handles negatives)\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n    \n    while b != 0:\n        carry = (a & b) << 1\n        a = (a ^ b) & MASK\n        b = carry & MASK\n    \n    # Handle negative numbers\n    return a if a <= MAX_INT else ~(a ^ MASK)"
      },
      {
        "id": "07-reverse-integer",
        "slug": "reverse-integer",
        "title": "Reverse Integer",
        "category": "bit-manipulation",
        "difficulty": "medium",
        "tags": [
          "bit-manipulation",
          "reverse-integer"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return `0`.\n\nAssume the environment does not allow you to store 64-bit integers.",
        "examples": [
          {
            "input": "x = 123",
            "output": "321",
            "explanation": ""
          },
          {
            "input": "x = -123",
            "output": "-321",
            "explanation": ""
          },
          {
            "input": "x = 120",
            "output": "21",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To get the last digit of x:",
            "options": [
              {
                "id": "a",
                "text": "x // 10"
              },
              {
                "id": "b",
                "text": "x % 10"
              },
              {
                "id": "c",
                "text": "x - 10"
              },
              {
                "id": "d",
                "text": "x / 10"
              }
            ],
            "correct": "b",
            "explanation": "Modulo 10 gives the ones digit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "To remove the last digit of x:",
            "options": [
              {
                "id": "a",
                "text": "x // 10"
              },
              {
                "id": "b",
                "text": "x % 10"
              },
              {
                "id": "c",
                "text": "x - 10"
              },
              {
                "id": "d",
                "text": "x * 10"
              }
            ],
            "correct": "a",
            "explanation": "Integer division by 10 drops the last digit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "To add digit d to reversed number rev:",
            "options": [
              {
                "id": "a",
                "text": "rev + d"
              },
              {
                "id": "b",
                "text": "rev * 10 + d"
              },
              {
                "id": "c",
                "text": "rev * d + 10"
              },
              {
                "id": "d",
                "text": "d * 10 + rev"
              }
            ],
            "correct": "b",
            "explanation": "Shift existing digits left (multiply by 10), add new digit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "For 32-bit signed int, overflow if:",
            "options": [
              {
                "id": "a",
                "text": "rev > MAX / 10"
              },
              {
                "id": "b",
                "text": "rev == MAX / 10 and digit > 7"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "Only after multiplication"
              }
            ],
            "correct": "c",
            "explanation": "Must check BEFORE multiplying. If rev > MAX/10, rev*10 overflows. If rev == MAX/10, depends on digit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "For negative x:",
            "options": [
              {
                "id": "a",
                "text": "Reverse separately, add negative sign"
              },
              {
                "id": "b",
                "text": "x % 10 gives negative remainder"
              },
              {
                "id": "c",
                "text": "Convert to positive, reverse, negate"
              },
              {
                "id": "d",
                "text": "B or C both work"
              }
            ],
            "correct": "d",
            "explanation": "In Python, -123 % 10 = 7 (weird). Better to track sign, work with absolute value.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "Pop last digit (x % 10), push to result (rev * 10 + digit), remove from x (x // 10). Check overflow BEFORE each push.",
        "pattern": "Bit Manipulation",
        "keyInsight": "Pop digits from end (mod 10), push to result (multiply by 10). Check overflow before each push.",
        "timeComplexity": "O(log x)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reverse integer",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reverse(x: int) -> int:\n    INT_MAX = 2**31 - 1\n    INT_MIN = -2**31\n    \n    sign = 1 if x >= 0 else -1\n    x = abs(x)\n    rev = 0\n    \n    while x:\n        digit = x % 10\n        x //= 10\n        \n        # Check overflow before push\n        if rev > INT_MAX // 10:\n            return 0\n        \n        rev = rev * 10 + digit\n    \n    rev *= sign\n    return rev if INT_MIN <= rev <= INT_MAX else 0"
      }
    ],
    "math-and-geometry": [
      {
        "id": "01-rotate-image",
        "slug": "rotate-image",
        "title": "Rotate Image",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "rotate-image"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
        "examples": [
          {
            "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
            "output": "[[7,4,1],[8,5,2],[9,6,3]]",
            "explanation": ""
          },
          {
            "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
            "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Transposing a matrix:",
            "options": [
              {
                "id": "a",
                "text": "Swaps rows and columns"
              },
              {
                "id": "b",
                "text": "Reverses rows"
              },
              {
                "id": "c",
                "text": "Reverses columns"
              },
              {
                "id": "d",
                "text": "Rotates 90°"
              }
            ],
            "correct": "a",
            "explanation": "Element at (i,j) goes to (j,i).",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After 90° clockwise, element at (i, j) goes to:",
            "options": [
              {
                "id": "a",
                "text": "(j, n-1-i)"
              },
              {
                "id": "b",
                "text": "(n-1-i, j)"
              },
              {
                "id": "c",
                "text": "(n-1-j, i)"
              },
              {
                "id": "d",
                "text": "(i, n-1-j)"
              }
            ],
            "correct": "a",
            "explanation": "Row i becomes column n-1-i. Column j becomes row j.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "90° clockwise rotation equals:",
            "options": [
              {
                "id": "a",
                "text": "Transpose only"
              },
              {
                "id": "b",
                "text": "Transpose + reverse rows"
              },
              {
                "id": "c",
                "text": "Reverse rows + transpose"
              },
              {
                "id": "d",
                "text": "Reverse columns only"
              }
            ],
            "correct": "b",
            "explanation": "Transpose swaps (i,j)->(j,i). Reversing rows of transpose gives 90° clockwise.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "In-place transpose swaps:",
            "options": [
              {
                "id": "a",
                "text": "matrix[i][j] with matrix[j][i]"
              },
              {
                "id": "b",
                "text": "matrix[i][j] with matrix[n-1-i][j]"
              },
              {
                "id": "c",
                "text": "matrix[i][j] with matrix[i][n-1-j]"
              },
              {
                "id": "d",
                "text": "All four corners"
              }
            ],
            "correct": "a",
            "explanation": "Only swap upper triangle with lower triangle.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For in-place transpose, we iterate:",
            "options": [
              {
                "id": "a",
                "text": "All (i, j) pairs"
              },
              {
                "id": "b",
                "text": "Only upper triangle (j > i)"
              },
              {
                "id": "c",
                "text": "Only diagonal"
              },
              {
                "id": "d",
                "text": "Only corners"
              }
            ],
            "correct": "b",
            "explanation": "Swapping all would swap twice (back to original). Only swap where j > i.",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "90° clockwise = Transpose + Reverse each row. Transpose swaps (i,j)<->(j,i). Both operations are in-place.",
        "pattern": "Math & Geometry",
        "keyInsight": "90° clockwise rotation = transpose + reverse each row.",
        "timeComplexity": "O(n²)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "rotate image",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def rotate(matrix: List[List[int]]) -> None:\n    n = len(matrix)\n    \n    # Step 1: Transpose (swap across diagonal)\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Step 2: Reverse each row\n    for i in range(n):\n        matrix[i].reverse()"
      },
      {
        "id": "02-spiral-matrix",
        "slug": "spiral-matrix",
        "title": "Spiral Matrix",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "spiral-matrix"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` matrix, return all elements of the matrix in spiral order.",
        "examples": [
          {
            "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
            "output": "[1,2,3,6,9,8,7,4,5]",
            "explanation": ""
          },
          {
            "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
            "output": "[1,2,3,4,8,12,11,10,9,5,6,7]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Spiral traversal order is:",
            "options": [
              {
                "id": "a",
                "text": "Left->Right, Top->Bottom, Right->Left, Bottom->Top"
              },
              {
                "id": "b",
                "text": "Top->Bottom, Left->Right, Bottom->Top, Right->Left"
              },
              {
                "id": "c",
                "text": "Random"
              },
              {
                "id": "d",
                "text": "Depends on matrix size"
              }
            ],
            "correct": "a",
            "explanation": "Start at top-left, go right, down, left, up, then repeat inward.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "We track:",
            "options": [
              {
                "id": "a",
                "text": "top, bottom, left, right"
              },
              {
                "id": "b",
                "text": "Only center"
              },
              {
                "id": "c",
                "text": "Only corners"
              },
              {
                "id": "d",
                "text": "Current position only"
              }
            ],
            "correct": "a",
            "explanation": "Four boundaries define the current \"ring\" to traverse.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After traversing top row (left to right):",
            "options": [
              {
                "id": "a",
                "text": "Decrement top"
              },
              {
                "id": "b",
                "text": "Increment top"
              },
              {
                "id": "c",
                "text": "Decrement left"
              },
              {
                "id": "d",
                "text": "Increment right"
              }
            ],
            "correct": "b",
            "explanation": "Top row is done. Next ring's top is one row lower.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Stop when:",
            "options": [
              {
                "id": "a",
                "text": "We've visited all elements"
              },
              {
                "id": "b",
                "text": "top > bottom or left > right"
              },
              {
                "id": "c",
                "text": "Boundaries reach center"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Boundaries crossing means no more elements to process.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For single row or column:",
            "options": [
              {
                "id": "a",
                "text": "Need special handling"
              },
              {
                "id": "b",
                "text": "Boundaries naturally handle it"
              },
              {
                "id": "c",
                "text": "Will loop forever"
              },
              {
                "id": "d",
                "text": "Skip traversal"
              }
            ],
            "correct": "b",
            "explanation": "Boundary checks (top <= bottom, left <= right) handle degenerate cases.",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "Track four boundaries. Traverse right->down->left->up, shrinking boundaries after each direction. Stop when boundaries cross.",
        "pattern": "Math & Geometry",
        "keyInsight": "Track four boundaries (top, bottom, left, right). Process each edge, shrink boundary, repeat.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "spiral matrix",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def spiralOrder(matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n        return []\n    \n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse right\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        # Traverse down\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        # Traverse left (if rows remain)\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        # Traverse up (if columns remain)\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result"
      },
      {
        "id": "03-set-matrix-zeroes",
        "slug": "set-matrix-zeroes",
        "title": "Set Matrix Zeroes",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "set-matrix-zeroes"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` integer matrix, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it in place.",
        "examples": [
          {
            "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
            "output": "[[1,0,1],[0,0,0],[1,0,1]]",
            "explanation": ""
          },
          {
            "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
            "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Why can't we zero cells immediately when we find a 0?",
            "options": [
              {
                "id": "a",
                "text": "We'd lose information about original zeros"
              },
              {
                "id": "b",
                "text": "Too slow"
              },
              {
                "id": "c",
                "text": "Matrix size unknown"
              },
              {
                "id": "d",
                "text": "No issue"
              }
            ],
            "correct": "a",
            "explanation": "New zeros would trigger more zeroing incorrectly. Need to mark first, then zero.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "We can use O(1) extra space by:",
            "options": [
              {
                "id": "a",
                "text": "Using first row/column as markers"
              },
              {
                "id": "b",
                "text": "Using diagonal"
              },
              {
                "id": "c",
                "text": "Using last row/column"
              },
              {
                "id": "d",
                "text": "Not possible"
              }
            ],
            "correct": "a",
            "explanation": "First row marks columns to zero. First column marks rows to zero.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "matrix[0][0] belongs to both first row and column. Handle by:",
            "options": [
              {
                "id": "a",
                "text": "Using a separate variable for row 0"
              },
              {
                "id": "b",
                "text": "Using a separate variable for col 0"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "No special handling"
              }
            ],
            "correct": "c",
            "explanation": "Need to separately track whether row 0 or col 0 should be zeroed.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After marking, we should fill zeros:",
            "options": [
              {
                "id": "a",
                "text": "From (0,0) to (m-1, n-1)"
              },
              {
                "id": "b",
                "text": "From (1,1) to (m-1, n-1), then first row/col"
              },
              {
                "id": "c",
                "text": "Randomly"
              },
              {
                "id": "d",
                "text": "First row/col first, then rest"
              }
            ],
            "correct": "b",
            "explanation": "Fill inner matrix first. If we zero first row/col early, we lose marker info.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "If matrix[0][j] = 0 after scanning:",
            "options": [
              {
                "id": "a",
                "text": "Column j should be zeroed"
              },
              {
                "id": "b",
                "text": "Row j should be zeroed"
              },
              {
                "id": "c",
                "text": "Cell (0,j) was originally 0 only"
              },
              {
                "id": "d",
                "text": "Nothing special"
              }
            ],
            "correct": "a",
            "explanation": "First row marks which columns to zero (either original 0 or 0 found below).",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "Use first row to mark columns, first column to mark rows. Handle row 0 separately. Fill inner cells, then first row/col.",
        "pattern": "Math & Geometry",
        "keyInsight": "Use first row and column as markers. Scan for zeros, mark in first row/col, then fill zeros.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "set matrix zeroes",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def setZeroes(matrix: List[List[int]]) -> None:\n    m, n = len(matrix), len(matrix[0])\n    first_row_zero = any(matrix[0][j] == 0 for j in range(n))\n    first_col_zero = any(matrix[i][0] == 0 for i in range(m))\n    \n    # Mark zeros in first row/col\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n    \n    # Fill zeros for inner matrix\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n    \n    # Handle first row/col\n    if first_row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n    if first_col_zero:\n        for i in range(m):\n            matrix[i][0] = 0"
      },
      {
        "id": "04-happy-number",
        "slug": "happy-number",
        "title": "Happy Number",
        "category": "math-and-geometry",
        "difficulty": "easy",
        "tags": [
          "math-and-geometry",
          "happy-number"
        ],
        "estimatedTime": 5,
        "problemStatement": "Write an algorithm to determine if a number `n` is happy.\n\nA happy number is a number defined by the following process:\n- Starting with any positive integer, replace the number by the sum of the squares of its digits.\n- Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n- Those numbers for which this process ends in 1 are happy.\n\nReturn `true` if `n` is a happy number, and `false` otherwise.",
        "examples": [
          {
            "input": "n = 19",
            "output": "true",
            "explanation": "1² + 9² = 82 -> 8² + 2² = 68 -> 6² + 8² = 100 -> 1² + 0² + 0² = 1"
          },
          {
            "input": "n = 2",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The sequence must cycle or reach 1 because:",
            "options": [
              {
                "id": "a",
                "text": "Sum of digit squares has bounded values"
              },
              {
                "id": "b",
                "text": "Numbers keep decreasing"
              },
              {
                "id": "c",
                "text": "Random chance"
              },
              {
                "id": "d",
                "text": "Always reaches 1"
              }
            ],
            "correct": "a",
            "explanation": "For any number, digit-square-sum is bounded. Eventually repeats or hits 1.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "To detect cycle, we can use:",
            "options": [
              {
                "id": "a",
                "text": "Hash set to track seen numbers"
              },
              {
                "id": "b",
                "text": "Floyd's slow/fast pointers"
              },
              {
                "id": "c",
                "text": "Either"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Hash set: check if seen. Floyd's: if slow meets fast, cycle exists.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "In Floyd's algorithm:",
            "options": [
              {
                "id": "a",
                "text": "Slow advances 1 step, fast advances 2"
              },
              {
                "id": "b",
                "text": "Both advance 1 step"
              },
              {
                "id": "c",
                "text": "Slow advances 2, fast advances 1"
              },
              {
                "id": "d",
                "text": "Both advance 2 steps"
              }
            ],
            "correct": "a",
            "explanation": "If there's a cycle, fast will \"lap\" slow and meet.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "Number is happy if:",
            "options": [
              {
                "id": "a",
                "text": "Sequence reaches 1"
              },
              {
                "id": "b",
                "text": "Sequence cycles at any number"
              },
              {
                "id": "c",
                "text": "Sequence decreases"
              },
              {
                "id": "d",
                "text": "First digit becomes 0"
              }
            ],
            "correct": "a",
            "explanation": "Happy numbers eventually reach 1 and stay there (1->1).",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "Number is NOT happy if:",
            "options": [
              {
                "id": "a",
                "text": "Sequence reaches 1"
              },
              {
                "id": "b",
                "text": "Slow meets fast (and not at 1)"
              },
              {
                "id": "c",
                "text": "Number seen before (and not 1)"
              },
              {
                "id": "d",
                "text": "B and C"
              }
            ],
            "correct": "d",
            "explanation": "Cycle detected that doesn't include 1 means it will loop forever.",
            "conceptId": "floyd-cycle"
          }
        ],
        "oneLiner": "Cycle detection: sequence either reaches 1 or cycles. Use hash set to detect repeats, or Floyd's fast/slow pointers.",
        "pattern": "Math & Geometry",
        "keyInsight": "This is cycle detection. Use Floyd's algorithm (slow/fast pointers) or a hash set.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "happy number",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isHappy(n: int) -> bool:\n    def get_next(num):\n        total = 0\n        while num > 0:\n            digit = num % 10\n            total += digit * digit\n            num //= 10\n        return total\n    \n    # Floyd's cycle detection\n    slow = n\n    fast = get_next(n)\n    \n    while fast != 1 and slow != fast:\n        slow = get_next(slow)\n        fast = get_next(get_next(fast))\n    \n    return fast == 1"
      },
      {
        "id": "05-plus-one",
        "slug": "plus-one",
        "title": "Plus One",
        "category": "math-and-geometry",
        "difficulty": "easy",
        "tags": [
          "math-and-geometry",
          "plus-one"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
          {
            "input": "digits = [1,2,3]",
            "output": "[1,2,4]",
            "explanation": "123 + 1 = 124"
          },
          {
            "input": "digits = [4,3,2,1]",
            "output": "[4,3,2,2]",
            "explanation": ""
          },
          {
            "input": "digits = [9]",
            "output": "[1,0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We add 1 starting from:",
            "options": [
              {
                "id": "a",
                "text": "Left (most significant digit)"
              },
              {
                "id": "b",
                "text": "Right (least significant digit)"
              },
              {
                "id": "c",
                "text": "Middle"
              },
              {
                "id": "d",
                "text": "Any position"
              }
            ],
            "correct": "b",
            "explanation": "Addition starts from rightmost digit (ones place).",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Carry occurs when:",
            "options": [
              {
                "id": "a",
                "text": "Digit is 0"
              },
              {
                "id": "b",
                "text": "Digit becomes 10 after adding"
              },
              {
                "id": "c",
                "text": "Digit is 9 before adding"
              },
              {
                "id": "d",
                "text": "B and C (same thing)"
              }
            ],
            "correct": "d",
            "explanation": "9 + 1 = 10. Set digit to 0, carry 1 to next position.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "If digit < 9:",
            "options": [
              {
                "id": "a",
                "text": "Increment and return immediately"
              },
              {
                "id": "b",
                "text": "Continue to next digit"
              },
              {
                "id": "c",
                "text": "Set to 0"
              },
              {
                "id": "d",
                "text": "Need to check carry"
              }
            ],
            "correct": "a",
            "explanation": "No carry will happen. Just increment and we're done.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For [9, 9, 9]:",
            "options": [
              {
                "id": "a",
                "text": "Result is [9, 9, 10]"
              },
              {
                "id": "b",
                "text": "Result is [1, 0, 0, 0]"
              },
              {
                "id": "c",
                "text": "Result is [0, 0, 0]"
              },
              {
                "id": "d",
                "text": "Overflow error"
              }
            ],
            "correct": "b",
            "explanation": "999 + 1 = 1000. Array grows by one element.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Array needs to grow when:",
            "options": [
              {
                "id": "a",
                "text": "Last digit is 9"
              },
              {
                "id": "b",
                "text": "First digit is 9"
              },
              {
                "id": "c",
                "text": "All digits are 9"
              },
              {
                "id": "d",
                "text": "Any digit is 9"
              }
            ],
            "correct": "c",
            "explanation": "Only when carry propagates all the way through.",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "From right: if digit < 9, increment and return. If 9, set to 0 and continue. If all 9s, prepend 1.",
        "pattern": "Math & Geometry",
        "keyInsight": "Simulate addition from right to left. Handle carry propagation.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "plus one",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def plusOne(digits: List[int]) -> List[int]:\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    \n    # All 9s case: [9,9,9] -> [1,0,0,0]\n    return [1] + digits"
      },
      {
        "id": "06-pow-x-n",
        "slug": "pow-x-n",
        "title": "Pow(x, n)",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "powx-n"
        ],
        "estimatedTime": 5,
        "problemStatement": "Implement `pow(x, n)`, which calculates `x` raised to the power `n` (i.e., `x^n`).",
        "examples": [
          {
            "input": "x = 2.00000, n = 10",
            "output": "1024.00000",
            "explanation": ""
          },
          {
            "input": "x = 2.10000, n = 3",
            "output": "9.26100",
            "explanation": ""
          },
          {
            "input": "x = 2.00000, n = -2",
            "output": "0.25000",
            "explanation": "2^-2 = 1/2^2 = 1/4 = 0.25"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Computing x * x * ... * x (n times) is:",
            "options": [
              {
                "id": "a",
                "text": "O(1)"
              },
              {
                "id": "b",
                "text": "O(log n)"
              },
              {
                "id": "c",
                "text": "O(n)"
              },
              {
                "id": "d",
                "text": "O(n²)"
              }
            ],
            "correct": "c",
            "explanation": "n multiplications for x^n. Too slow for large n.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "x^10 can be computed as:",
            "options": [
              {
                "id": "a",
                "text": "x * x^9"
              },
              {
                "id": "b",
                "text": "(x^5)^2"
              },
              {
                "id": "c",
                "text": "(x^2)^5"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "All are mathematically equivalent. (x^5)² uses fewer multiplications.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For even n, x^n = ?",
            "options": [
              {
                "id": "a",
                "text": "x * x^(n-1)"
              },
              {
                "id": "b",
                "text": "(x^(n/2))²"
              },
              {
                "id": "c",
                "text": "x² * x^(n-2)"
              },
              {
                "id": "d",
                "text": "Any of above"
              }
            ],
            "correct": "b",
            "explanation": "Halves the problem size immediately.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For odd n, x^n = ?",
            "options": [
              {
                "id": "a",
                "text": "x * x^(n-1)"
              },
              {
                "id": "b",
                "text": "(x^(n/2))²"
              },
              {
                "id": "c",
                "text": "x * (x^((n-1)/2))²"
              },
              {
                "id": "d",
                "text": "A or C"
              }
            ],
            "correct": "d",
            "explanation": "Make it even by extracting one x, then apply even rule.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For negative n, x^n = ?",
            "options": [
              {
                "id": "a",
                "text": "-x^n"
              },
              {
                "id": "b",
                "text": "1/x^n"
              },
              {
                "id": "c",
                "text": "x^(-n)"
              },
              {
                "id": "d",
                "text": "x/n"
              }
            ],
            "correct": "b",
            "explanation": "x^(-n) = 1/(x^n). Compute positive power, take reciprocal.",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "Binary exponentiation: halve exponent each step. Even n: (x²)^(n/2). Odd n: x * (x²)^((n-1)/2). O(log n) multiplications.",
        "pattern": "Math & Geometry",
        "keyInsight": "Binary exponentiation: x^n = (x^(n/2))^2 for even n, x * x^(n-1) for odd n.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(log n)",
        "triggerWords": [
          "pow(x, n)",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def myPow(x: float, n: int) -> float:\n    if n < 0:\n        x = 1 / x\n        n = -n\n    \n    result = 1\n    while n > 0:\n        if n % 2 == 1:  # Odd\n            result *= x\n        x *= x\n        n //= 2\n    \n    return result"
      },
      {
        "id": "07-multiply-strings",
        "slug": "multiply-strings",
        "title": "Multiply Strings",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "multiply-strings"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.",
        "examples": [
          {
            "input": "num1 = \"2\", num2 = \"3\"",
            "output": "\"6\"",
            "explanation": ""
          },
          {
            "input": "num1 = \"123\", num2 = \"456\"",
            "output": "\"56088\"",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Product of m-digit and n-digit numbers has at most:",
            "options": [
              {
                "id": "a",
                "text": "m + n digits"
              },
              {
                "id": "b",
                "text": "m * n digits"
              },
              {
                "id": "c",
                "text": "max(m, n) digits"
              },
              {
                "id": "d",
                "text": "m + n - 1 digits"
              }
            ],
            "correct": "a",
            "explanation": "Maximum is when 999...9 × 999...9 which has m+n digits.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "num1[i] * num2[j] contributes to positions:",
            "options": [
              {
                "id": "a",
                "text": "i and j"
              },
              {
                "id": "b",
                "text": "i + j and i + j + 1"
              },
              {
                "id": "c",
                "text": "i * j only"
              },
              {
                "id": "d",
                "text": "0 and 1 only"
              }
            ],
            "correct": "b",
            "explanation": "Digit at position i has value × 10^(n1-1-i). Product at positions i+j, i+j+1 in result.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "We process digits:",
            "options": [
              {
                "id": "a",
                "text": "Left to right"
              },
              {
                "id": "b",
                "text": "Right to left for both"
              },
              {
                "id": "c",
                "text": "Left to right for num1, right to left for num2"
              },
              {
                "id": "d",
                "text": "Any order"
              }
            ],
            "correct": "b",
            "explanation": "Rightmost digits are ones place. Process like manual multiplication.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After accumulating at result[i+j+1]:",
            "options": [
              {
                "id": "a",
                "text": "Immediately propagate carry"
              },
              {
                "id": "b",
                "text": "Handle all carries at the end"
              },
              {
                "id": "c",
                "text": "Either works"
              },
              {
                "id": "d",
                "text": "No carry needed"
              }
            ],
            "correct": "c",
            "explanation": "Can accumulate all products first, then handle carries. Or propagate immediately.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Leading zeros in result:",
            "options": [
              {
                "id": "a",
                "text": "Should be kept"
              },
              {
                "id": "b",
                "text": "Should be removed"
              },
              {
                "id": "c",
                "text": "Don't exist"
              },
              {
                "id": "d",
                "text": "Cause errors"
              }
            ],
            "correct": "b",
            "explanation": "\"00123\" should become \"123\". Handle edge case of \"0\".",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "Like manual multiplication: num1[i] × num2[j] goes to result[i+j] and result[i+j+1]. Handle carries, remove leading zeros.",
        "pattern": "Math & Geometry",
        "keyInsight": "Product of digits at positions i and j contributes to position i+j and i+j+1.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m + n)",
        "triggerWords": [
          "multiply strings",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def multiply(num1: str, num2: str) -> str:\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n    \n    m, n = len(num1), len(num2)\n    result = [0] * (m + n)\n    \n    # Multiply each digit pair\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            prod = int(num1[i]) * int(num2[j])\n            p1, p2 = i + j, i + j + 1\n            \n            total = prod + result[p2]\n            result[p2] = total % 10\n            result[p1] += total // 10\n    \n    # Convert to string, skip leading zeros\n    result_str = ''.join(map(str, result)).lstrip('0')\n    return result_str if result_str else \"0\""
      },
      {
        "id": "08-detect-squares",
        "slug": "detect-squares",
        "title": "Detect Squares",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "detect-squares"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a stream of points on the X-Y plane. Design an algorithm that:\n\n- **Adds** new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.\n- Given a query point, **counts** the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.\n\nAn axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For axis-aligned square, edges must be:",
            "options": [
              {
                "id": "a",
                "text": "Any direction"
              },
              {
                "id": "b",
                "text": "Parallel/perpendicular to axes"
              },
              {
                "id": "c",
                "text": "At 45° angles"
              },
              {
                "id": "d",
                "text": "Variable length"
              }
            ],
            "correct": "b",
            "explanation": "\"Axis-aligned\" means sides are horizontal and vertical.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Given two diagonal corners (x1, y1) and (x2, y2), the other two are:",
            "options": [
              {
                "id": "a",
                "text": "(x1, y2) and (x2, y1)"
              },
              {
                "id": "b",
                "text": "((x1+x2)/2, (y1+y2)/2)"
              },
              {
                "id": "c",
                "text": "(x1+1, y1+1) and (x2+1, y2+1)"
              },
              {
                "id": "d",
                "text": "Random points"
              }
            ],
            "correct": "a",
            "explanation": "For axis-aligned square, diagonal corners share no coordinates. Other two share one with each.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "(x1, y1) and (x2, y2) form square diagonal if:",
            "options": [
              {
                "id": "a",
                "text": "|x1 - x2| == |y1 - y2| != 0"
              },
              {
                "id": "b",
                "text": "x1 == x2 or y1 == y2"
              },
              {
                "id": "c",
                "text": "|x1 - x2| + |y1 - y2| == constant"
              },
              {
                "id": "d",
                "text": "Any two points work"
              }
            ],
            "correct": "a",
            "explanation": "Square has equal side lengths. Diagonal implies equal x and y distances.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "To count squares for query point p:",
            "options": [
              {
                "id": "a",
                "text": "Check all pairs of points"
              },
              {
                "id": "b",
                "text": "For each point on same x or y, check diagonal"
              },
              {
                "id": "c",
                "text": "Random sampling"
              },
              {
                "id": "d",
                "text": "Brute force all triplets"
              }
            ],
            "correct": "b",
            "explanation": "Fix one dimension (same x or same y), other corners are determined.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Duplicate points should:",
            "options": [
              {
                "id": "a",
                "text": "Be ignored"
              },
              {
                "id": "b",
                "text": "Increase square count"
              },
              {
                "id": "c",
                "text": "Cause errors"
              },
              {
                "id": "d",
                "text": "Replace old point"
              }
            ],
            "correct": "b",
            "explanation": "Multiple copies of a point can form multiple squares with same corners.",
            "conceptId": "hash-map"
          }
        ],
        "oneLiner": "For query point, check points with same x (or y). Calculate side length, check if the other two corners exist. Multiply counts for duplicates.",
        "pattern": "Math & Geometry",
        "keyInsight": "Fix query point as one corner. For each point with same x, compute potential square corners. Check if both exist.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "detect squares",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class DetectSquares:\n    def __init__(self):\n        self.points = defaultdict(int)\n        self.x_points = defaultdict(list)  # x -> list of y values\n    \n    def add(self, point: List[int]) -> None:\n        x, y = point\n        self.points[(x, y)] += 1\n        self.x_points[x].append(y)\n    \n    def count(self, point: List[int]) -> int:\n        x1, y1 = point\n        result = 0\n        \n        # For each point with same x, try to form square\n        for y2 in self.x_points[x1]:\n            if y2 == y1:\n                continue\n            \n            side = abs(y2 - y1)\n            \n            # Check two possible squares (left and right)\n            for x2 in [x1 + side, x1 - side]:\n                count1 = self.points[(x2, y1)]\n                count2 = self.points[(x2, y2)]\n                result += count1 * count2\n        \n        return result"
      }
    ]
  },
  "allProblems": {
    "arrays-and-hashing": [
      {
        "id": "01-contains-duplicate",
        "slug": "contains-duplicate",
        "title": "Contains Duplicate",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "contains-duplicate"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.",
        "examples": [
          {
            "input": "nums = [1, 2, 3, 1]",
            "output": "true",
            "explanation": "1 appears twice"
          },
          {
            "input": "nums = [1, 2, 3, 4]",
            "output": "false",
            "explanation": "All elements are distinct"
          },
          {
            "input": "nums = [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What is the core operation you need to perform for each element?",
            "options": [
              {
                "id": "a",
                "text": "Compare it with the next element"
              },
              {
                "id": "b",
                "text": "Check if you've seen it before"
              },
              {
                "id": "c",
                "text": "Find its position in sorted order"
              },
              {
                "id": "d",
                "text": "Count how many times it appears"
              }
            ],
            "correct": "b",
            "explanation": "The problem asks if ANY value appears twice. You don't need counts, positions, or adjacent comparisons. You just need to know: seen or not seen.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "If you check each element against all previous elements, what's the time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "c",
            "explanation": "For each of n elements, you potentially scan all previous elements. First element: 0 comparisons, second: 1, third: 2, ... nth: n-1. Total: 0+1+2+...+(n-1) = n(n-1)/2 = O(n²)",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "What operation needs to be faster to improve the solution?",
            "options": [
              {
                "id": "a",
                "text": "Adding elements to the result"
              },
              {
                "id": "b",
                "text": "Checking if an element was seen before"
              },
              {
                "id": "c",
                "text": "Iterating through the array"
              },
              {
                "id": "d",
                "text": "Returning the result"
              }
            ],
            "correct": "b",
            "explanation": "Iteration is already O(n) - you must look at each element once. The bottleneck is that for each element, you're doing O(n) membership check. Make that O(1), and you get O(n) overall.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Which data structure provides O(1) average membership checking?",
            "options": [
              {
                "id": "a",
                "text": "Array"
              },
              {
                "id": "b",
                "text": "Linked List"
              },
              {
                "id": "c",
                "text": "Hash Set"
              },
              {
                "id": "d",
                "text": "Binary Search Tree"
              }
            ],
            "correct": "c",
            "explanation": "Hash sets use hashing to achieve O(1) average insert and lookup. Arrays need O(n) scan, linked lists need O(n) traversal, BSTs need O(log n) traversal.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Complete the algorithm:\n1. Create empty hash set\n2. For each number in array:\n   a. If number is in set → ___\n   b. If number is not in set → ___",
            "options": [
              {
                "id": "a",
                "text": "return false; add to set"
              },
              {
                "id": "b",
                "text": "return true; add to set"
              },
              {
                "id": "c",
                "text": "add to set; return true"
              },
              {
                "id": "d",
                "text": "add to set; return false"
              }
            ],
            "correct": "b",
            "explanation": "If you find the number already in the set, you've found a duplicate → return true immediately. Otherwise, add it to track it for future checks.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "What should the function return if the loop completes without finding a duplicate?",
            "options": [
              {
                "id": "a",
                "text": "true"
              },
              {
                "id": "b",
                "text": "false"
              },
              {
                "id": "c",
                "text": "null"
              },
              {
                "id": "d",
                "text": "-1"
              }
            ],
            "correct": "b",
            "explanation": "If you check every element and never find one already in the set, all elements are unique → no duplicate exists → return false.",
            "conceptId": "hash-set"
          }
        ],
        "oneLiner": "When you need to answer 'have I seen this before?' in O(1), use a hash set.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "The bottleneck is the \"have I seen this?\" lookup.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "contains duplicate",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def containsDuplicate(nums: List[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False"
      },
      {
        "id": "02-valid-anagram",
        "slug": "valid-anagram",
        "title": "Valid Anagram",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "valid-anagram"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.\n\nAn **anagram** is a word formed by rearranging the letters of another word, using all the original letters exactly once.\n\n**Constraint:** `s` and `t` consist of lowercase English letters only.",
        "examples": [
          {
            "input": "s = \"anagram\", t = \"nagaram\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"rat\", t = \"car\"",
            "output": "false",
            "explanation": ""
          },
          {
            "input": "s = \"a\", t = \"a\"",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If two strings are anagrams, what must be true about their lengths?",
            "options": [
              {
                "id": "a",
                "text": "s must be longer than t"
              },
              {
                "id": "b",
                "text": "s must be shorter than t"
              },
              {
                "id": "c",
                "text": "Lengths must be equal"
              },
              {
                "id": "d",
                "text": "Length doesn't matter"
              }
            ],
            "correct": "c",
            "explanation": "Anagrams use all original letters exactly once. If lengths differ, one string has letters the other doesn't. This is a quick O(1) early exit check.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Two strings are anagrams if they have the same ___ for each character.",
            "options": [
              {
                "id": "a",
                "text": "Position"
              },
              {
                "id": "b",
                "text": "ASCII value"
              },
              {
                "id": "c",
                "text": "Frequency/count"
              },
              {
                "id": "d",
                "text": "Case"
              }
            ],
            "correct": "c",
            "explanation": "Order (position) doesn't matter - that's the whole point of anagrams. We only care that each letter appears the same number of times in both strings.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Which approach correctly checks if two strings are anagrams?",
            "options": [
              {
                "id": "a",
                "text": "Check if first characters match"
              },
              {
                "id": "b",
                "text": "Count character frequencies and compare"
              },
              {
                "id": "c",
                "text": "Check if strings are equal"
              },
              {
                "id": "d",
                "text": "Check if one is a substring of the other"
              }
            ],
            "correct": "b",
            "explanation": "We need to verify identical character counts. Direct equality check would fail (different order). Substring check is wrong concept entirely.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "What's the best way to store character frequencies?",
            "options": [
              {
                "id": "a",
                "text": "A linked list"
              },
              {
                "id": "b",
                "text": "An array of size 26 (for a-z)"
              },
              {
                "id": "c",
                "text": "A binary tree"
              },
              {
                "id": "d",
                "text": "A stack"
              }
            ],
            "correct": "b",
            "explanation": "Since we only have lowercase letters (a-z), a fixed-size array of 26 integers is perfect. Index 0 = 'a' count, index 1 = 'b' count, etc. Hash map also works but array is simpler and faster for fixed alphabet.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Which algorithm correctly determines if s and t are anagrams?",
            "options": [
              {
                "id": "a",
                "text": "Sort both strings, check if equal"
              },
              {
                "id": "b",
                "text": "Count chars in s, count chars in t, compare counts"
              },
              {
                "id": "c",
                "text": "For each char in s, check if it exists in t"
              },
              {
                "id": "d",
                "text": "Both A and B work"
              }
            ],
            "correct": "d",
            "explanation": "Both approaches work! Sorting: O(n log n) time, O(1) space if in-place. Counting: O(n) time, O(1) space for fixed alphabet. Option C doesn't account for frequency - \"aab\" would match \"ab\" incorrectly.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Instead of two count arrays, we can use one. How?",
            "options": [
              {
                "id": "a",
                "text": "Count s, then verify against t by decrementing"
              },
              {
                "id": "b",
                "text": "Count only the longer string"
              },
              {
                "id": "c",
                "text": "Count only vowels"
              },
              {
                "id": "d",
                "text": "This isn't possible"
              }
            ],
            "correct": "a",
            "explanation": "Build counts from s (increment). Then process t (decrement). If any count goes negative, t has a char that s doesn't have enough of → not anagram. If all counts are zero at end → anagram.",
            "conceptId": "frequency-count"
          }
        ],
        "oneLiner": "Anagram = same character frequencies. Count and compare.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "You don't care about order. You care about frequency.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "valid anagram",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    for c in t:\n        count[ord(c) - ord('a')] -= 1\n        if count[ord(c) - ord('a')] < 0:\n            return False\n    return True"
      },
      {
        "id": "03-two-sum",
        "slug": "two-sum",
        "title": "Two Sum",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "two-sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of integers `nums` and an integer `target`, return the **indices** of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.\n\nYou can return the answer in any order.",
        "examples": [
          {
            "input": "nums = [2, 7, 11, 15], target = 9",
            "output": "[0, 1]",
            "explanation": "nums[0] + nums[1] = 2 + 7 = 9"
          },
          {
            "input": "nums = [3, 2, 4], target = 6",
            "output": "[1, 2]",
            "explanation": "nums[1] + nums[2] = 2 + 4 = 6"
          },
          {
            "input": "nums = [3, 3], target = 6",
            "output": "[0, 1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If the target is 9 and the current number is 4, what specific value are you looking for?",
            "options": [
              {
                "id": "a",
                "text": "Any number greater than 4"
              },
              {
                "id": "b",
                "text": "Any number less than 9"
              },
              {
                "id": "c",
                "text": "The number 5"
              },
              {
                "id": "d",
                "text": "The number 4"
              }
            ],
            "correct": "c",
            "explanation": "If current = 4 and target = 9, the complement is 9 - 4 = 5. We're not looking for \"some number\" - we're looking for exactly 5.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "For each number in the array, the main operation is:",
            "options": [
              {
                "id": "a",
                "text": "Compare with adjacent elements"
              },
              {
                "id": "b",
                "text": "Check if its complement exists in what we've seen"
              },
              {
                "id": "c",
                "text": "Sort it into position"
              },
              {
                "id": "d",
                "text": "Count its occurrences"
              }
            ],
            "correct": "b",
            "explanation": "The key operation is complement lookup. \"Does (target - current) exist in our collection?\"",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Why is a hash map better than an array for storing seen numbers?",
            "options": [
              {
                "id": "a",
                "text": "Hash maps are always faster"
              },
              {
                "id": "b",
                "text": "Arrays can't store negative numbers"
              },
              {
                "id": "c",
                "text": "Hash map gives O(1) lookup by value"
              },
              {
                "id": "d",
                "text": "Arrays use more memory"
              }
            ],
            "correct": "c",
            "explanation": "We need to look up \"does value X exist?\" - this requires searching by value. Arrays give O(1) lookup by index, but O(n) lookup by value. Hash maps give O(1) lookup by key (the value itself).",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "The hash map should store:",
            "options": [
              {
                "id": "a",
                "text": "index → value"
              },
              {
                "id": "b",
                "text": "value → index"
              },
              {
                "id": "c",
                "text": "value → count"
              },
              {
                "id": "d",
                "text": "index → index"
              }
            ],
            "correct": "b",
            "explanation": "We search BY value (the complement) and we need to RETURN the index. So: key = value, stored data = index.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "For each number, which order is correct?",
            "options": [
              {
                "id": "a",
                "text": "Add to map, then check for complement"
              },
              {
                "id": "b",
                "text": "Check for complement, then add to map"
              },
              {
                "id": "c",
                "text": "Check for complement only"
              },
              {
                "id": "d",
                "text": "Add to map only"
              }
            ],
            "correct": "b",
            "explanation": "Check first, add second. If you add first, you might match a number with itself (when complement == current and they're the same element).",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Given nums = [3, 3], target = 6. Why does checking before adding work?",
            "options": [
              {
                "id": "a",
                "text": "It doesn't work for this case"
              },
              {
                "id": "b",
                "text": "First 3 is added, second 3 finds complement"
              },
              {
                "id": "c",
                "text": "Both 3s are added simultaneously"
              },
              {
                "id": "d",
                "text": "We need special handling for duplicates"
              }
            ],
            "correct": "b",
            "explanation": "Process first 3: check for 3 (not found), add 3→0. Process second 3: check for 3 (found at index 0!), return [0, 1]. The order ensures we don't match an element with itself.",
            "conceptId": "hash-map"
          }
        ],
        "oneLiner": "For pair problems, don't search for pairs. Calculate the complement and look it up.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "You're not searching for \"any pair.\" You're searching for a specific value.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "two sum",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def twoSum(nums: List[int], target: int) -> List[int]:\n    seen = {}  # value -> index\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []"
      },
      {
        "id": "04-group-anagrams",
        "slug": "group-anagrams",
        "title": "Group Anagrams",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "group-anagrams"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.",
        "examples": [
          {
            "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
            "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "explanation": ""
          },
          {
            "input": "strs = [\"\"]",
            "output": "[[\"\"]]",
            "explanation": ""
          },
          {
            "input": "strs = [\"a\"]",
            "output": "[[\"a\"]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What's the main challenge in grouping anagrams?",
            "options": [
              {
                "id": "a",
                "text": "Sorting the strings alphabetically"
              },
              {
                "id": "b",
                "text": "Finding a way to identify which strings are anagrams"
              },
              {
                "id": "c",
                "text": "Counting the total number of strings"
              },
              {
                "id": "d",
                "text": "Finding the longest string"
              }
            ],
            "correct": "b",
            "explanation": "We need a method to determine \"these strings belong together\" without comparing every pair (which would be O(n²)).",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "What property is IDENTICAL for all anagrams of the same word?",
            "options": [
              {
                "id": "a",
                "text": "Length only"
              },
              {
                "id": "b",
                "text": "First character"
              },
              {
                "id": "c",
                "text": "Sorted character sequence"
              },
              {
                "id": "d",
                "text": "Number of vowels"
              }
            ],
            "correct": "c",
            "explanation": "Sorting the characters produces the same result for all anagrams. \"eat\"→\"aet\", \"tea\"→\"aet\". This sorted form is called a **signature** - a canonical representation that's identical for all anagrams of the same word. Length is necessary but not sufficient (many non-anagrams have same length).",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "To group strings by their signature, what data structure is best?",
            "options": [
              {
                "id": "a",
                "text": "Array of arrays"
              },
              {
                "id": "b",
                "text": "Hash map: signature → list of strings"
              },
              {
                "id": "c",
                "text": "Set of strings"
              },
              {
                "id": "d",
                "text": "Queue"
              }
            ],
            "correct": "b",
            "explanation": "We need to map each signature to all strings that share it. Hash map gives O(1) lookup by signature, and stores the list of matching strings.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "What is the time complexity difference between sorted vs count signatures?",
            "options": [
              {
                "id": "a",
                "text": "Sorted is always better"
              },
              {
                "id": "b",
                "text": "Count is always better"
              },
              {
                "id": "c",
                "text": "Sorted: O(k log k) per string. Count: O(k) per string"
              },
              {
                "id": "d",
                "text": "They have identical performance"
              }
            ],
            "correct": "c",
            "explanation": "For string of length k, sorting is O(k log k), counting is O(k). For very long strings, counting is faster. For short strings, difference is negligible.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "After processing all strings, the hash map values are:",
            "options": [
              {
                "id": "a",
                "text": "The signatures"
              },
              {
                "id": "b",
                "text": "The groups of anagrams"
              },
              {
                "id": "c",
                "text": "The indices of strings"
              },
              {
                "id": "d",
                "text": "The counts of each group"
              }
            ],
            "correct": "b",
            "explanation": "The map is signature → [list of strings with that signature]. The values are exactly the groups we need to return.",
            "conceptId": "hash-map"
          }
        ],
        "oneLiner": "To group anagrams, use a canonical form (sorted or char-count) as hash key.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "All anagrams share the same \"signature.\"",
        "timeComplexity": "O(n * k log k)",
        "spaceComplexity": "O(n * k)",
        "triggerWords": [
          "group anagrams",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def groupAnagrams(strs: List[str]) -> List[List[str]]:\n    groups = defaultdict(list)\n    for s in strs:\n        # Use sorted string as signature\n        key = ''.join(sorted(s))\n        groups[key].append(s)\n    return list(groups.values())"
      },
      {
        "id": "05-top-k-frequent-elements",
        "slug": "top-k-frequent-elements",
        "title": "Top K Frequent Elements",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "top-k-frequent-elements"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.",
        "examples": [
          {
            "input": "nums = [1,1,1,2,2,3], k = 2",
            "output": "[1,2]",
            "explanation": ""
          },
          {
            "input": "nums = [1], k = 1",
            "output": "[1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What's the first thing you need to compute?",
            "options": [
              {
                "id": "a",
                "text": "The maximum element"
              },
              {
                "id": "b",
                "text": "The frequency of each element"
              },
              {
                "id": "c",
                "text": "The sorted array"
              },
              {
                "id": "d",
                "text": "The median"
              }
            ],
            "correct": "b",
            "explanation": "You can't find \"most frequent\" without knowing frequencies.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Best data structure for counting frequencies?",
            "options": [
              {
                "id": "a",
                "text": "Array (if values are bounded and non-negative)"
              },
              {
                "id": "b",
                "text": "Hash map (for general case)"
              },
              {
                "id": "c",
                "text": "Stack"
              },
              {
                "id": "d",
                "text": "Queue"
              }
            ],
            "correct": "b",
            "explanation": "Hash map handles any value range efficiently. Array works too if values are small non-negative integers.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "After counting frequencies, how do you find the top k?",
            "options": [
              {
                "id": "a",
                "text": "Sort all elements by frequency, take first k"
              },
              {
                "id": "b",
                "text": "Use a min-heap of size k"
              },
              {
                "id": "c",
                "text": "Use bucket sort by frequency"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "All work. They differ in time complexity: Sort is O(n log n), Heap is O(n log k), Bucket is O(n).",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Why can we use bucket sort for this problem?",
            "options": [
              {
                "id": "a",
                "text": "Elements are already sorted"
              },
              {
                "id": "b",
                "text": "Frequencies have a bounded range (1 to n)"
              },
              {
                "id": "c",
                "text": "There are only k elements"
              },
              {
                "id": "d",
                "text": "All frequencies are unique"
              }
            ],
            "correct": "b",
            "explanation": "Bucket sort requires a bounded range. Frequency of any element is between 1 and n (total elements). This is a limited range we can bucket into.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "In bucket sort approach, bucket[i] contains:",
            "options": [
              {
                "id": "a",
                "text": "Elements with value i"
              },
              {
                "id": "b",
                "text": "Elements that appear i times"
              },
              {
                "id": "c",
                "text": "The i-th largest element"
              },
              {
                "id": "d",
                "text": "The count of element i"
              }
            ],
            "correct": "b",
            "explanation": "We're bucketing by frequency, not by value. Bucket[3] holds all elements that appear exactly 3 times.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "To get top k frequent, iterate buckets in which order?",
            "options": [
              {
                "id": "a",
                "text": "Bucket 0 to bucket n (ascending frequency)"
              },
              {
                "id": "b",
                "text": "Bucket n to bucket 0 (descending frequency)"
              },
              {
                "id": "c",
                "text": "Random order"
              },
              {
                "id": "d",
                "text": "Order doesn't matter"
              }
            ],
            "correct": "b",
            "explanation": "We want most frequent first. Start from highest frequency bucket (n), work down until we've collected k elements.",
            "conceptId": "frequency-count"
          }
        ],
        "oneLiner": "For 'top k by frequency': count with hash map, then either heap (O(n log k)) or bucket sort by frequency (O(n)).",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "Step 1 is straightforward: hash map for frequency counting.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "top k frequent elements",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def topKFrequent(nums: List[int], k: int) -> List[int]:\n    # Step 1: Count frequencies\n    count = Counter(nums)\n    \n    # Step 2: Bucket sort by frequency\n    buckets = [[] for _ in range(len(nums) + 1)]\n    for num, freq in count.items():\n        buckets[freq].append(num)\n    \n    # Step 3: Collect top k from highest buckets\n    result = []\n    for i in range(len(buckets) - 1, 0, -1):\n        for num in buckets[i]:\n            result.append(num)\n            if len(result) == k:\n                return result\n    return result"
      },
      {
        "id": "06-product-of-array-except-self",
        "slug": "product-of-array-except-self",
        "title": "Product of Array Except Self",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "product-of-array-except-self"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\nYou must write an algorithm that runs in O(n) time and **without using the division operation**.",
        "examples": [
          {
            "input": "nums = [1,2,3,4]",
            "output": "[24,12,8,6]",
            "explanation": ""
          },
          {
            "input": "nums = [-1,1,0,-3,3]",
            "output": "[0,0,9,0,0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If division were allowed, the solution would be:",
            "options": [
              {
                "id": "a",
                "text": "Sort the array and take middle element"
              },
              {
                "id": "b",
                "text": "Compute total product, divide by each element"
              },
              {
                "id": "c",
                "text": "Add all elements and subtract each one"
              },
              {
                "id": "d",
                "text": "Division wouldn't help here"
              }
            ],
            "correct": "b",
            "explanation": "Total product / nums[i] = product of all others. But the problem forbids division, likely to handle zeros properly (division by zero) or as a learning exercise.",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "Product of all elements except nums[i] equals:",
            "options": [
              {
                "id": "a",
                "text": "Sum of all other elements"
              },
              {
                "id": "b",
                "text": "Maximum of all other elements"
              },
              {
                "id": "c",
                "text": "(Product of elements before i) × (Product of elements after i)"
              },
              {
                "id": "d",
                "text": "Product of adjacent elements"
              }
            ],
            "correct": "c",
            "explanation": "This decomposition avoids needing nums[i] itself. We multiply everything to the left with everything to the right.",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "prefix[i] represents:",
            "options": [
              {
                "id": "a",
                "text": "nums[0] + nums[1] + ... + nums[i]"
              },
              {
                "id": "b",
                "text": "nums[0] × nums[1] × ... × nums[i-1]"
              },
              {
                "id": "c",
                "text": "The maximum from 0 to i"
              },
              {
                "id": "d",
                "text": "The count of elements before i"
              }
            ],
            "correct": "b",
            "explanation": "Prefix product at i is the product of all elements BEFORE index i (exclusive of i).",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "suffix[i] represents:",
            "options": [
              {
                "id": "a",
                "text": "nums[i+1] × nums[i+2] × ... × nums[n-1]"
              },
              {
                "id": "b",
                "text": "nums[i] × nums[i+1] × ... × nums[n-1]"
              },
              {
                "id": "c",
                "text": "The sum of elements after i"
              },
              {
                "id": "d",
                "text": "The count of elements after i"
              }
            ],
            "correct": "a",
            "explanation": "Suffix product at i is the product of all elements AFTER index i (exclusive of i).",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "The answer for position i is:",
            "options": [
              {
                "id": "a",
                "text": "prefix[i] + suffix[i]"
              },
              {
                "id": "b",
                "text": "prefix[i] × suffix[i]"
              },
              {
                "id": "c",
                "text": "max(prefix[i], suffix[i])"
              },
              {
                "id": "d",
                "text": "prefix[i] - suffix[i]"
              }
            ],
            "correct": "b",
            "explanation": "Product of everything before × product of everything after = product of everything except nums[i].",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "We can reduce from O(n) extra space to O(1) by:",
            "options": [
              {
                "id": "a",
                "text": "Not storing the result"
              },
              {
                "id": "b",
                "text": "Computing prefix in result array, then multiplying suffix on second pass"
              },
              {
                "id": "c",
                "text": "Using recursion instead"
              },
              {
                "id": "d",
                "text": "It's not possible to optimize space"
              }
            ],
            "correct": "b",
            "explanation": "First pass: fill result with prefix products. Second pass: multiply each result[i] by running suffix product. We only need a single variable for the running suffix.",
            "conceptId": "prefix-sum"
          }
        ],
        "oneLiner": "Product except self = prefix product × suffix product. Compute in two passes.",
        "pattern": "Prefix/Suffix Arrays",
        "keyInsight": "Product of all except nums[i] = (product of everything left of i) × (product of everything right of i)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "product of array except self",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def productExceptSelf(nums: List[int]) -> List[int]:\n    n = len(nums)\n    result = [1] * n\n    \n    # First pass: compute prefix products\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n    \n    # Second pass: multiply by suffix products\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n    \n    return result"
      },
      {
        "id": "07-valid-sudoku",
        "slug": "valid-sudoku",
        "title": "Valid Sudoku",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "valid-sudoku"
        ],
        "estimatedTime": 5,
        "problemStatement": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n1. Each row must contain the digits 1-9 without repetition\n2. Each column must contain the digits 1-9 without repetition\n3. Each of the nine 3 x 3 sub-boxes must contain the digits 1-9 without repetition\n\n**Note:** A Sudoku board (partially filled) could be valid but not necessarily solvable. Only validate filled cells.",
        "examples": [
          {
            "input": "board =",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "board =",
            "output": "false",
            "explanation": "The first column has two 8s"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "How many different duplicate checks does valid Sudoku require?",
            "options": [
              {
                "id": "a",
                "text": "1 (just the whole board)"
              },
              {
                "id": "b",
                "text": "9 (just the rows)"
              },
              {
                "id": "c",
                "text": "27 (9 rows + 9 columns + 9 boxes)"
              },
              {
                "id": "d",
                "text": "81 (every cell)"
              }
            ],
            "correct": "c",
            "explanation": "Each row (9), each column (9), each 3×3 box (9) must have no duplicates = 27 separate checks.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "For each row/column/box, what operation detects invalidity?",
            "options": [
              {
                "id": "a",
                "text": "Checking if sum equals 45"
              },
              {
                "id": "b",
                "text": "Checking if any digit appears more than once"
              },
              {
                "id": "c",
                "text": "Checking if all digits are present"
              },
              {
                "id": "d",
                "text": "Checking if digits are sorted"
              }
            ],
            "correct": "b",
            "explanation": "We only need to check filled cells. A partial board might not have all digits, but no digit should repeat.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Best structure to check for duplicates as you scan?",
            "options": [
              {
                "id": "a",
                "text": "Array of booleans (seen[1..9])"
              },
              {
                "id": "b",
                "text": "Hash set"
              },
              {
                "id": "c",
                "text": "Counter"
              },
              {
                "id": "d",
                "text": "Both A and B work"
              }
            ],
            "correct": "d",
            "explanation": "Both work for O(1) lookup. Array is slightly more efficient for fixed range 1-9, but hash set is more general.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Cell (5, 7) belongs to which 3×3 box?",
            "options": [
              {
                "id": "a",
                "text": "Box 0"
              },
              {
                "id": "b",
                "text": "Box 2"
              },
              {
                "id": "c",
                "text": "Box 5"
              },
              {
                "id": "d",
                "text": "Box 8"
              }
            ],
            "correct": "c",
            "explanation": "row=5, col=7. Box = (5//3)*3 + (7//3) = 1*3 + 2 = 5",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Return false immediately when:",
            "options": [
              {
                "id": "a",
                "text": "A cell contains a non-digit character"
              },
              {
                "id": "b",
                "text": "A digit is already in the set for its row, column, OR box"
              },
              {
                "id": "c",
                "text": "The board has empty cells"
              },
              {
                "id": "d",
                "text": "A row has less than 9 filled cells"
              }
            ],
            "correct": "b",
            "explanation": "Any single duplicate (in any row, column, or box) makes the board invalid. Empty cells ('.') are allowed.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Can we check all constraints in a single pass through the board?",
            "options": [
              {
                "id": "a",
                "text": "No, we need 3 separate passes"
              },
              {
                "id": "b",
                "text": "Yes, update row, column, and box sets simultaneously"
              },
              {
                "id": "c",
                "text": "Yes, but it requires sorting first"
              },
              {
                "id": "d",
                "text": "It depends on the board state"
              }
            ],
            "correct": "b",
            "explanation": "For each cell, we know its row index, column index, and can compute box index. Update all three sets at once.",
            "conceptId": "hash-set"
          }
        ],
        "oneLiner": "Valid Sudoku = no duplicates in any row, column, or 3×3 box. Use sets for each, compute box index with (r//3)*3 + (c//3).",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "For each constraint, use a hash set to track seen digits.",
        "timeComplexity": "O(81)",
        "spaceComplexity": "O(81)",
        "triggerWords": [
          "valid sudoku",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isValidSudoku(board: List[List[str]]) -> bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    \n    for r in range(9):\n        for c in range(9):\n            if board[r][c] == '.':\n                continue\n            \n            num = board[r][c]\n            box_idx = (r // 3) * 3 + (c // 3)\n            \n            if num in rows[r] or num in cols[c] or num in boxes[box_idx]:\n                return False\n            \n            rows[r].add(num)\n            cols[c].add(num)\n            boxes[box_idx].add(num)\n    \n    return True"
      },
      {
        "id": "08-longest-consecutive-sequence",
        "slug": "longest-consecutive-sequence",
        "title": "Longest Consecutive Sequence",
        "category": "arrays-and-hashing",
        "difficulty": "easy",
        "tags": [
          "arrays-and-hashing",
          "longest-consecutive-sequence"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.",
        "examples": [
          {
            "input": "nums = [100, 4, 200, 1, 3, 2]",
            "output": "4",
            "explanation": "The longest consecutive sequence is [1, 2, 3, 4]. Length = 4."
          },
          {
            "input": "nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]",
            "output": "9",
            "explanation": "[0, 1, 2, 3, 4, 5, 6, 7, 8]. Length = 9."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Sorting would make consecutive numbers adjacent. Why not use it?",
            "options": [
              {
                "id": "a",
                "text": "Sorting doesn't work for this problem"
              },
              {
                "id": "b",
                "text": "Sorting is O(n log n), problem requires O(n)"
              },
              {
                "id": "c",
                "text": "Sorting uses too much space"
              },
              {
                "id": "d",
                "text": "Sorted arrays can't have consecutive sequences"
              }
            ],
            "correct": "b",
            "explanation": "Sorting works logically, but violates the O(n) time requirement.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "To quickly check \"does number X exist in the array?\", use:",
            "options": [
              {
                "id": "a",
                "text": "Sorted array with binary search"
              },
              {
                "id": "b",
                "text": "Hash set"
              },
              {
                "id": "c",
                "text": "Linked list"
              },
              {
                "id": "d",
                "text": "Stack"
              }
            ],
            "correct": "b",
            "explanation": "Hash set gives O(1) average lookup. Convert array to set first.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "If we try to extend a sequence from EVERY number:\n\nnums = [1, 2, 3, 4]\n\nStarting from 1: count 1→2→3→4, length 4\nStarting from 2: count 2→3→4, length 3\nStarting from 3: count 3→4, length 2\nStarting from 4: count 4, length 1\n\nWhat's wrong?",
            "options": [
              {
                "id": "a",
                "text": "We get the wrong answer"
              },
              {
                "id": "b",
                "text": "We're recounting overlapping sequences"
              },
              {
                "id": "c",
                "text": "The hash lookups fail"
              },
              {
                "id": "d",
                "text": "Nothing is wrong"
              }
            ],
            "correct": "b",
            "explanation": "Each number in the sequence triggers a partial recount. This gives O(n²) worst case.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "How do we ensure each sequence is counted exactly once?",
            "options": [
              {
                "id": "a",
                "text": "Sort the array first"
              },
              {
                "id": "b",
                "text": "Only start counting from the smallest number overall"
              },
              {
                "id": "c",
                "text": "Only start counting if (num - 1) is NOT in the set"
              },
              {
                "id": "d",
                "text": "Only count increasing sequences"
              }
            ],
            "correct": "c",
            "explanation": "If num-1 exists, then num is not the start of its sequence — some earlier number will count it. Only true \"sequence starts\" trigger counting.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "In nums = [100, 4, 200, 1, 3, 2], which numbers are sequence starts?",
            "options": [
              {
                "id": "a",
                "text": "All of them"
              },
              {
                "id": "b",
                "text": "100, 200, 1"
              },
              {
                "id": "c",
                "text": "1, 2, 3, 4"
              },
              {
                "id": "d",
                "text": "100"
              }
            ],
            "correct": "b",
            "explanation": "1 is a start (0 not in set). 100 is a start (99 not in set). 200 is a start (199 not in set). 2, 3, 4 are NOT starts because their predecessors exist.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "Starting from num = 1, how do we find the sequence length?",
            "options": [
              {
                "id": "a",
                "text": "Count how many times 1 appears"
              },
              {
                "id": "b",
                "text": "Check if 2, 3, 4, ... exist until one doesn't"
              },
              {
                "id": "c",
                "text": "Binary search for the endpoint"
              },
              {
                "id": "d",
                "text": "Check if 0, -1, -2, ... exist"
              }
            ],
            "correct": "b",
            "explanation": "From a start, extend right: does num+1 exist? Does num+2 exist? Count until you hit a gap.",
            "conceptId": "hash-set"
          }
        ],
        "oneLiner": "Only count from sequence starts (where num-1 doesn't exist). This ensures O(n) — each number is visited at most twice.",
        "pattern": "Hash Set / Hash Map",
        "keyInsight": "Only start counting from sequence BEGINNINGS.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "longest consecutive sequence",
          "arrays-and-hashing"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def longestConsecutive(nums: List[int]) -> int:\n    num_set = set(nums)\n    longest = 0\n    \n    for num in num_set:\n        # Only start counting from sequence beginnings\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n            \n            while current + 1 in num_set:\n                current += 1\n                length += 1\n            \n            longest = max(longest, length)\n    \n    return longest"
      }
    ],
    "two-pointers": [
      {
        "id": "01-valid-palindrome",
        "slug": "valid-palindrome",
        "title": "Valid Palindrome",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "valid-palindrome"
        ],
        "estimatedTime": 5,
        "problemStatement": "A phrase is a **palindrome** if, after converting all uppercase letters to lowercase and removing all non-alphanumeric characters, it reads the same forward and backward.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
        "examples": [
          {
            "input": "s = \"A man, a plan, a canal: Panama\"",
            "output": "true",
            "explanation": "\"amanaplanacanalpanama\" is a palindrome"
          },
          {
            "input": "s = \"race a car\"",
            "output": "false",
            "explanation": "\"raceacar\" is not a palindrome"
          },
          {
            "input": "s = \" \"",
            "output": "true",
            "explanation": "Empty string after removing non-alphanumeric = palindrome"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What must be true for a string to be a palindrome?",
            "options": [
              {
                "id": "a",
                "text": "All characters are the same"
              },
              {
                "id": "b",
                "text": "Characters at position i equal characters at position (n-1-i)"
              },
              {
                "id": "c",
                "text": "Characters are in alphabetical order"
              },
              {
                "id": "d",
                "text": "The string has odd length"
              }
            ],
            "correct": "b",
            "explanation": "Position 0 must equal position n-1, position 1 must equal position n-2, etc. Mirror symmetry.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Why use two pointers instead of creating a reversed copy?",
            "options": [
              {
                "id": "a",
                "text": "Two pointers can't solve this"
              },
              {
                "id": "b",
                "text": "Two pointers use O(1) space vs O(n) for reverse"
              },
              {
                "id": "c",
                "text": "Two pointers are slower"
              },
              {
                "id": "d",
                "text": "Reversing doesn't work for palindromes"
              }
            ],
            "correct": "b",
            "explanation": "Reversing creates a new string (O(n) space). Two pointers compare in-place.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If s[left] == s[right], what do you do?",
            "options": [
              {
                "id": "a",
                "text": "Return true"
              },
              {
                "id": "b",
                "text": "Move left pointer left"
              },
              {
                "id": "c",
                "text": "Move left pointer right AND right pointer left"
              },
              {
                "id": "d",
                "text": "Reset both pointers"
              }
            ],
            "correct": "c",
            "explanation": "Characters match, move inward to check the next pair.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "When left pointer is at a space or punctuation:",
            "options": [
              {
                "id": "a",
                "text": "Return false"
              },
              {
                "id": "b",
                "text": "Skip it by moving left pointer right"
              },
              {
                "id": "c",
                "text": "Compare it anyway"
              },
              {
                "id": "d",
                "text": "Remove it from the string"
              }
            ],
            "correct": "b",
            "explanation": "Non-alphanumeric chars don't count. Skip them without comparison.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "When do the pointers stop moving?",
            "options": [
              {
                "id": "a",
                "text": "When they find a mismatch"
              },
              {
                "id": "b",
                "text": "When left >= right"
              },
              {
                "id": "c",
                "text": "When they reach the string ends"
              },
              {
                "id": "d",
                "text": "After n iterations"
              }
            ],
            "correct": "b",
            "explanation": "When pointers cross or meet, we've checked all pairs. If no mismatch found, it's a palindrome.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If s[left] ≠ s[right] (after skipping non-alphanumeric and case conversion):",
            "options": [
              {
                "id": "a",
                "text": "Move both pointers"
              },
              {
                "id": "b",
                "text": "Return true"
              },
              {
                "id": "c",
                "text": "Return false immediately"
              },
              {
                "id": "d",
                "text": "Try different characters"
              }
            ],
            "correct": "c",
            "explanation": "A single mismatch proves it's not a palindrome. Early exit.",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "Palindrome check = two pointers from ends moving inward, comparing cleaned characters.",
        "pattern": "Two Pointers",
        "keyInsight": "Compare characters from both ends, moving inward.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "valid palindrome",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isPalindrome(s: str) -> bool:\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric from left\n        while left < right and not s[left].isalnum():\n            left += 1\n        # Skip non-alphanumeric from right\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Compare characters (case-insensitive)\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True"
      },
      {
        "id": "02-two-sum-ii",
        "slug": "two-sum-ii",
        "title": "Two Sum II - Input Array Is Sorted",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "two-sum-ii-input-array-is-sorted"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a **1-indexed** array of integers `numbers` that is already **sorted in non-decreasing order**, find two numbers such that they add up to a specific `target` number.\n\nReturn the indices of the two numbers (1-indexed) as an integer array `[index1, index2]`.\n\nYou may not use the same element twice. There is exactly one solution.\n\n**Constraint:** Must use only constant extra space.",
        "examples": [
          {
            "input": "numbers = [2,7,11,15], target = 9",
            "output": "[1,2]",
            "explanation": "2 + 7 = 9. Index1 = 1, Index2 = 2."
          },
          {
            "input": "numbers = [2,3,4], target = 6",
            "output": "[1,3]",
            "explanation": ""
          },
          {
            "input": "numbers = [-1,0], target = -1",
            "output": "[1,2]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The problem requires O(1) space. Why does hash map violate this?",
            "options": [
              {
                "id": "a",
                "text": "Hash maps are slow"
              },
              {
                "id": "b",
                "text": "Hash maps use O(n) space"
              },
              {
                "id": "c",
                "text": "Hash maps don't work with sorted arrays"
              },
              {
                "id": "d",
                "text": "We can use hash map, the constraint is wrong"
              }
            ],
            "correct": "b",
            "explanation": "Hash map stores up to n elements. The problem explicitly requires constant space.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Because the array is sorted, if nums[L] + nums[R] < target, we know:",
            "options": [
              {
                "id": "a",
                "text": "The answer doesn't exist"
              },
              {
                "id": "b",
                "text": "We need a larger sum, so move L right"
              },
              {
                "id": "c",
                "text": "We need a smaller sum, so move R left"
              },
              {
                "id": "d",
                "text": "We should try different elements randomly"
              }
            ],
            "correct": "b",
            "explanation": "Moving L right gives us a larger number on the left, increasing the sum. Moving R left would decrease sum further — wrong direction.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If nums[L] + nums[R] > target, we should:",
            "options": [
              {
                "id": "a",
                "text": "Move L right (increase sum)"
              },
              {
                "id": "b",
                "text": "Move R left (decrease sum)"
              },
              {
                "id": "c",
                "text": "Move both pointers"
              },
              {
                "id": "d",
                "text": "Return no solution"
              }
            ],
            "correct": "b",
            "explanation": "Sum too big → need smaller numbers → only way is to move R left (can't move L left, it's already as far left as possible relative to our search).",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Why are we guaranteed to find the answer (if it exists) with this approach?",
            "options": [
              {
                "id": "a",
                "text": "We try all pairs eventually"
              },
              {
                "id": "b",
                "text": "Each move eliminates impossible candidates while preserving the answer"
              },
              {
                "id": "c",
                "text": "Sorted arrays always have a two-sum solution"
              },
              {
                "id": "d",
                "text": "We use random chance"
              }
            ],
            "correct": "b",
            "explanation": "When we move L right (sum too small), we eliminate all pairs with current L because they'd all be too small. Answer is preserved because it needs a larger left value. Similarly for moving R.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "The loop terminates when:",
            "options": [
              {
                "id": "a",
                "text": "We find the answer (sum == target)"
              },
              {
                "id": "b",
                "text": "Pointers cross (L >= R) meaning no solution"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "After n iterations"
              }
            ],
            "correct": "c",
            "explanation": "Either we find it and return, or pointers cross (which shouldn't happen given \"exactly one solution\" guarantee, but is the logical stopping point).",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "In sorted arrays, two pointers from ends let you search in O(n) time, O(1) space — sum too small means move left pointer right, too big means move right pointer left.",
        "pattern": "Two Pointers",
        "keyInsight": "In a sorted array, the sum of two elements tells you how to adjust.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "two sum ii - input array is sorted",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def twoSum(numbers: List[int], target: int) -> List[int]:\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # 1-indexed\n        elif current_sum < target:\n            left += 1  # Need larger sum\n        else:\n            right -= 1  # Need smaller sum\n    \n    return []  # No solution found"
      },
      {
        "id": "03-three-sum",
        "slug": "three-sum",
        "title": "3Sum",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "3sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nThe solution set must not contain duplicate triplets.",
        "examples": [
          {
            "input": "nums = [-1,0,1,2,-1,-4]",
            "output": "[[-1,-1,2],[-1,0,1]]",
            "explanation": ""
          },
          {
            "input": "nums = [0,1,1]",
            "output": "[]",
            "explanation": "No triplets sum to 0."
          },
          {
            "input": "nums = [0,0,0]",
            "output": "[[0,0,0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If we fix one element nums[i], what remains?",
            "options": [
              {
                "id": "a",
                "text": "A 3Sum problem on the rest"
              },
              {
                "id": "b",
                "text": "A 2Sum problem with target = -nums[i]"
              },
              {
                "id": "c",
                "text": "A 1Sum problem"
              },
              {
                "id": "d",
                "text": "An unsolvable problem"
              }
            ],
            "correct": "b",
            "explanation": "nums[i] + nums[j] + nums[k] = 0 means nums[j] + nums[k] = -nums[i]. Two Sum!",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Sorting helps with (select all):",
            "options": [
              {
                "id": "a",
                "text": "Using two-pointer technique for 2Sum"
              },
              {
                "id": "b",
                "text": "Skipping duplicate triplets efficiently"
              },
              {
                "id": "c",
                "text": "Finding the minimum element"
              },
              {
                "id": "d",
                "text": "Both A and B"
              }
            ],
            "correct": "d",
            "explanation": "Sorting enables two-pointer 2Sum (O(n) each) and makes duplicates adjacent (easy to skip).",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After processing i=1 where nums[1]=-1: [-4, -1, -1, 0, 1, 2] ↑ Should we process i=2 where nums[2]=-1?",
            "options": [
              {
                "id": "a",
                "text": "Yes, always process every index"
              },
              {
                "id": "b",
                "text": "No, skip because nums[2] == nums[1]"
              },
              {
                "id": "c",
                "text": "Yes, but use different two-pointer logic"
              },
              {
                "id": "d",
                "text": "It depends on the target"
              }
            ],
            "correct": "b",
            "explanation": "If nums[i] == nums[i-1], we've already found all triplets starting with this value. Skip to avoid duplicates.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "During two-pointer search, after finding a valid triplet: nums = [..., -1, 0, 0, 1, 1, ...] L     ↑     R After finding [..., 0, 1] as part of triplet, we should:",
            "options": [
              {
                "id": "a",
                "text": "Return immediately"
              },
              {
                "id": "b",
                "text": "Move L right, skipping duplicate 0s; move R left, skipping duplicate 1s"
              },
              {
                "id": "c",
                "text": "Only move L, keep R"
              },
              {
                "id": "d",
                "text": "Restart the search"
              }
            ],
            "correct": "b",
            "explanation": "After finding a triplet, continue searching but skip over duplicate values to avoid finding the same triplet again.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "What's the time complexity of 3Sum with this approach?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(n³)"
              }
            ],
            "correct": "c",
            "explanation": "Sorting is O(n log n). For each of n elements (outer loop), we do O(n) two-pointer search. Total: O(n²).",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "3Sum = sort + fix one element + two-pointer 2Sum. Skip duplicates by comparing with previous values.",
        "pattern": "Two Pointers",
        "keyInsight": "3Sum = Fix one element + Two Sum on the rest",
        "timeComplexity": "O(n²)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "3sum",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def threeSum(nums: List[int]) -> List[List[int]]:\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        # Skip duplicate first elements\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        target = -nums[i]\n        \n        while left < right:\n            current_sum = nums[left] + nums[right]\n            \n            if current_sum == target:\n                result.append([nums[i], nums[left], nums[right]])\n                # Skip duplicates\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return result"
      },
      {
        "id": "04-container-with-most-water",
        "slug": "container-with-most-water",
        "title": "Container With Most Water",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "container-with-most-water"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `i`th line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\n**Note:** You may not slant the container.",
        "examples": [
          {
            "input": "height = [1,8,6,2,5,4,8,3,7]",
            "output": "49",
            "explanation": "Lines at index 1 (height 8) and index 8 (height 7)."
          },
          {
            "input": "height = [1,1]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The area of water between lines at positions i and j is:",
            "options": [
              {
                "id": "a",
                "text": "height[i] × height[j]"
              },
              {
                "id": "b",
                "text": "(height[i] + height[j]) × (j - i)"
              },
              {
                "id": "c",
                "text": "min(height[i], height[j]) × (j - i)"
              },
              {
                "id": "d",
                "text": "max(height[i], height[j]) × (j - i)"
              }
            ],
            "correct": "c",
            "explanation": "Water level = shorter line (water would spill over). Width = distance between lines.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Starting with L=0 and R=n-1 gives us:",
            "options": [
              {
                "id": "a",
                "text": "The minimum possible width"
              },
              {
                "id": "b",
                "text": "The maximum possible width"
              },
              {
                "id": "c",
                "text": "Random width"
              },
              {
                "id": "d",
                "text": "The optimal answer immediately"
              }
            ],
            "correct": "b",
            "explanation": "Pointers at extremes = maximum distance = maximum width. This is our starting point.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If height[L] < height[R], which pointer should move?",
            "options": [
              {
                "id": "a",
                "text": "Move L (the shorter one) inward"
              },
              {
                "id": "b",
                "text": "Move R (the taller one) inward"
              },
              {
                "id": "c",
                "text": "Move both"
              },
              {
                "id": "d",
                "text": "Move neither"
              }
            ],
            "correct": "a",
            "explanation": "Moving R inward would decrease width while the height is still limited by L (the shorter). Moving L gives a chance of finding a taller line that could compensate for lost width.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If height[L]=3 and height[R]=7, moving R to a line of height 5:\n\n- Old area: 3 × width\n- New area: min(3, 5) × (width-1) = 3 × (width-1)\n\nWhat happened?",
            "options": [
              {
                "id": "a",
                "text": "Area increased"
              },
              {
                "id": "b",
                "text": "Area decreased"
              },
              {
                "id": "c",
                "text": "Area stayed same"
              },
              {
                "id": "d",
                "text": "Can't determine"
              }
            ],
            "correct": "b",
            "explanation": "The height is still capped at 3 (the short line didn't move). But width decreased. Guaranteed worse or equal, never better.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If height[L]=3 and height[R]=7, moving L to a line of height 6:\n\n- Old area: 3 × width\n- New area: min(6, 7) × (width-1) = 6 × (width-1)\n\nUnder what condition is new area larger?",
            "options": [
              {
                "id": "a",
                "text": "When 6 × (width-1) > 3 × width"
              },
              {
                "id": "b",
                "text": "Never"
              },
              {
                "id": "c",
                "text": "Always"
              },
              {
                "id": "d",
                "text": "When width > 6"
              }
            ],
            "correct": "a",
            "explanation": "Simplify: 6w - 6 > 3w → 3w > 6 → w > 2. If width > 2, moving to a taller line helps!",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Why does always moving the shorter pointer find the global maximum?",
            "options": [
              {
                "id": "a",
                "text": "It doesn't always work"
              },
              {
                "id": "b",
                "text": "We try all promising pairs; moving taller pointer only finds worse solutions"
              },
              {
                "id": "c",
                "text": "Luck"
              },
              {
                "id": "d",
                "text": "The array is sorted"
              }
            ],
            "correct": "b",
            "explanation": "Moving the taller pointer can never improve (height capped, width decreasing). We're not missing any potentially better solutions by moving the shorter one.",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "Start wide, greedily sacrifice width by moving the shorter line inward — only way to potentially find more area.",
        "pattern": "Two Pointers",
        "keyInsight": "Start with maximum width (pointers at both ends). Trade width for potentially greater height.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "container with most water",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxArea(height: List[int]) -> int:\n    left, right = 0, len(height) - 1\n    max_water = 0\n    \n    while left < right:\n        # Calculate current area\n        width = right - left\n        h = min(height[left], height[right])\n        max_water = max(max_water, width * h)\n        \n        # Move the shorter line inward\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water"
      },
      {
        "id": "05-trapping-rain-water",
        "slug": "trapping-rain-water",
        "title": "Trapping Rain Water",
        "category": "two-pointers",
        "difficulty": "easy",
        "tags": [
          "two-pointers",
          "trapping-rain-water"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "examples": [
          {
            "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
            "output": "6",
            "explanation": "The elevation map (black) can trap 6 units of rain water (blue)."
          },
          {
            "input": "height = [4,2,0,3,2,5]",
            "output": "9",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Water can be trapped at position i if:",
            "options": [
              {
                "id": "a",
                "text": "There's a taller bar somewhere to the left AND somewhere to the right"
              },
              {
                "id": "b",
                "text": "There's a taller bar immediately adjacent"
              },
              {
                "id": "c",
                "text": "The bar at i is the shortest in the array"
              },
              {
                "id": "d",
                "text": "The total height is positive"
              }
            ],
            "correct": "a",
            "explanation": "Water needs walls on both sides to be contained. Without both, it would flow off.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "The water level at position i cannot exceed:",
            "options": [
              {
                "id": "a",
                "text": "The height of the tallest bar in the array"
              },
              {
                "id": "b",
                "text": "The height of the tallest bar to the left"
              },
              {
                "id": "c",
                "text": "The height of the tallest bar to the right"
              },
              {
                "id": "d",
                "text": "min(tallest left, tallest right)"
              }
            ],
            "correct": "d",
            "explanation": "Water would overflow over the shorter of the two bounding walls.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If max_left = 3, max_right = 2, height[i] = 1, water trapped = ?",
            "options": [
              {
                "id": "a",
                "text": "3 - 1 = 2"
              },
              {
                "id": "b",
                "text": "2 - 1 = 1"
              },
              {
                "id": "c",
                "text": "3 + 2 - 1 = 4"
              },
              {
                "id": "d",
                "text": "(3 + 2) / 2 - 1 = 1.5"
              }
            ],
            "correct": "b",
            "explanation": "Water level = min(3, 2) = 2. Water trapped = 2 - 1 = 1.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Naive approach: For each position, scan left for max, scan right for max. Time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "c",
            "explanation": "For each of n positions, we scan up to n elements left and right.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "We can precompute max_left[] and max_right[] arrays. What's the new time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "a",
            "explanation": "One pass to build max_left, one for max_right, one to compute water. O(3n) = O(n).",
            "conceptId": "prefix-sum"
          },
          {
            "type": "mcq",
            "question": "Two pointers can solve this in O(1) space because:",
            "options": [
              {
                "id": "a",
                "text": "We only need to track the current water level"
              },
              {
                "id": "b",
                "text": "At each step, we know enough about one side to compute water"
              },
              {
                "id": "c",
                "text": "Pointers magically know the max heights"
              },
              {
                "id": "d",
                "text": "It's not possible in O(1) space"
              }
            ],
            "correct": "b",
            "explanation": "If max_left < max_right, we know the left side is the bottleneck. We can safely compute water at the left pointer without knowing the exact max_right (just that it's >= max_left).",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "Water at each position = min(max_left, max_right) - height. Two pointers let us compute this in O(1) space by always processing the side with the smaller known max.",
        "pattern": "Two Pointers",
        "keyInsight": "Water at position i = min(max_left, max_right) - height[i]",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "trapping rain water",
          "two-pointers"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def trap(height: List[int]) -> int:\n    if not height:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max, right_max = height[left], height[right]\n    water = 0\n    \n    while left < right:\n        if left_max < right_max:\n            left += 1\n            left_max = max(left_max, height[left])\n            water += left_max - height[left]\n        else:\n            right -= 1\n            right_max = max(right_max, height[right])\n            water += right_max - height[right]\n    \n    return water"
      }
    ],
    "stack": [
      {
        "id": "01-valid-parentheses",
        "slug": "valid-parentheses",
        "title": "Valid Parentheses",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "valid-parentheses"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets\n2. Open brackets must be closed in the correct order\n3. Every close bracket has a corresponding open bracket of the same type",
        "examples": [
          {
            "input": "s = \"()\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"()[]{}\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"(]\"",
            "output": "false",
            "explanation": ""
          },
          {
            "input": "s = \"([)]\"",
            "output": "false",
            "explanation": ""
          },
          {
            "input": "s = \"{[]}\"",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The key property that makes a stack appropriate is:",
            "options": [
              {
                "id": "a",
                "text": "Brackets come in pairs"
              },
              {
                "id": "b",
                "text": "The most recent open bracket must close first"
              },
              {
                "id": "c",
                "text": "There are three types of brackets"
              },
              {
                "id": "d",
                "text": "The string has finite length"
              }
            ],
            "correct": "b",
            "explanation": "LIFO behavior. The innermost (most recently opened) bracket must be matched first.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "When you see an opening bracket '(', '[', or '{', you should:",
            "options": [
              {
                "id": "a",
                "text": "Push the closing bracket onto the stack"
              },
              {
                "id": "b",
                "text": "Push the opening bracket onto the stack"
              },
              {
                "id": "c",
                "text": "Pop from the stack"
              },
              {
                "id": "d",
                "text": "Do nothing"
              }
            ],
            "correct": "a",
            "explanation": "Empty stack means no opener to match = invalid. Otherwise, top of stack should be the matching opener.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "After processing all characters, the string is valid if:",
            "options": [
              {
                "id": "a",
                "text": "We never returned false"
              },
              {
                "id": "b",
                "text": "The stack is empty"
              },
              {
                "id": "c",
                "text": "The stack has one element"
              },
              {
                "id": "d",
                "text": "Both A and B"
              }
            ],
            "correct": "d",
            "explanation": "We need no mismatches during processing AND no unmatched openers left.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "\"([)]\" fails because:",
            "options": [
              {
                "id": "a",
                "text": "Different number of opens and closes"
              },
              {
                "id": "b",
                "text": "The '[' must close before ')' but ')' comes first"
              },
              {
                "id": "c",
                "text": "Parentheses can't be next to brackets"
              },
              {
                "id": "d",
                "text": "The string is too long"
              }
            ],
            "correct": "b",
            "explanation": "After `([`, stack is `[(, []`. Seeing `)` requires `(` on top, but `[` is on top. Nesting violation.",
            "conceptId": "stack"
          }
        ],
        "oneLiner": "Nested structures = stack. Push openers, pop and match on closers, end with empty stack.",
        "pattern": "Stack",
        "keyInsight": "Last opened bracket must be first to close.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "valid parentheses",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping:  # Closing bracket\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:  # Opening bracket\n            stack.append(char)\n    \n    return len(stack) == 0"
      },
      {
        "id": "02-min-stack",
        "slug": "min-stack",
        "title": "Min Stack",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "min-stack"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the `MinStack` class:\n- `MinStack()` initializes the stack object\n- `void push(int val)` pushes the element val onto the stack\n- `void pop()` removes the element on the top of the stack\n- `int top()` gets the top element of the stack\n- `int getMin()` retrieves the minimum element in the stack\n\nAll operations must be O(1) time.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If we store just the minimum value, what breaks on pop?",
            "options": [
              {
                "id": "a",
                "text": "We don't know what to pop"
              },
              {
                "id": "b",
                "text": "We lose what the previous minimum was"
              },
              {
                "id": "c",
                "text": "The stack becomes empty"
              },
              {
                "id": "d",
                "text": "Nothing breaks"
              }
            ],
            "correct": "b",
            "explanation": "If we pop the current min, we don't know the second smallest without scanning.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "When element X is on top, the minimum is determined by:",
            "options": [
              {
                "id": "a",
                "text": "Only X"
              },
              {
                "id": "b",
                "text": "All elements currently in the stack"
              },
              {
                "id": "c",
                "text": "All elements ever pushed"
              },
              {
                "id": "d",
                "text": "The element below X"
              }
            ],
            "correct": "b",
            "explanation": "Minimum is among current elements. When X is popped, min changes to min of remaining elements.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "At each stack position, we can precompute:",
            "options": [
              {
                "id": "a",
                "text": "The sum of all elements below"
              },
              {
                "id": "b",
                "text": "The minimum of all elements at or below this position"
              },
              {
                "id": "c",
                "text": "The maximum element"
              },
              {
                "id": "d",
                "text": "The count of elements"
              }
            ],
            "correct": "b",
            "explanation": "This \"minimum-so-far\" lets us answer getMin() instantly and recover previous min on pop.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "Which approach works for O(1) operations?",
            "options": [
              {
                "id": "a",
                "text": "Store (value, min_so_far) pairs"
              },
              {
                "id": "b",
                "text": "Use two stacks: main stack and min stack"
              },
              {
                "id": "c",
                "text": "Single stack with lazy min computation"
              },
              {
                "id": "d",
                "text": "Both A and B work"
              }
            ],
            "correct": "d",
            "explanation": "Pairs and synchronized stacks are equivalent. Both achieve O(1) for all operations.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "With two stacks (main, mins), when pushing value X:",
            "options": [
              {
                "id": "a",
                "text": "Push X to main; push min(X, mins.top()) to mins"
              },
              {
                "id": "b",
                "text": "Push X to both stacks"
              },
              {
                "id": "c",
                "text": "Push X to main only if X < current min"
              },
              {
                "id": "d",
                "text": "Push X to mins only if X < current min"
              }
            ],
            "correct": "a",
            "explanation": "Main stack holds all values. Mins stack holds the minimum at each level. They stay synchronized in size.",
            "conceptId": "stack"
          }
        ],
        "oneLiner": "Track 'minimum so far' at each stack position — either with pairs (val, min) or synchronized min stack.",
        "pattern": "Stack",
        "keyInsight": "Track the minimum at each \"level\" of the stack.",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "min stack",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class MinStack:\n    def __init__(self):\n        self.stack = []      # (value, min_so_far)\n    \n    def push(self, val: int) -> None:\n        if not self.stack:\n            self.stack.append((val, val))\n        else:\n            current_min = min(val, self.stack[-1][1])\n            self.stack.append((val, current_min))\n    \n    def pop(self) -> None:\n        self.stack.pop()\n    \n    def top(self) -> int:\n        return self.stack[-1][0]\n    \n    def getMin(self) -> int:\n        return self.stack[-1][1]"
      },
      {
        "id": "03-evaluate-reverse-polish-notation",
        "slug": "evaluate-reverse-polish-notation",
        "title": "Evaluate Reverse Polish Notation",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "evaluate-reverse-polish-notation"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of strings `tokens` that represents an arithmetic expression in Reverse Polish Notation (RPN).\n\nEvaluate the expression and return an integer representing the value.\n\n**Notes:**\n- Valid operators are `+`, `-`, `*`, and `/`\n- Each operand may be an integer or another expression\n- Division truncates toward zero\n- No division by zero\n- Answer fits in 32-bit integer",
        "examples": [
          {
            "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
            "output": "9",
            "explanation": "((2 + 1) * 3) = 9"
          },
          {
            "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
            "output": "6",
            "explanation": "(4 + (13 / 5)) = 4 + 2 = 6"
          },
          {
            "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
            "output": "22",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "When you encounter a number token, you should:",
            "options": [
              {
                "id": "a",
                "text": "Immediately output it"
              },
              {
                "id": "b",
                "text": "Push it onto the stack"
              },
              {
                "id": "c",
                "text": "Discard it"
              },
              {
                "id": "d",
                "text": "Apply the previous operator"
              }
            ],
            "correct": "b",
            "explanation": "Numbers wait on the stack until an operator needs them.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "When you encounter an operator, you should:",
            "options": [
              {
                "id": "a",
                "text": "Push it onto the stack"
              },
              {
                "id": "b",
                "text": "Pop one operand, apply operator"
              },
              {
                "id": "c",
                "text": "Pop two operands, apply operator, push result"
              },
              {
                "id": "d",
                "text": "Wait for the next number"
              }
            ],
            "correct": "c",
            "explanation": "Binary operators need two operands. Result goes back on stack for future operations.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "For tokens [\"10\", \"3\", \"-\"], the result is:",
            "options": [
              {
                "id": "a",
                "text": "3 - 10 = -7"
              },
              {
                "id": "b",
                "text": "10 - 3 = 7"
              },
              {
                "id": "c",
                "text": "Error"
              },
              {
                "id": "d",
                "text": "13"
              }
            ],
            "correct": "b",
            "explanation": "First number pushed (10) is second popped. Order is: second_popped OP first_popped = 10 - 3 = 7.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "If stack is [10, 3] and operator is \"/\": Pop 3, pop 10. The computation is:",
            "options": [
              {
                "id": "a",
                "text": "3 / 10"
              },
              {
                "id": "b",
                "text": "10 / 3"
              },
              {
                "id": "c",
                "text": "Either works"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "b",
            "explanation": "The operand pushed first (10) is the dividend. Operand pushed second (3) is the divisor. 10 / 3 = 3 (truncated).",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "After processing all tokens, the answer is:",
            "options": [
              {
                "id": "a",
                "text": "The sum of all stack elements"
              },
              {
                "id": "b",
                "text": "The top (and only) element of the stack"
              },
              {
                "id": "c",
                "text": "The bottom element of the stack"
              },
              {
                "id": "d",
                "text": "Zero"
              }
            ],
            "correct": "b",
            "explanation": "Valid RPN expression reduces to exactly one value on the stack.",
            "conceptId": "stack"
          }
        ],
        "oneLiner": "RPN evaluation: numbers go on stack, operators pop two, compute, push result. Final answer is stack's only element.",
        "pattern": "Stack",
        "keyInsight": "When you see an operator, apply it to the two most recent numbers.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "evaluate reverse polish notation",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def evalRPN(tokens: List[str]) -> int:\n    stack = []\n    operators = {'+', '-', '*', '/'}\n    \n    for token in tokens:\n        if token in operators:\n            b = stack.pop()  # Second operand\n            a = stack.pop()  # First operand\n            \n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            else:  # Division truncates toward zero\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    \n    return stack[0]"
      },
      {
        "id": "04-generate-parentheses",
        "slug": "generate-parentheses",
        "title": "Generate Parentheses",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "generate-parentheses"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
        "examples": [
          {
            "input": "n = 3",
            "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
            "explanation": ""
          },
          {
            "input": "n = 1",
            "output": "[\"()\"]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For n pairs, a valid sequence must have:",
            "options": [
              {
                "id": "a",
                "text": "n characters total"
              },
              {
                "id": "b",
                "text": "n '(' and n ')' characters"
              },
              {
                "id": "c",
                "text": "More '(' than ')'"
              },
              {
                "id": "d",
                "text": "Alternating '(' and ')'"
              }
            ],
            "correct": "b",
            "explanation": "Exactly n of each type, total length 2n.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At any prefix of a valid sequence:",
            "options": [
              {
                "id": "a",
                "text": "Count of ')' > count of '('"
              },
              {
                "id": "b",
                "text": "Count of '(' ≥ count of ')'"
              },
              {
                "id": "c",
                "text": "Counts must be equal"
              },
              {
                "id": "d",
                "text": "No constraint"
              }
            ],
            "correct": "b",
            "explanation": "If ')' ever exceeds '(', there's an unmatched closer. Invalid.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We can add an opening bracket if:",
            "options": [
              {
                "id": "a",
                "text": "We've added at least one ')'"
              },
              {
                "id": "b",
                "text": "We've used fewer than n '(' so far"
              },
              {
                "id": "c",
                "text": "The previous char was ')'"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "b",
            "explanation": "We have n opens to use. If used < n, we can add more.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We can add a closing bracket if:",
            "options": [
              {
                "id": "a",
                "text": "We've used fewer than n ')' so far"
              },
              {
                "id": "b",
                "text": "Open count > close count"
              },
              {
                "id": "c",
                "text": "Both A and B"
              },
              {
                "id": "d",
                "text": "The string is non-empty"
              }
            ],
            "correct": "c",
            "explanation": "We need both: (1) ')' available and (2) a '(' to match. Condition B implies A when building sequentially.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We've completed a valid sequence when:",
            "options": [
              {
                "id": "a",
                "text": "Length equals n"
              },
              {
                "id": "b",
                "text": "Length equals 2n"
              },
              {
                "id": "c",
                "text": "We can't add more characters"
              },
              {
                "id": "d",
                "text": "Both B and C"
              }
            ],
            "correct": "b",
            "explanation": "2n characters = n opens + n closes = complete sequence.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Generate valid parentheses by backtracking: add '(' if < n used, add ')' if close < open. Both constraints must hold.",
        "pattern": "Stack",
        "keyInsight": "Build sequences character by character, tracking counts.",
        "timeComplexity": "O(4^n / √n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "generate parentheses",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def generateParenthesis(n: int) -> List[str]:\n    result = []\n    \n    def backtrack(current: str, open_count: int, close_count: int):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        # Can add '(' if we haven't used all n\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        \n        # Can add ')' if it doesn't exceed open count\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result"
      },
      {
        "id": "05-daily-temperatures",
        "slug": "daily-temperatures",
        "title": "Daily Temperatures",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "daily-temperatures"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of integers `temperatures` represents the daily temperatures, return an array `answer` such that `answer[i]` is the number of days you have to wait after the `i`th day to get a warmer temperature. If there is no future day with warmer temperature, `answer[i] = 0`.",
        "examples": [
          {
            "input": "temperatures = [73,74,75,71,69,72,76,73]",
            "output": "[1,1,4,2,1,1,0,0]",
            "explanation": ""
          },
          {
            "input": "temperatures = [30,40,50,60]",
            "output": "[1,1,1,0]",
            "explanation": ""
          },
          {
            "input": "temperatures = [30,60,90]",
            "output": "[1,1,0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For each day i, scan forward to find the first warmer day. Time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(n log n)"
              },
              {
                "id": "c",
                "text": "O(n²)"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "c",
            "explanation": "For each of n days, we might scan up to n days forward.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The stack holds days that are:",
            "options": [
              {
                "id": "a",
                "text": "Already resolved (found their warmer day)"
              },
              {
                "id": "b",
                "text": "Still waiting to find a warmer day"
              },
              {
                "id": "c",
                "text": "The warmest days seen"
              },
              {
                "id": "d",
                "text": "Random days"
              }
            ],
            "correct": "b",
            "explanation": "Days on the stack haven't found their next warmer day yet.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "When processing day i with temperature T, pop from stack if:",
            "options": [
              {
                "id": "a",
                "text": "Stack is not empty"
              },
              {
                "id": "b",
                "text": "Stack top's temperature < T"
              },
              {
                "id": "c",
                "text": "Stack top's temperature > T"
              },
              {
                "id": "d",
                "text": "Stack has more than one element"
              }
            ],
            "correct": "b",
            "explanation": "Day on stack top is cooler than today. Today is its \"next warmer day\"!",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "When popping day j because day i is warmer: answer[j] = ?",
            "options": [
              {
                "id": "a",
                "text": "temperatures[i]"
              },
              {
                "id": "b",
                "text": "temperatures[i] - temperatures[j]"
              },
              {
                "id": "c",
                "text": "i - j"
              },
              {
                "id": "d",
                "text": "j"
              }
            ],
            "correct": "c",
            "explanation": "We want days to wait, not temperature difference. Days = index difference.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "After resolving all cooler days, what do we do with the current day?",
            "options": [
              {
                "id": "a",
                "text": "Discard it"
              },
              {
                "id": "b",
                "text": "Push it onto the stack"
              },
              {
                "id": "c",
                "text": "Store it in answer"
              },
              {
                "id": "d",
                "text": "Pop more elements"
              }
            ],
            "correct": "b",
            "explanation": "Current day now waits for ITS next warmer day. It joins the stack.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The temperatures of days on the stack form a:",
            "options": [
              {
                "id": "a",
                "text": "Random sequence"
              },
              {
                "id": "b",
                "text": "Increasing sequence"
              },
              {
                "id": "c",
                "text": "Decreasing sequence (from bottom to top)"
              },
              {
                "id": "d",
                "text": "Alternating sequence"
              }
            ],
            "correct": "c",
            "explanation": "We pop anything smaller than current before pushing. So bottom is largest, top is smallest of the waiting days. This is a monotonic decreasing stack.",
            "conceptId": "monotonic-stack"
          }
        ],
        "oneLiner": "Next greater element = monotonic decreasing stack. Pop and resolve when current > stack top, then push current.",
        "pattern": "Stack",
        "keyInsight": "Use a stack to track days waiting for a warmer day.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "daily temperatures",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def dailyTemperatures(temperatures: List[int]) -> List[int]:\n    n = len(temperatures)\n    answer = [0] * n\n    stack = []  # Stack of indices\n    \n    for i in range(n):\n        # Pop all days that found their warmer day\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            prev_day = stack.pop()\n            answer[prev_day] = i - prev_day\n        \n        # Current day waits for its warmer day\n        stack.append(i)\n    \n    return answer"
      },
      {
        "id": "06-car-fleet",
        "slug": "car-fleet",
        "title": "Car Fleet",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "car-fleet"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\n\nYou are given two integer arrays `position` and `speed`, both of length `n`, where `position[i]` is the position of the `i`th car and `speed[i]` is the speed of the `i`th car (in miles per hour).\n\nA car can never pass another car ahead of it, but it can catch up to it and then travel at the same speed. The faster car will slow down to match the slower car's speed.\n\nA **car fleet** is some non-empty set of cars driving at the same position and same speed. A single car is also a fleet.\n\nIf a car catches up to a car fleet right at the destination point, it still counts as one fleet.\n\nReturn the number of car fleets that will arrive at the destination.",
        "examples": [
          {
            "input": "target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]",
            "output": "3",
            "explanation": ""
          },
          {
            "input": "target = 10, position = [3], speed = [3]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For a car at position p with speed s, time to reach target T is:",
            "options": [
              {
                "id": "a",
                "text": "T * s"
              },
              {
                "id": "b",
                "text": "(T - p) / s"
              },
              {
                "id": "c",
                "text": "p / s"
              },
              {
                "id": "d",
                "text": "T / p"
              }
            ],
            "correct": "b",
            "explanation": "Distance to travel = T - p. Time = distance / speed.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "We process cars from closest to target because:",
            "options": [
              {
                "id": "a",
                "text": "It's alphabetically first"
              },
              {
                "id": "b",
                "text": "Front cars can block/slow down cars behind them"
              },
              {
                "id": "c",
                "text": "Front cars are always faster"
              },
              {
                "id": "d",
                "text": "Randomizes the result"
              }
            ],
            "correct": "b",
            "explanation": "A slower car in front creates a \"barrier\" — faster cars behind can only match its arrival time, not beat it.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Car B (behind) merges with Car A (ahead) if:",
            "options": [
              {
                "id": "a",
                "text": "B is faster than A"
              },
              {
                "id": "b",
                "text": "B would arrive at target before or at same time as A"
              },
              {
                "id": "c",
                "text": "B starts closer to target"
              },
              {
                "id": "d",
                "text": "A and B have the same speed"
              }
            ],
            "correct": "b",
            "explanation": "If B's arrival time ≤ A's, B catches up (or ties at target). B can't pass A, so B joins A's fleet.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "When car B merges with car A's fleet:",
            "options": [
              {
                "id": "a",
                "text": "Both times are averaged"
              },
              {
                "id": "b",
                "text": "Fleet takes B's (faster) arrival time"
              },
              {
                "id": "c",
                "text": "Fleet takes A's (slower) arrival time"
              },
              {
                "id": "d",
                "text": "Fleet speed doubles"
              }
            ],
            "correct": "c",
            "explanation": "B can't pass A, so B slows down to A's pace. Fleet arrival = A's original arrival time.",
            "conceptId": "stack"
          },
          {
            "type": "mcq",
            "question": "The stack stores:",
            "options": [
              {
                "id": "a",
                "text": "Car positions"
              },
              {
                "id": "b",
                "text": "Car speeds"
              },
              {
                "id": "c",
                "text": "Arrival times of fleet \"leaders\""
              },
              {
                "id": "d",
                "text": "Number of cars in each fleet"
              }
            ],
            "correct": "c",
            "explanation": "Each stack entry represents a fleet. We track its arrival time to compare with the next car.",
            "conceptId": "stack"
          }
        ],
        "oneLiner": "Sort cars by position (front first). Car joins fleet ahead if its arrival time ≤ fleet's time, else forms new fleet. Count distinct fleet times.",
        "pattern": "Stack",
        "keyInsight": "Calculate arrival time for each car. Process from position closest to target backward.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "car fleet",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def carFleet(target: int, position: List[int], speed: List[int]) -> int:\n    # Pair positions with arrival times, sort by position descending\n    cars = sorted(zip(position, speed), reverse=True)\n    stack = []  # Arrival times of fleet leaders\n    \n    for pos, spd in cars:\n        arrival_time = (target - pos) / spd\n        \n        # If this car arrives later than the fleet ahead, it's a new fleet\n        if not stack or arrival_time > stack[-1]:\n            stack.append(arrival_time)\n        # Otherwise, it merges with the fleet ahead (don't push)\n    \n    return len(stack)"
      },
      {
        "id": "07-largest-rectangle-in-histogram",
        "slug": "largest-rectangle-in-histogram",
        "title": "Largest Rectangle in Histogram",
        "category": "stack",
        "difficulty": "medium",
        "tags": [
          "stack",
          "largest-rectangle-in-histogram"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of integers `heights` representing the histogram's bar heights where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
        "examples": [
          {
            "input": "heights = [2,1,5,6,2,3]",
            "output": "10",
            "explanation": "Rectangle with height 5 and width 2 (indices 2-3) = 10"
          },
          {
            "input": "heights = [2,4]",
            "output": "4",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A rectangle of height h starting at bar i can extend to bar j if:",
            "options": [
              {
                "id": "a",
                "text": "heights[j] ≥ h"
              },
              {
                "id": "b",
                "text": "heights[j] > h"
              },
              {
                "id": "c",
                "text": "heights[j] = h"
              },
              {
                "id": "d",
                "text": "j > i"
              }
            ],
            "correct": "a",
            "explanation": "As long as bars are at least height h, the rectangle continues.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The maximum rectangle using bar i as the shortest bar:",
            "options": [
              {
                "id": "a",
                "text": "Has width 1"
              },
              {
                "id": "b",
                "text": "Extends to first shorter bar on each side"
              },
              {
                "id": "c",
                "text": "Extends to the array ends"
              },
              {
                "id": "d",
                "text": "Only includes taller bars"
              }
            ],
            "correct": "b",
            "explanation": "Rectangle height is limited by bar i. It extends until a shorter bar blocks it.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "We maintain bars in increasing height order because:",
            "options": [
              {
                "id": "a",
                "text": "It looks nice"
              },
              {
                "id": "b",
                "text": "When a shorter bar appears, we can compute rectangles for all taller bars"
              },
              {
                "id": "c",
                "text": "We only care about increasing sequences"
              },
              {
                "id": "d",
                "text": "Random order works too"
              }
            ],
            "correct": "b",
            "explanation": "A shorter bar terminates all taller bars' extensions to the right. We process them now.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "For a bar popped from the stack, its left boundary is:",
            "options": [
              {
                "id": "a",
                "text": "Index 0"
              },
              {
                "id": "b",
                "text": "Its own index"
              },
              {
                "id": "c",
                "text": "The new stack top's index (or -1 if empty)"
              },
              {
                "id": "d",
                "text": "The index of the bar that caused the pop"
              }
            ],
            "correct": "c",
            "explanation": "The bar below it on the stack is the first shorter bar to its left. If stack becomes empty, it can extend to index 0 (left boundary = -1).",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "For a bar popped because of bar at index i, its right boundary is:",
            "options": [
              {
                "id": "a",
                "text": "The array's length"
              },
              {
                "id": "b",
                "text": "i"
              },
              {
                "id": "c",
                "text": "i + 1"
              },
              {
                "id": "d",
                "text": "The bar's own index"
              }
            ],
            "correct": "b",
            "explanation": "Bar at index i is the first shorter bar to its right. Right boundary = i (exclusive).",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "If left boundary (exclusive) is L and right boundary (exclusive) is R: Width = ?",
            "options": [
              {
                "id": "a",
                "text": "R - L"
              },
              {
                "id": "b",
                "text": "R - L - 1"
              },
              {
                "id": "c",
                "text": "R - L + 1"
              },
              {
                "id": "d",
                "text": "L - R"
              }
            ],
            "correct": "b",
            "explanation": "Bars from L+1 to R-1 are included. Count = (R-1) - (L+1) + 1 = R - L - 1.",
            "conceptId": "monotonic-stack"
          }
        ],
        "oneLiner": "Monotonic increasing stack: when a shorter bar appears, all taller bars on stack have found their right boundary. Pop, compute width = right - left - 1, track max area.",
        "pattern": "Stack",
        "keyInsight": "For each bar, find how far it can extend left and right.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "largest rectangle in histogram",
          "stack"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def largestRectangleArea(heights: List[int]) -> int:\n    stack = []  # Stack of indices\n    max_area = 0\n    \n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            idx, height = stack.pop()\n            max_area = max(max_area, height * (i - idx))\n            start = idx  # Extend left boundary\n        stack.append((start, h))\n    \n    # Process remaining bars (extend to end)\n    for idx, height in stack:\n        max_area = max(max_area, height * (len(heights) - idx))\n    \n    return max_area"
      }
    ],
    "sliding-window": [
      {
        "id": "01-best-time-to-buy-and-sell-stock",
        "slug": "best-time-to-buy-and-sell-stock",
        "title": "Best Time to Buy and Sell Stock",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "best-time-to-buy-and-sell-stock"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
        "examples": [
          {
            "input": "prices = [7,1,5,3,6,4]",
            "output": "5",
            "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
          },
          {
            "input": "prices = [7,6,4,3,1]",
            "output": "0",
            "explanation": "No profitable transaction possible (prices only decrease)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To find max profit, the naive approach is:",
            "options": [
              {
                "id": "a",
                "text": "Sort the array and take max - min"
              },
              {
                "id": "b",
                "text": "For each day, check profit with every future day"
              },
              {
                "id": "c",
                "text": "Sum all the prices"
              },
              {
                "id": "d",
                "text": "Find the average price"
              }
            ],
            "correct": "b",
            "explanation": "We need to check all buy-sell pairs where sell comes after buy. But this is O(n²).",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "Given prices = [3, 1, 4], after sorting = [1, 3, 4]. Max - min = 4 - 1 = 3. Is this achievable?",
            "options": [
              {
                "id": "a",
                "text": "Yes, always achievable"
              },
              {
                "id": "b",
                "text": "Only if max comes after min in original array"
              },
              {
                "id": "c",
                "text": "Only if array is already sorted"
              },
              {
                "id": "d",
                "text": "Never achievable"
              }
            ],
            "correct": "b",
            "explanation": "We can only sell AFTER buying. Sorting loses temporal order. Here it works (4 comes after 1), but [4,1,3] would give wrong answer.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "As we scan left to right, what should we track?",
            "options": [
              {
                "id": "a",
                "text": "Maximum price seen so far"
              },
              {
                "id": "b",
                "text": "Minimum price seen so far"
              },
              {
                "id": "c",
                "text": "Average price so far"
              },
              {
                "id": "d",
                "text": "Median price so far"
              }
            ],
            "correct": "b",
            "explanation": "We want to buy low. The best buy opportunity at any point is the minimum we've seen. We can only buy in the past, not the future.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "At day i, the best profit if we sell today is:",
            "options": [
              {
                "id": "a",
                "text": "prices[i] - prices[0]"
              },
              {
                "id": "b",
                "text": "prices[i] - min(prices[0:i])"
              },
              {
                "id": "c",
                "text": "max(prices[0:i]) - prices[i]"
              },
              {
                "id": "d",
                "text": "prices[i] - prices[i-1]"
              }
            ],
            "correct": "b",
            "explanation": "Best profit = today's price minus the cheapest price before today.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "After computing today's potential profit, we:",
            "options": [
              {
                "id": "a",
                "text": "Always update the answer"
              },
              {
                "id": "b",
                "text": "Update answer if this profit > current best"
              },
              {
                "id": "c",
                "text": "Update answer if price increased from yesterday"
              },
              {
                "id": "d",
                "text": "Reset the minimum price"
              }
            ],
            "correct": "b",
            "explanation": "We want maximum profit, so only update if we found a better one.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "If today's price is lower than our tracked minimum:",
            "options": [
              {
                "id": "a",
                "text": "We should sell today"
              },
              {
                "id": "b",
                "text": "We should update minimum and skip profit calculation"
              },
              {
                "id": "c",
                "text": "We should update minimum, and profit today is 0"
              },
              {
                "id": "d",
                "text": "We should restart the algorithm"
              }
            ],
            "correct": "c",
            "explanation": "New minimum can't give positive profit today (selling at price we just bought). Future days might benefit from this lower buy price.",
            "conceptId": "sliding-window"
          }
        ],
        "oneLiner": "Track minimum price seen. At each day, profit = today - min. Track maximum profit.",
        "pattern": "Sliding Window",
        "keyInsight": "Track the minimum price seen so far. At each day, calculate potential profit if we sold today.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "best time to buy and sell stock",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxProfit(prices: List[int]) -> int:\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        profit = price - min_price\n        max_profit = max(max_profit, profit)\n    \n    return max_profit"
      },
      {
        "id": "02-longest-substring-without-repeating",
        "slug": "longest-substring-without-repeating",
        "title": "Longest Substring Without Repeating Characters",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "longest-substring-without-repeating-characters"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s`, find the length of the longest substring without repeating characters.",
        "examples": [
          {
            "input": "s = \"abcabcbb\"",
            "output": "3",
            "explanation": "The answer is \"abc\", with length 3."
          },
          {
            "input": "s = \"bbbbb\"",
            "output": "1",
            "explanation": "The answer is \"b\", with length 1."
          },
          {
            "input": "s = \"pwwkew\"",
            "output": "3",
            "explanation": "The answer is \"wke\", with length 3."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A window (substring) is valid if:",
            "options": [
              {
                "id": "a",
                "text": "It contains at least one character"
              },
              {
                "id": "b",
                "text": "All characters in it are unique"
              },
              {
                "id": "c",
                "text": "It starts at index 0"
              },
              {
                "id": "d",
                "text": "It has odd length"
              }
            ],
            "correct": "b",
            "explanation": "\"Without repeating characters\" means all unique within the window.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "We can expand the window by moving the right pointer when:",
            "options": [
              {
                "id": "a",
                "text": "The window is empty"
              },
              {
                "id": "b",
                "text": "The new character is not in the current window"
              },
              {
                "id": "c",
                "text": "The window size is less than 26"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "b",
            "explanation": "Adding a character that's already in the window creates a duplicate, violating our constraint.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "We must shrink the window (move left pointer) when:",
            "options": [
              {
                "id": "a",
                "text": "Window size exceeds some limit"
              },
              {
                "id": "b",
                "text": "The character at right pointer already exists in window"
              },
              {
                "id": "c",
                "text": "We've scanned half the string"
              },
              {
                "id": "d",
                "text": "The left character is a vowel"
              }
            ],
            "correct": "b",
            "explanation": "A duplicate means the window is invalid. Shrink until the duplicate is removed.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "When shrinking due to duplicate at position r, shrink until:",
            "options": [
              {
                "id": "a",
                "text": "Window is empty"
              },
              {
                "id": "b",
                "text": "Window size is 1"
              },
              {
                "id": "c",
                "text": "The duplicate character is no longer in the window"
              },
              {
                "id": "d",
                "text": "Left pointer equals right pointer"
              }
            ],
            "correct": "c",
            "explanation": "We only need to remove enough to eliminate the duplicate. Then we can include s[r].",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "To check if a character is in the current window in O(1):",
            "options": [
              {
                "id": "a",
                "text": "Scan the window each time"
              },
              {
                "id": "b",
                "text": "Use a hash set"
              },
              {
                "id": "c",
                "text": "Use a sorted array"
              },
              {
                "id": "d",
                "text": "Use a queue"
              }
            ],
            "correct": "b",
            "explanation": "Set provides O(1) add, remove, and contains operations.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "If we track each character's last position, when we find duplicate:",
            "options": [
              {
                "id": "a",
                "text": "We must still remove one at a time"
              },
              {
                "id": "b",
                "text": "We can jump left pointer to last_position[char] + 1"
              },
              {
                "id": "c",
                "text": "We reset to position 0"
              },
              {
                "id": "d",
                "text": "We skip the duplicate entirely"
              }
            ],
            "correct": "b",
            "explanation": "If we know where the duplicate was last seen, we can jump past it. This is still O(n) but with fewer operations.",
            "conceptId": "hash-map"
          }
        ],
        "oneLiner": "Sliding window with set: expand right, shrink left until no duplicate, track max window size.",
        "pattern": "Sliding Window",
        "keyInsight": "Expand the window right. When a duplicate is found, shrink from the left until unique again.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(min(n, alphabet))",
        "triggerWords": [
          "longest substring without repeating characters",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def lengthOfLongestSubstring(s: str) -> int:\n    char_set = set()\n    left = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        # Shrink window until no duplicate\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        char_set.add(s[right])\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len"
      },
      {
        "id": "03-longest-repeating-character-replacement",
        "slug": "longest-repeating-character-replacement",
        "title": "Longest Repeating Character Replacement",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "longest-repeating-character-replacement"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.",
        "examples": [
          {
            "input": "s = \"ABAB\", k = 2",
            "output": "4",
            "explanation": "Replace the two 'A's with 'B's or vice versa."
          },
          {
            "input": "s = \"AABABBA\", k = 1",
            "output": "4",
            "explanation": "Replace the 'B' at index 2 with 'A'. Substring \"AAAB\" or replace 'A' at index 0 with 'B' for \"BABBA\" → \"BBBB\" (substring \"ABBB\" starting at 1)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A window can become all same character if:",
            "options": [
              {
                "id": "a",
                "text": "It contains only one unique character"
              },
              {
                "id": "b",
                "text": "Characters to change ≤ k"
              },
              {
                "id": "c",
                "text": "Window size ≤ k"
              },
              {
                "id": "d",
                "text": "Most frequent char appears > k times"
              }
            ],
            "correct": "b",
            "explanation": "We have k changes. If we need more than k, window is invalid.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "In a valid window, which character should we NOT change?",
            "options": [
              {
                "id": "a",
                "text": "The first character"
              },
              {
                "id": "b",
                "text": "The last character"
              },
              {
                "id": "c",
                "text": "The most frequent character"
              },
              {
                "id": "d",
                "text": "Any vowel present"
              }
            ],
            "correct": "c",
            "explanation": "Keeping the most frequent minimizes changes needed. Changing the minority to match the majority.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "For a window of size W with most frequent character appearing F times: Replacements needed = ?",
            "options": [
              {
                "id": "a",
                "text": "W"
              },
              {
                "id": "b",
                "text": "F"
              },
              {
                "id": "c",
                "text": "W - F"
              },
              {
                "id": "d",
                "text": "W + F"
              }
            ],
            "correct": "c",
            "explanation": "Total chars - chars we keep = chars we must change.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "Window is invalid when:",
            "options": [
              {
                "id": "a",
                "text": "W - F > k"
              },
              {
                "id": "b",
                "text": "W - F < k"
              },
              {
                "id": "c",
                "text": "F > k"
              },
              {
                "id": "d",
                "text": "W > k"
              }
            ],
            "correct": "a",
            "explanation": "If we need more than k replacements, we can't make all chars the same.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "When window becomes invalid, we:",
            "options": [
              {
                "id": "a",
                "text": "Reset to empty window"
              },
              {
                "id": "b",
                "text": "Move left pointer right by 1"
              },
              {
                "id": "c",
                "text": "Move right pointer left by 1"
              },
              {
                "id": "d",
                "text": "Remove all occurrences of some character"
              }
            ],
            "correct": "b",
            "explanation": "Shrink window minimally. Maybe removing one char from left makes it valid again.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "To know the most frequent character in current window:",
            "options": [
              {
                "id": "a",
                "text": "Scan window each time"
              },
              {
                "id": "b",
                "text": "Keep a frequency map of chars in window"
              },
              {
                "id": "c",
                "text": "Only track the first character"
              },
              {
                "id": "d",
                "text": "Use a sorted set"
              }
            ],
            "correct": "b",
            "explanation": "Maintain count of each character. Update as window expands/shrinks.",
            "conceptId": "frequency-count"
          }
        ],
        "oneLiner": "Valid window: size - max_frequency ≤ k. Expand right, shrink left when invalid, track max size.",
        "pattern": "Sliding Window",
        "keyInsight": "Characters to replace = window size - count of most frequent character.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(26)",
        "triggerWords": [
          "longest repeating character replacement",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def characterReplacement(s: str, k: int) -> int:\n    count = {}  # Frequency of chars in window\n    left = 0\n    max_freq = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_freq = max(max_freq, count[s[right]])\n        \n        # Window is invalid: size - max_freq > k\n        while (right - left + 1) - max_freq > k:\n            count[s[left]] -= 1\n            left += 1\n        \n        max_len = max(max_len, right - left + 1)\n    \n    return max_len"
      },
      {
        "id": "04-permutation-in-string",
        "slug": "permutation-in-string",
        "title": "Permutation in String",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "permutation-in-string"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1`, or `false` otherwise.\n\nIn other words, return `true` if one of `s1`'s permutations is a substring of `s2`.",
        "examples": [
          {
            "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
            "output": "true",
            "explanation": "s2 contains one permutation of s1 (\"ba\")."
          },
          {
            "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Two strings are permutations of each other if:",
            "options": [
              {
                "id": "a",
                "text": "They have the same length"
              },
              {
                "id": "b",
                "text": "They have the same first and last character"
              },
              {
                "id": "c",
                "text": "They have identical character frequency counts"
              },
              {
                "id": "d",
                "text": "One can be reversed to get the other"
              }
            ],
            "correct": "c",
            "explanation": "\"abc\" and \"bca\" are permutations — same chars, same counts, different order.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "For s1 of length n, generating all permutations takes:",
            "options": [
              {
                "id": "a",
                "text": "O(n) time"
              },
              {
                "id": "b",
                "text": "O(n²) time"
              },
              {
                "id": "c",
                "text": "O(n!) time"
              },
              {
                "id": "d",
                "text": "O(2^n) time"
              }
            ],
            "correct": "c",
            "explanation": "n! permutations exist. For n=10, that's 3.6 million. Way too slow.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "To find a permutation of s1 in s2, the window size should be:",
            "options": [
              {
                "id": "a",
                "text": "Variable"
              },
              {
                "id": "b",
                "text": "len(s1)"
              },
              {
                "id": "c",
                "text": "len(s2)"
              },
              {
                "id": "d",
                "text": "min(len(s1), len(s2))"
              }
            ],
            "correct": "b",
            "explanation": "Permutation has exact same length as original. Window must match s1's length.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "With a fixed-size window, when we slide right by 1:",
            "options": [
              {
                "id": "a",
                "text": "Rebuild the entire frequency count"
              },
              {
                "id": "b",
                "text": "Add new char on right, remove old char on left"
              },
              {
                "id": "c",
                "text": "Only add new char on right"
              },
              {
                "id": "d",
                "text": "Reset the window"
              }
            ],
            "correct": "b",
            "explanation": "Sliding by 1 = one char enters (right), one char exits (left). Update counts incrementally.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "The simplest way to check if window matches s1:",
            "options": [
              {
                "id": "a",
                "text": "Sort both and compare"
              },
              {
                "id": "b",
                "text": "Compare frequency dictionaries"
              },
              {
                "id": "c",
                "text": "Check if all characters exist"
              },
              {
                "id": "d",
                "text": "Use string equality"
              }
            ],
            "correct": "b",
            "explanation": "Two frequency maps can be compared in O(26) = O(1) for lowercase letters.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "Instead of comparing full maps, we can track:",
            "options": [
              {
                "id": "a",
                "text": "Just the first character"
              },
              {
                "id": "b",
                "text": "Number of matching character counts"
              },
              {
                "id": "c",
                "text": "Sum of all frequencies"
              },
              {
                "id": "d",
                "text": "Product of all frequencies"
              }
            ],
            "correct": "b",
            "explanation": "Track how many of the 26 characters have matching counts. When all 26 match (or all present chars match), we found a permutation.",
            "conceptId": "sliding-window"
          }
        ],
        "oneLiner": "Permutation = same frequency. Slide fixed-size window, update counts incrementally, check for match.",
        "pattern": "Sliding Window",
        "keyInsight": "A permutation has the same characters in different order. Same characters = same frequency count.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "permutation in string",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def checkInclusion(s1: str, s2: str) -> bool:\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = [0] * 26\n    window_count = [0] * 26\n    \n    for c in s1:\n        s1_count[ord(c) - ord('a')] += 1\n    \n    for i in range(len(s2)):\n        # Add char to window\n        window_count[ord(s2[i]) - ord('a')] += 1\n        \n        # Remove char that left the window\n        if i >= len(s1):\n            window_count[ord(s2[i - len(s1)]) - ord('a')] -= 1\n        \n        # Check if window matches s1\n        if window_count == s1_count:\n            return True\n    \n    return False"
      },
      {
        "id": "05-minimum-window-substring",
        "slug": "minimum-window-substring",
        "title": "Minimum Window Substring",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "minimum-window-substring"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `\"\"`.",
        "examples": [
          {
            "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
            "output": "\"BANC\"",
            "explanation": "\"BANC\" is the smallest window containing 'A', 'B', and 'C'."
          },
          {
            "input": "s = \"a\", t = \"a\"",
            "output": "\"a\"",
            "explanation": ""
          },
          {
            "input": "s = \"a\", t = \"aa\"",
            "output": "\"\"",
            "explanation": "Need two 'a's but only one exists."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We use sliding window because:",
            "options": [
              {
                "id": "a",
                "text": "The answer is always at the start"
              },
              {
                "id": "b",
                "text": "We're looking for a contiguous substring"
              },
              {
                "id": "c",
                "text": "The strings are sorted"
              },
              {
                "id": "d",
                "text": "We need O(1) space"
              }
            ],
            "correct": "b",
            "explanation": "Substring = contiguous sequence. Window maintains contiguity.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "A window is valid when:",
            "options": [
              {
                "id": "a",
                "text": "It contains at least one char from t"
              },
              {
                "id": "b",
                "text": "It contains each unique char from t at least once"
              },
              {
                "id": "c",
                "text": "It contains each char from t with at least the required frequency"
              },
              {
                "id": "d",
                "text": "Its length equals t's length"
              }
            ],
            "correct": "c",
            "explanation": "If t = \"aab\", window needs at least 2 'a's and 1 'b'. Frequencies matter.",
            "conceptId": "frequency-count"
          },
          {
            "type": "mcq",
            "question": "We expand the window when:",
            "options": [
              {
                "id": "a",
                "text": "Window is already valid"
              },
              {
                "id": "b",
                "text": "Window is not yet valid"
              },
              {
                "id": "c",
                "text": "We've found a minimum"
              },
              {
                "id": "d",
                "text": "Left equals right"
              }
            ],
            "correct": "b",
            "explanation": "Need to include more chars to meet the requirement. Once valid, try shrinking.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "Once window is valid, we shrink from left to:",
            "options": [
              {
                "id": "a",
                "text": "Make window invalid"
              },
              {
                "id": "b",
                "text": "Find a smaller valid window"
              },
              {
                "id": "c",
                "text": "Reset the search"
              },
              {
                "id": "d",
                "text": "Remove duplicates"
              }
            ],
            "correct": "b",
            "explanation": "We want minimum window. Maybe some chars on the left aren't needed. Shrink until invalid, track min valid.",
            "conceptId": "sliding-window"
          },
          {
            "type": "mcq",
            "question": "To efficiently check if window contains all of t:",
            "options": [
              {
                "id": "a",
                "text": "Compare sorted strings"
              },
              {
                "id": "b",
                "text": "Track \"how many char requirements are fully met\""
              },
              {
                "id": "c",
                "text": "Count total characters only"
              },
              {
                "id": "d",
                "text": "Use regex matching"
              }
            ],
            "correct": "b",
            "explanation": "For each char in t, track if window has enough. Count how many chars have met quota. When count equals unique chars in t, window is valid.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "We update our answer (minimum window) when:",
            "options": [
              {
                "id": "a",
                "text": "Window expands"
              },
              {
                "id": "b",
                "text": "Window shrinks"
              },
              {
                "id": "c",
                "text": "Window is valid and smaller than current best"
              },
              {
                "id": "d",
                "text": "Window contains exactly t"
              }
            ],
            "correct": "c",
            "explanation": "Only valid windows count. Among valid, we want smallest.",
            "conceptId": "sliding-window"
          }
        ],
        "oneLiner": "Expand right until valid, shrink left while still valid, track minimum. Validity = all target chars satisfied.",
        "pattern": "Sliding Window",
        "keyInsight": "Expand window until valid (contains all of t). Then shrink from left while still valid. Track minimum.",
        "timeComplexity": "O(|s| + |t|)",
        "spaceComplexity": "O(|s| + |t|)",
        "triggerWords": [
          "minimum window substring",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minWindow(s: str, t: str) -> str:\n    if not t or not s:\n        return \"\"\n    \n    from collections import Counter\n    t_count = Counter(t)\n    required = len(t_count)\n    \n    left = 0\n    formed = 0\n    window_count = {}\n    ans = (float('inf'), None, None)  # (length, left, right)\n    \n    for right in range(len(s)):\n        char = s[right]\n        window_count[char] = window_count.get(char, 0) + 1\n        \n        if char in t_count and window_count[char] == t_count[char]:\n            formed += 1\n        \n        # Shrink window while valid\n        while formed == required:\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            left_char = s[left]\n            window_count[left_char] -= 1\n            if left_char in t_count and window_count[left_char] < t_count[left_char]:\n                formed -= 1\n            left += 1\n    \n    return \"\" if ans[0] == float('inf') else s[ans[1]:ans[2]+1]"
      },
      {
        "id": "06-sliding-window-maximum",
        "slug": "sliding-window-maximum",
        "title": "Sliding Window Maximum",
        "category": "sliding-window",
        "difficulty": "medium",
        "tags": [
          "sliding-window",
          "sliding-window-maximum"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of integers `nums`, and there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.\n\nReturn the max sliding window.",
        "examples": [
          {
            "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
            "output": "[3,3,5,5,6,7]",
            "explanation": ""
          },
          {
            "input": "nums = [1], k = 1",
            "output": "[1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A max-heap seems natural for tracking maximum. The issue is:",
            "options": [
              {
                "id": "a",
                "text": "Heaps are too slow"
              },
              {
                "id": "b",
                "text": "Heaps can't handle removing arbitrary elements efficiently"
              },
              {
                "id": "c",
                "text": "Heaps only work for positive numbers"
              },
              {
                "id": "d",
                "text": "Heaps need sorted input"
              }
            ],
            "correct": "b",
            "explanation": "When the window slides, we must remove the element leaving the window. Heaps don't support efficient arbitrary removal (only top removal).",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "When a larger element enters the window, all smaller elements to its left:",
            "options": [
              {
                "id": "a",
                "text": "Become more important"
              },
              {
                "id": "b",
                "text": "Can never be the maximum while the larger element is in the window"
              },
              {
                "id": "c",
                "text": "Should be moved to the front"
              },
              {
                "id": "d",
                "text": "Are immediately removed from array"
              }
            ],
            "correct": "b",
            "explanation": "A smaller element can only become max if all larger elements leave. But the new larger element entered AFTER, so it leaves later. The smaller elements will never be max.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The deque should store:",
            "options": [
              {
                "id": "a",
                "text": "Values in the window"
              },
              {
                "id": "b",
                "text": "Indices of potential maximum candidates"
              },
              {
                "id": "c",
                "text": "All indices in the window"
              },
              {
                "id": "d",
                "text": "Only the current maximum"
              }
            ],
            "correct": "b",
            "explanation": "We store indices because (1) we can get values from indices, and (2) we need indices to check if element is still in window.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "The deque maintains elements in:",
            "options": [
              {
                "id": "a",
                "text": "Increasing order"
              },
              {
                "id": "b",
                "text": "Decreasing order (from front to back)"
              },
              {
                "id": "c",
                "text": "Original order"
              },
              {
                "id": "d",
                "text": "Random order"
              }
            ],
            "correct": "b",
            "explanation": "Front is the maximum. Each subsequent element is smaller but might become max later when larger elements leave.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "Before adding nums[i] to deque, we:",
            "options": [
              {
                "id": "a",
                "text": "Just append it"
              },
              {
                "id": "b",
                "text": "Remove all smaller elements from back"
              },
              {
                "id": "c",
                "text": "Remove all smaller elements from front"
              },
              {
                "id": "d",
                "text": "Clear the entire deque"
              }
            ],
            "correct": "b",
            "explanation": "Elements smaller than nums[i] will never be max while nums[i] is in window. Remove from back (LIFO) to maintain deque order.",
            "conceptId": "monotonic-stack"
          },
          {
            "type": "mcq",
            "question": "We remove from front when:",
            "options": [
              {
                "id": "a",
                "text": "Front value is smaller than new value"
              },
              {
                "id": "b",
                "text": "Front index is outside the current window"
              },
              {
                "id": "c",
                "text": "Deque size exceeds k"
              },
              {
                "id": "d",
                "text": "Always after adding new element"
              }
            ],
            "correct": "b",
            "explanation": "If front index ≤ current index - k, it's no longer in the window. Remove it.",
            "conceptId": "sliding-window"
          }
        ],
        "oneLiner": "Monotonic decreasing deque of indices: remove smaller from back (useless candidates), remove expired from front (out of window). Front is always current max.",
        "pattern": "Sliding Window",
        "keyInsight": "Use a monotonic decreasing deque. Front is always the current max. Remove elements that can't be max for future windows.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "sliding window maximum",
          "sliding-window"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import deque\n\ndef maxSlidingWindow(nums: List[int], k: int) -> List[int]:\n    dq = deque()  # Store indices, decreasing order by value\n    result = []\n    \n    for i in range(len(nums)):\n        # Remove indices outside current window\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove smaller elements from back\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Add max to result once window is complete\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result"
      }
    ],
    "binary-search": [
      {
        "id": "01-binary-search",
        "slug": "binary-search",
        "title": "Binary Search",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "binary-search"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with O(log n) runtime complexity.",
        "examples": [
          {
            "input": "nums = [-1,0,3,5,9,12], target = 9",
            "output": "4",
            "explanation": "9 exists in nums and its index is 4"
          },
          {
            "input": "nums = [-1,0,3,5,9,12], target = 2",
            "output": "-1",
            "explanation": "2 does not exist in nums so return -1"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Binary search is O(log n) because:",
            "options": [
              {
                "id": "a",
                "text": "It uses recursion"
              },
              {
                "id": "b",
                "text": "It halves the search space each iteration"
              },
              {
                "id": "c",
                "text": "It uses a sorted array"
              },
              {
                "id": "d",
                "text": "It only checks odd indices"
              }
            ],
            "correct": "b",
            "explanation": "n → n/2 → n/4 → ... → 1 takes log₂(n) steps.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Binary search requires the array to be:",
            "options": [
              {
                "id": "a",
                "text": "Non-empty"
              },
              {
                "id": "b",
                "text": "Sorted"
              },
              {
                "id": "c",
                "text": "Containing unique elements"
              },
              {
                "id": "d",
                "text": "Having even length"
              }
            ],
            "correct": "b",
            "explanation": "Without sorting, we can't eliminate half based on a single comparison.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "To avoid integer overflow, the middle index should be:",
            "options": [
              {
                "id": "a",
                "text": "(left + right) / 2"
              },
              {
                "id": "b",
                "text": "left + (right - left) / 2"
              },
              {
                "id": "c",
                "text": "right - left / 2"
              },
              {
                "id": "d",
                "text": "(left + right + 1) / 2"
              }
            ],
            "correct": "b",
            "explanation": "left + right can overflow for large indices. This formula avoids it.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If nums[mid] == target:",
            "options": [
              {
                "id": "a",
                "text": "Continue searching left"
              },
              {
                "id": "b",
                "text": "Continue searching right"
              },
              {
                "id": "c",
                "text": "Return mid"
              },
              {
                "id": "d",
                "text": "Return -1"
              }
            ],
            "correct": "c",
            "explanation": "We found it! Return the index.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We search the left half (right = mid - 1) when:",
            "options": [
              {
                "id": "a",
                "text": "target > nums[mid]"
              },
              {
                "id": "b",
                "text": "target < nums[mid]"
              },
              {
                "id": "c",
                "text": "target == nums[mid]"
              },
              {
                "id": "d",
                "text": "left < right"
              }
            ],
            "correct": "b",
            "explanation": "Target is smaller than middle, so it must be in the smaller (left) portion.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "The loop should continue while:",
            "options": [
              {
                "id": "a",
                "text": "left < right"
              },
              {
                "id": "b",
                "text": "left <= right"
              },
              {
                "id": "c",
                "text": "left != right"
              },
              {
                "id": "d",
                "text": "mid != target"
              }
            ],
            "correct": "b",
            "explanation": "When left == right, there's still one element to check. Loop ends when left > right (search space empty).",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Sorted array: compare middle to target, eliminate half. Repeat until found or search space empty.",
        "pattern": "Binary Search",
        "keyInsight": "Sorted array = can eliminate half the search space with each comparison.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "binary search",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1"
      },
      {
        "id": "02-search-2d-matrix",
        "slug": "search-2d-matrix",
        "title": "Search a 2D Matrix",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "search-a-2d-matrix"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an `m x n` integer matrix `matrix` with the following two properties:\n- Each row is sorted in non-decreasing order.\n- The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer `target`, return `true` if `target` is in `matrix` or `false` otherwise.\n\nYou must write a solution in O(log(m * n)) time complexity.",
        "examples": [
          {
            "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Given the two properties, the entire matrix when read row by row is:",
            "options": [
              {
                "id": "a",
                "text": "Partially sorted"
              },
              {
                "id": "b",
                "text": "Fully sorted"
              },
              {
                "id": "c",
                "text": "Unsorted"
              },
              {
                "id": "d",
                "text": "Sorted in each row only"
              }
            ],
            "correct": "b",
            "explanation": "Each row is sorted, and row i's last element < row i+1's first element. So all elements are in ascending order.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "For an m×n matrix, how many elements total?",
            "options": [
              {
                "id": "a",
                "text": "m + n"
              },
              {
                "id": "b",
                "text": "m × n"
              },
              {
                "id": "c",
                "text": "m - n"
              },
              {
                "id": "d",
                "text": "max(m, n)"
              }
            ],
            "correct": "b",
            "explanation": "m rows, n elements each = m × n total.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "For a 1D index i in a matrix with n columns, the row is:",
            "options": [
              {
                "id": "a",
                "text": "i % n"
              },
              {
                "id": "b",
                "text": "i / n (integer division)"
              },
              {
                "id": "c",
                "text": "i - n"
              },
              {
                "id": "d",
                "text": "n / i"
              }
            ],
            "correct": "b",
            "explanation": "After every n elements, we move to the next row. i / n gives the row number.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "For a 1D index i in a matrix with n columns, the column is:",
            "options": [
              {
                "id": "a",
                "text": "i % n"
              },
              {
                "id": "b",
                "text": "i / n"
              },
              {
                "id": "c",
                "text": "i - n"
              },
              {
                "id": "d",
                "text": "n % i"
              }
            ],
            "correct": "a",
            "explanation": "Position within the row cycles every n elements. i % n gives column.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Binary search should search indices from:",
            "options": [
              {
                "id": "a",
                "text": "0 to m-1"
              },
              {
                "id": "b",
                "text": "0 to n-1"
              },
              {
                "id": "c",
                "text": "0 to m×n-1"
              },
              {
                "id": "d",
                "text": "1 to m×n"
              }
            ],
            "correct": "c",
            "explanation": "Total m×n elements, indices 0 through m×n-1.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Another valid approach is:",
            "options": [
              {
                "id": "a",
                "text": "Binary search to find the row, then binary search within the row"
              },
              {
                "id": "b",
                "text": "Linear search each row"
              },
              {
                "id": "c",
                "text": "Check only diagonal elements"
              },
              {
                "id": "d",
                "text": "Sort the matrix first"
              }
            ],
            "correct": "a",
            "explanation": "Two binary searches: O(log m) + O(log n) = O(log(m×n)). Same complexity!",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Matrix with sorted rows and row-to-row ordering = one sorted array. Binary search with index conversion: row = mid/cols, col = mid%cols.",
        "pattern": "Binary Search",
        "keyInsight": "Treat the 2D matrix as a 1D sorted array. Use index conversion.",
        "timeComplexity": "O(log(m*n))",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "search a 2d matrix",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def searchMatrix(matrix: List[List[int]], target: int) -> bool:\n    if not matrix:\n        return False\n    \n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        row, col = mid // n, mid % n\n        val = matrix[row][col]\n        \n        if val == target:\n            return True\n        elif val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return False"
      },
      {
        "id": "03-koko-eating-bananas",
        "slug": "koko-eating-bananas",
        "title": "Koko Eating Bananas",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "koko-eating-bananas"
        ],
        "estimatedTime": 5,
        "problemStatement": "Koko loves to eat bananas. There are `n` piles of bananas, the `i`th pile has `piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour, she chooses a pile and eats `k` bananas from that pile. If the pile has less than `k` bananas, she eats all of them and will not eat any more bananas during that hour.\n\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.",
        "examples": [
          {
            "input": "piles = [3,6,7,11], h = 8",
            "output": "4",
            "explanation": "At k=4: ceil(3/4) + ceil(6/4) + ceil(7/4) + ceil(11/4) = 1+2+2+3 = 8 hours"
          },
          {
            "input": "piles = [30,11,23,4,20], h = 5",
            "output": "30",
            "explanation": "Must eat one pile per hour (fastest possible)."
          },
          {
            "input": "piles = [30,11,23,4,20], h = 6",
            "output": "23",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We're binary searching for:",
            "options": [
              {
                "id": "a",
                "text": "The index of the largest pile"
              },
              {
                "id": "b",
                "text": "The pile to eat first"
              },
              {
                "id": "c",
                "text": "The eating speed k"
              },
              {
                "id": "d",
                "text": "The number of hours"
              }
            ],
            "correct": "c",
            "explanation": "We want to find the minimum k that allows finishing in h hours. k is a value we're searching for, not an index.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "The minimum possible eating speed is:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "min(piles)"
              },
              {
                "id": "d",
                "text": "h"
              }
            ],
            "correct": "b",
            "explanation": "Must eat at least 1 banana per hour. k=0 means never eating.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "The maximum useful eating speed is:",
            "options": [
              {
                "id": "a",
                "text": "sum(piles)"
              },
              {
                "id": "b",
                "text": "max(piles)"
              },
              {
                "id": "c",
                "text": "len(piles)"
              },
              {
                "id": "d",
                "text": "h"
              }
            ],
            "correct": "b",
            "explanation": "Eating faster than the largest pile gains nothing (can only eat one pile per hour anyway). At k = max(piles), each pile takes exactly 1 hour.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "To eat a pile of size p at speed k, hours needed:",
            "options": [
              {
                "id": "a",
                "text": "p / k"
              },
              {
                "id": "b",
                "text": "ceil(p / k)"
              },
              {
                "id": "c",
                "text": "p * k"
              },
              {
                "id": "d",
                "text": "p - k"
              }
            ],
            "correct": "b",
            "explanation": "If p=7, k=4: eat 4 first hour, 3 second hour = 2 hours = ceil(7/4).",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Total hours at speed k:",
            "options": [
              {
                "id": "a",
                "text": "sum(piles) / k"
              },
              {
                "id": "b",
                "text": "len(piles)"
              },
              {
                "id": "c",
                "text": "sum(ceil(p/k) for each pile)"
              },
              {
                "id": "d",
                "text": "max(piles) / k"
              }
            ],
            "correct": "c",
            "explanation": "Each pile takes ceil(size/k) hours. Sum all piles' times.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If k hours > h (too slow):",
            "options": [
              {
                "id": "a",
                "text": "Try smaller k"
              },
              {
                "id": "b",
                "text": "Try larger k"
              },
              {
                "id": "c",
                "text": "k is the answer"
              },
              {
                "id": "d",
                "text": "No answer exists"
              }
            ],
            "correct": "b",
            "explanation": "Need to eat faster (larger k) to finish in fewer hours.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Binary search on answer: k in [1, max(piles)]. Check if sum(ceil(pile/k)) ≤ h. Find minimum valid k.",
        "pattern": "Binary Search",
        "keyInsight": "Binary search on the answer (k), not on the input.",
        "timeComplexity": "O(n * log(max(piles)))",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "koko eating bananas",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import math\n\ndef minEatingSpeed(piles: List[int], h: int) -> int:\n    left, right = 1, max(piles)\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        # Calculate hours needed at speed mid\n        hours = sum(math.ceil(p / mid) for p in piles)\n        \n        if hours <= h:\n            right = mid  # Can go slower\n        else:\n            left = mid + 1  # Need to go faster\n    \n    return left"
      },
      {
        "id": "04-search-in-rotated-sorted-array",
        "slug": "search-in-rotated-sorted-array",
        "title": "Search in Rotated Sorted Array",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "search-in-rotated-sorted-array"
        ],
        "estimatedTime": 5,
        "problemStatement": "There is an integer array `nums` sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, `nums` is possibly rotated at an unknown pivot index `k` such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`.\n\nGiven the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.\n\nYou must write an algorithm with O(log n) runtime complexity.",
        "examples": [
          {
            "input": "nums = [4,5,6,7,0,1,2], target = 0",
            "output": "4",
            "explanation": ""
          },
          {
            "input": "nums = [4,5,6,7,0,1,2], target = 3",
            "output": "-1",
            "explanation": ""
          },
          {
            "input": "nums = [1], target = 0",
            "output": "-1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "After rotation, the array:",
            "options": [
              {
                "id": "a",
                "text": "Becomes unsorted"
              },
              {
                "id": "b",
                "text": "Has two sorted portions"
              },
              {
                "id": "c",
                "text": "Has random order"
              },
              {
                "id": "d",
                "text": "Stays the same"
              }
            ],
            "correct": "b",
            "explanation": "[1,2,3,4,5] rotated → [4,5,1,2,3]. Both [4,5] and [1,2,3] are sorted.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "At index mid, the left half [left...mid] is sorted if:",
            "options": [
              {
                "id": "a",
                "text": "nums[mid] > nums[right]"
              },
              {
                "id": "b",
                "text": "nums[left] <= nums[mid]"
              },
              {
                "id": "c",
                "text": "mid > left"
              },
              {
                "id": "d",
                "text": "nums[left] < nums[right]"
              }
            ],
            "correct": "b",
            "explanation": "If left element ≤ mid element, the left half is in ascending order (no rotation break in this half).",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If left half is sorted, target is in left half if:",
            "options": [
              {
                "id": "a",
                "text": "target > nums[mid]"
              },
              {
                "id": "b",
                "text": "target < nums[left]"
              },
              {
                "id": "c",
                "text": "nums[left] <= target < nums[mid]"
              },
              {
                "id": "d",
                "text": "target == nums[left]"
              }
            ],
            "correct": "c",
            "explanation": "Target must be ≥ the sorted half's minimum and < its maximum (mid) to be in that range.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If left half is sorted and target is NOT in left half:",
            "options": [
              {
                "id": "a",
                "text": "Search left half anyway"
              },
              {
                "id": "b",
                "text": "Search right half"
              },
              {
                "id": "c",
                "text": "Return -1"
              },
              {
                "id": "d",
                "text": "Restart the search"
              }
            ],
            "correct": "b",
            "explanation": "If target isn't in the sorted left, it must be in the right (if it exists).",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If left half is NOT sorted (nums[left] > nums[mid]), then:",
            "options": [
              {
                "id": "a",
                "text": "Neither half is sorted"
              },
              {
                "id": "b",
                "text": "Right half must be sorted"
              },
              {
                "id": "c",
                "text": "The pivot is at mid"
              },
              {
                "id": "d",
                "text": "Target doesn't exist"
              }
            ],
            "correct": "b",
            "explanation": "One half must always be sorted. If left isn't, right is.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "Within a sorted half, we can:",
            "options": [
              {
                "id": "a",
                "text": "Only do linear search"
              },
              {
                "id": "b",
                "text": "Apply standard binary search logic"
              },
              {
                "id": "c",
                "text": "Skip elements randomly"
              },
              {
                "id": "d",
                "text": "Reverse and search"
              }
            ],
            "correct": "b",
            "explanation": "A sorted portion allows normal binary search range checking.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "At mid, one half is sorted. Check if target is in the sorted half's range; if yes search there, else search the other half.",
        "pattern": "Binary Search",
        "keyInsight": "At any midpoint, at least one half is properly sorted. Check if target is in the sorted half.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "search in rotated sorted array",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        # Left half is sorted\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        # Right half is sorted\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1"
      },
      {
        "id": "05-find-minimum-in-rotated-sorted-array",
        "slug": "find-minimum-in-rotated-sorted-array",
        "title": "Find Minimum in Rotated Sorted Array",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "find-minimum-in-rotated-sorted-array"
        ],
        "estimatedTime": 5,
        "problemStatement": "Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n- `[4,5,6,7,0,1,2]` if it was rotated 4 times.\n- `[0,1,2,4,5,6,7]` if it was rotated 7 times.\n\nGiven the sorted rotated array `nums` of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
          {
            "input": "nums = [3,4,5,1,2]",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "nums = [4,5,6,7,0,1,2]",
            "output": "0",
            "explanation": ""
          },
          {
            "input": "nums = [11,13,15,17]",
            "output": "11",
            "explanation": "Array not rotated (or rotated n times), minimum at start."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "In a rotated sorted array, the minimum element is:",
            "options": [
              {
                "id": "a",
                "text": "Always at index 0"
              },
              {
                "id": "b",
                "text": "Always at index n-1"
              },
              {
                "id": "c",
                "text": "At the rotation point (where the \"break\" occurs)"
              },
              {
                "id": "d",
                "text": "In the middle"
              }
            ],
            "correct": "c",
            "explanation": "[4,5,6,7,0,1,2] — minimum 0 is where the sequence breaks from 7 to 0.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If the array is sorted (not rotated or rotated n times), minimum is at:",
            "options": [
              {
                "id": "a",
                "text": "Index 0"
              },
              {
                "id": "b",
                "text": "Index n-1"
              },
              {
                "id": "c",
                "text": "Middle index"
              },
              {
                "id": "d",
                "text": "Nowhere determinable"
              }
            ],
            "correct": "a",
            "explanation": "[1,2,3,4,5] — standard sorted, minimum is first element.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We compare nums[mid] with nums[right] because:",
            "options": [
              {
                "id": "a",
                "text": "It's simpler than comparing with left"
              },
              {
                "id": "b",
                "text": "It tells us which half contains the minimum"
              },
              {
                "id": "c",
                "text": "The right element is always the minimum"
              },
              {
                "id": "d",
                "text": "Random choice"
              }
            ],
            "correct": "b",
            "explanation": "If mid > right, the break is between mid and right (min is right of mid). If mid < right, this portion is sorted, so min is at or left of mid.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If nums[mid] > nums[right], the minimum is:",
            "options": [
              {
                "id": "a",
                "text": "At mid"
              },
              {
                "id": "b",
                "text": "To the left of mid"
              },
              {
                "id": "c",
                "text": "To the right of mid"
              },
              {
                "id": "d",
                "text": "At the right end"
              }
            ],
            "correct": "c",
            "explanation": "Mid being greater than right means there's a \"drop\" somewhere between mid and right. The minimum is in the right half.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If nums[mid] < nums[right], the minimum:",
            "options": [
              {
                "id": "a",
                "text": "Might be at mid itself"
              },
              {
                "id": "b",
                "text": "Is definitely not at mid"
              },
              {
                "id": "c",
                "text": "Is at the right end"
              },
              {
                "id": "d",
                "text": "Doesn't exist"
              }
            ],
            "correct": "a",
            "explanation": "The portion from mid to right is sorted. The minimum could be mid or something to its left. Don't exclude mid.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We use `left < right` (not `left <= right`) because:",
            "options": [
              {
                "id": "a",
                "text": "We're finding a value, not searching for a target"
              },
              {
                "id": "b",
                "text": "It's faster"
              },
              {
                "id": "c",
                "text": "Prevents off-by-one errors only"
              },
              {
                "id": "d",
                "text": "No particular reason"
              }
            ],
            "correct": "a",
            "explanation": "We're narrowing down to the minimum. When left == right, that's our answer. No need to check equality.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Compare mid with right: if mid > right, minimum is in right half (left = mid + 1). Else minimum is at mid or left (right = mid). Converge to find break point.",
        "pattern": "Binary Search",
        "keyInsight": "The minimum is where the \"break\" happens — where a larger element is followed by a smaller one.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "find minimum in rotated sorted array",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findMin(nums: List[int]) -> int:\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] > nums[right]:\n            # Minimum is in right half\n            left = mid + 1\n        else:\n            # Minimum is at mid or left of mid\n            right = mid\n    \n    return nums[left]"
      },
      {
        "id": "06-time-based-key-value-store",
        "slug": "time-based-key-value-store",
        "title": "Time Based Key-Value Store",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "time-based-key-value-store"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\n\nImplement the `TimeMap` class:\n- `TimeMap()` Initializes the object.\n- `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time `timestamp`.\n- `String get(String key, int timestamp)` Returns a value such that `set` was called previously, with `timestamp_prev <= timestamp`. If there are multiple such values, it returns the value associated with the largest `timestamp_prev`. If there are no values, it returns `\"\"`.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To map keys to their history, use:",
            "options": [
              {
                "id": "a",
                "text": "Array"
              },
              {
                "id": "b",
                "text": "Hash map with key → list of (timestamp, value)"
              },
              {
                "id": "c",
                "text": "Sorted set"
              },
              {
                "id": "d",
                "text": "Queue"
              }
            ],
            "correct": "b",
            "explanation": "Need O(1) key lookup. Each key has multiple (timestamp, value) pairs.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "The constraint \"timestamps are strictly increasing\" means:",
            "options": [
              {
                "id": "a",
                "text": "We must sort after each insert"
              },
              {
                "id": "b",
                "text": "Appending maintains sorted order"
              },
              {
                "id": "c",
                "text": "We need a heap"
              },
              {
                "id": "d",
                "text": "Order doesn't matter"
              }
            ],
            "correct": "b",
            "explanation": "New timestamps are always larger, so appending naturally keeps list sorted.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "get(key, timestamp) should return:",
            "options": [
              {
                "id": "a",
                "text": "Exact match or nothing"
              },
              {
                "id": "b",
                "text": "Value with smallest timestamp"
              },
              {
                "id": "c",
                "text": "Value with largest timestamp ≤ query"
              },
              {
                "id": "d",
                "text": "Value with smallest timestamp > query"
              }
            ],
            "correct": "c",
            "explanation": "\"Most recent before or at this time\" = largest timestamp that doesn't exceed query.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We need binary search to find:",
            "options": [
              {
                "id": "a",
                "text": "Exact timestamp match"
              },
              {
                "id": "b",
                "text": "Rightmost timestamp ≤ query (upper bound - 1)"
              },
              {
                "id": "c",
                "text": "Leftmost timestamp ≥ query"
              },
              {
                "id": "d",
                "text": "Any timestamp"
              }
            ],
            "correct": "b",
            "explanation": "We want the largest timestamp not exceeding query. This is floor/predecessor search.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If no timestamp ≤ query exists:",
            "options": [
              {
                "id": "a",
                "text": "Return the first value"
              },
              {
                "id": "b",
                "text": "Return the last value"
              },
              {
                "id": "c",
                "text": "Return empty string"
              },
              {
                "id": "d",
                "text": "Throw error"
              }
            ],
            "correct": "c",
            "explanation": "Problem states to return \"\" if no valid timestamp found.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "With n entries for a key, get() takes:",
            "options": [
              {
                "id": "a",
                "text": "O(1)"
              },
              {
                "id": "b",
                "text": "O(log n)"
              },
              {
                "id": "c",
                "text": "O(n)"
              },
              {
                "id": "d",
                "text": "O(n log n)"
              }
            ],
            "correct": "b",
            "explanation": "Binary search on sorted list of timestamps.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Store (timestamp, value) pairs per key. Timestamps increase so list stays sorted. Binary search for largest timestamp ≤ query.",
        "pattern": "Binary Search",
        "keyInsight": "Timestamps are always increasing. Store (timestamp, value) pairs per key in sorted order. Binary search for largest timestamp ≤ query.",
        "timeComplexity": "set: O(1), get: O(log n)",
        "spaceComplexity": "O(total entries)",
        "triggerWords": [
          "time based key-value store",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class TimeMap:\n    def __init__(self):\n        self.store = {}  # key -> [(timestamp, value), ...]\n    \n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.store:\n            self.store[key] = []\n        self.store[key].append((timestamp, value))\n    \n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"\n        \n        values = self.store[key]\n        left, right = 0, len(values) - 1\n        result = \"\"\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if values[mid][0] <= timestamp:\n                result = values[mid][1]\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return result"
      },
      {
        "id": "07-median-of-two-sorted-arrays",
        "slug": "median-of-two-sorted-arrays",
        "title": "Median of Two Sorted Arrays",
        "category": "binary-search",
        "difficulty": "medium",
        "tags": [
          "binary-search",
          "median-of-two-sorted-arrays"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
          {
            "input": "nums1 = [1,3], nums2 = [2]",
            "output": "2.0",
            "explanation": "merged = [1,2,3], median = 2"
          },
          {
            "input": "nums1 = [1,2], nums2 = [3,4]",
            "output": "2.5",
            "explanation": "merged = [1,2,3,4], median = (2+3)/2 = 2.5"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For n elements, the median is:",
            "options": [
              {
                "id": "a",
                "text": "The first element"
              },
              {
                "id": "b",
                "text": "The last element"
              },
              {
                "id": "c",
                "text": "Middle element (odd n) or average of two middle (even n)"
              },
              {
                "id": "d",
                "text": "The maximum element"
              }
            ],
            "correct": "c",
            "explanation": "Median = value that separates the higher half from lower half.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "For total = m + n elements, the left partition should contain:",
            "options": [
              {
                "id": "a",
                "text": "(m + n) / 2 elements always"
              },
              {
                "id": "b",
                "text": "(m + n + 1) / 2 elements"
              },
              {
                "id": "c",
                "text": "m elements"
              },
              {
                "id": "d",
                "text": "n elements"
              }
            ],
            "correct": "b",
            "explanation": "For odd total, include the median in left. For even total, this equals half. Works for both.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If we take i elements from nums1 for left partition, from nums2 we take:",
            "options": [
              {
                "id": "a",
                "text": "i elements"
              },
              {
                "id": "b",
                "text": "half - i elements"
              },
              {
                "id": "c",
                "text": "n - i elements"
              },
              {
                "id": "d",
                "text": "m - i elements"
              }
            ],
            "correct": "b",
            "explanation": "Total left = half = i + j, so j = half - i.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "A partition is valid when:",
            "options": [
              {
                "id": "a",
                "text": "Left and right have equal size"
              },
              {
                "id": "b",
                "text": "nums1[i-1] ≤ nums2[j] AND nums2[j-1] ≤ nums1[i]"
              },
              {
                "id": "c",
                "text": "All elements are equal"
              },
              {
                "id": "d",
                "text": "i = j"
              }
            ],
            "correct": "b",
            "explanation": "max(left of nums1) ≤ min(right of nums2), AND max(left of nums2) ≤ min(right of nums1). This ensures left ≤ right overall.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "If nums1[i-1] > nums2[j], we should:",
            "options": [
              {
                "id": "a",
                "text": "Increase i (take more from nums1)"
              },
              {
                "id": "b",
                "text": "Decrease i (take fewer from nums1)"
              },
              {
                "id": "c",
                "text": "Increase j"
              },
              {
                "id": "d",
                "text": "Start over"
              }
            ],
            "correct": "b",
            "explanation": "nums1's left side has an element too large. Move partition left in nums1 to reduce it.",
            "conceptId": "binary-search"
          },
          {
            "type": "mcq",
            "question": "We binary search on the smaller array because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "Ensures j = half - i is always valid (non-negative)"
              },
              {
                "id": "c",
                "text": "Smaller arrays are always sorted"
              },
              {
                "id": "d",
                "text": "No particular reason"
              }
            ],
            "correct": "b",
            "explanation": "If we search on larger array, i might be so large that j becomes negative. Searching smaller ensures 0 ≤ j ≤ n.",
            "conceptId": "binary-search"
          }
        ],
        "oneLiner": "Binary search partition point in smaller array. Valid partition: max(left_halves) ≤ min(right_halves). Median from partition boundaries.",
        "pattern": "Binary Search",
        "keyInsight": "Binary search for a partition: split both arrays such that left partition has exactly half the total elements, and all left elements ≤ all right elements.",
        "timeComplexity": "O(log(min(m,n)))",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "median of two sorted arrays",
          "binary-search"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:\n    # Ensure nums1 is smaller\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    half = (m + n + 1) // 2\n    left, right = 0, m\n    \n    while left <= right:\n        i = (left + right) // 2  # Partition in nums1\n        j = half - i              # Partition in nums2\n        \n        left1 = nums1[i-1] if i > 0 else float('-inf')\n        right1 = nums1[i] if i < m else float('inf')\n        left2 = nums2[j-1] if j > 0 else float('-inf')\n        right2 = nums2[j] if j < n else float('inf')\n        \n        if left1 <= right2 and left2 <= right1:\n            # Valid partition\n            if (m + n) % 2 == 1:\n                return max(left1, left2)\n            return (max(left1, left2) + min(right1, right2)) / 2\n        elif left1 > right2:\n            right = i - 1\n        else:\n            left = i + 1\n    \n    return 0.0"
      }
    ],
    "linked-list": [
      {
        "id": "01-reverse-linked-list",
        "slug": "reverse-linked-list",
        "title": "Reverse Linked List",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "reverse-linked-list"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.",
        "examples": [
          {
            "input": "head = [1,2,3,4,5]",
            "output": "[5,4,3,2,1]",
            "explanation": ""
          },
          {
            "input": "head = [1,2]",
            "output": "[2,1]",
            "explanation": ""
          },
          {
            "input": "head = []",
            "output": "[]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To reverse a linked list, we change each node's:",
            "options": [
              {
                "id": "a",
                "text": "Value"
              },
              {
                "id": "b",
                "text": "next pointer"
              },
              {
                "id": "c",
                "text": "Address"
              },
              {
                "id": "d",
                "text": "Nothing, we build new nodes"
              }
            ],
            "correct": "b",
            "explanation": "We don't change values or create nodes. We just redirect pointers.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After setting curr.next = prev, we lose:",
            "options": [
              {
                "id": "a",
                "text": "Reference to prev"
              },
              {
                "id": "b",
                "text": "Reference to curr"
              },
              {
                "id": "c",
                "text": "Reference to the original next node"
              },
              {
                "id": "d",
                "text": "Nothing"
              }
            ],
            "correct": "c",
            "explanation": "curr.next used to point forward. After changing it, we can't reach the rest of the list without saving it first.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "To reverse iteratively, we need how many pointers?",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "2"
              },
              {
                "id": "c",
                "text": "3"
              },
              {
                "id": "d",
                "text": "4"
              }
            ],
            "correct": "c",
            "explanation": "prev (new next), curr (current node), next_temp (saved forward reference).",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "At the start, prev should be:",
            "options": [
              {
                "id": "a",
                "text": "head"
              },
              {
                "id": "b",
                "text": "null/None"
              },
              {
                "id": "c",
                "text": "The last node"
              },
              {
                "id": "d",
                "text": "A new node"
              }
            ],
            "correct": "b",
            "explanation": "After reversal, the original head becomes the tail, pointing to null.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We continue the loop while:",
            "options": [
              {
                "id": "a",
                "text": "prev is not null"
              },
              {
                "id": "b",
                "text": "curr is not null"
              },
              {
                "id": "c",
                "text": "next_temp is not null"
              },
              {
                "id": "d",
                "text": "We've seen n nodes"
              }
            ],
            "correct": "b",
            "explanation": "curr traverses each node. When curr is null, we've processed all nodes.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After the loop, we return:",
            "options": [
              {
                "id": "a",
                "text": "curr (which is null)"
              },
              {
                "id": "b",
                "text": "prev (which is the new head)"
              },
              {
                "id": "c",
                "text": "head (the original head)"
              },
              {
                "id": "d",
                "text": "next_temp"
              }
            ],
            "correct": "b",
            "explanation": "prev ends up pointing to the last node we processed, which is the new head.",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Save next, point current backward, advance. Repeat until end. Return prev as new head.",
        "pattern": "Linked List",
        "keyInsight": "To reverse, change each node's `next` pointer to point to its previous node.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reverse linked list",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reverseList(head: ListNode) -> ListNode:\n    prev = None\n    curr = head\n    \n    while curr:\n        next_temp = curr.next  # Save next\n        curr.next = prev       # Reverse pointer\n        prev = curr            # Move prev forward\n        curr = next_temp       # Move curr forward\n    \n    return prev"
      },
      {
        "id": "02-merge-two-sorted-lists",
        "slug": "merge-two-sorted-lists",
        "title": "Merge Two Sorted Lists",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "merge-two-sorted-lists"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
        "examples": [
          {
            "input": "list1 = [1,2,4], list2 = [1,3,4]",
            "output": "[1,1,2,3,4,4]",
            "explanation": ""
          },
          {
            "input": "list1 = [], list2 = []",
            "output": "[]",
            "explanation": ""
          },
          {
            "input": "list1 = [], list2 = [0]",
            "output": "[0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At each step, we compare:",
            "options": [
              {
                "id": "a",
                "text": "Tails of both lists"
              },
              {
                "id": "b",
                "text": "Heads (current nodes) of both lists"
              },
              {
                "id": "c",
                "text": "All nodes of both lists"
              },
              {
                "id": "d",
                "text": "Random nodes"
              }
            ],
            "correct": "b",
            "explanation": "Both lists are sorted. Smallest remaining element is always at the head of one list.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "If list1.val < list2.val, we:",
            "options": [
              {
                "id": "a",
                "text": "Take node from list2"
              },
              {
                "id": "b",
                "text": "Take node from list1"
              },
              {
                "id": "c",
                "text": "Take from either"
              },
              {
                "id": "d",
                "text": "Swap them"
              }
            ],
            "correct": "b",
            "explanation": "We want sorted order. Smaller goes first.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After appending a node from list1, we:",
            "options": [
              {
                "id": "a",
                "text": "Stay at same position in list1"
              },
              {
                "id": "b",
                "text": "Advance list1 to list1.next"
              },
              {
                "id": "c",
                "text": "Advance list2"
              },
              {
                "id": "d",
                "text": "Reset to beginning"
              }
            ],
            "correct": "b",
            "explanation": "We've used this node. Move to the next candidate.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "A dummy node helps because:",
            "options": [
              {
                "id": "a",
                "text": "It stores extra data"
              },
              {
                "id": "b",
                "text": "It simplifies handling the head of result"
              },
              {
                "id": "c",
                "text": "It makes the list circular"
              },
              {
                "id": "d",
                "text": "It's required for linked lists"
              }
            ],
            "correct": "b",
            "explanation": "Without dummy, we need special logic for the first node. With dummy, we always append to dummy's current position.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "When list1 becomes null (exhausted):",
            "options": [
              {
                "id": "a",
                "text": "Return null"
              },
              {
                "id": "b",
                "text": "Append remaining list2"
              },
              {
                "id": "c",
                "text": "Stop immediately"
              },
              {
                "id": "d",
                "text": "Restart list1"
              }
            ],
            "correct": "b",
            "explanation": "Remaining nodes of list2 are already sorted. Just attach them.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We return:",
            "options": [
              {
                "id": "a",
                "text": "The dummy node"
              },
              {
                "id": "b",
                "text": "dummy.next"
              },
              {
                "id": "c",
                "text": "list1"
              },
              {
                "id": "d",
                "text": "list2"
              }
            ],
            "correct": "b",
            "explanation": "Dummy is just a placeholder. The actual merged list starts at dummy.next.",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Compare heads, take smaller, advance that pointer. Use dummy node. Attach remaining list when one exhausts.",
        "pattern": "Linked List",
        "keyInsight": "Compare heads of both lists. Take the smaller one, advance that list's pointer. Repeat.",
        "timeComplexity": "O(n + m)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "merge two sorted lists",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def mergeTwoLists(list1: ListNode, list2: ListNode) -> ListNode:\n    dummy = ListNode()\n    curr = dummy\n    \n    while list1 and list2:\n        if list1.val <= list2.val:\n            curr.next = list1\n            list1 = list1.next\n        else:\n            curr.next = list2\n            list2 = list2.next\n        curr = curr.next\n    \n    # Attach remaining nodes\n    curr.next = list1 if list1 else list2\n    \n    return dummy.next"
      },
      {
        "id": "03-linked-list-cycle",
        "slug": "linked-list-cycle",
        "title": "Linked List Cycle",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "linked-list-cycle"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer.\n\nReturn `true` if there is a cycle in the linked list. Otherwise, return `false`.",
        "examples": [
          {
            "input": "head = [3,2,0,-4], pos = 1",
            "output": "true",
            "explanation": "Tail connects to node at index 1 (0-indexed)."
          },
          {
            "input": "head = [1,2], pos = 0",
            "output": "true",
            "explanation": "Tail connects to node at index 0."
          },
          {
            "input": "head = [1], pos = -1",
            "output": "false",
            "explanation": "No cycle."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To detect a cycle, we could:",
            "options": [
              {
                "id": "a",
                "text": "Store visited nodes in a set and check for repeats"
              },
              {
                "id": "b",
                "text": "Count the number of nodes"
              },
              {
                "id": "c",
                "text": "Reverse the list"
              },
              {
                "id": "d",
                "text": "Check if head is null"
              }
            ],
            "correct": "a",
            "explanation": "If we see the same node twice, there's a cycle. But this uses O(n) space.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "If fast moves 2x speed of slow, in a cycle:",
            "options": [
              {
                "id": "a",
                "text": "They'll never meet"
              },
              {
                "id": "b",
                "text": "Fast will eventually catch slow"
              },
              {
                "id": "c",
                "text": "Slow catches fast"
              },
              {
                "id": "d",
                "text": "Both reach the end"
              }
            ],
            "correct": "b",
            "explanation": "In a cycle, fast gains 1 position on slow each step. Eventually the gap closes to 0.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "If slow is at position S and fast is at position F in a cycle:",
            "options": [
              {
                "id": "a",
                "text": "The gap increases"
              },
              {
                "id": "b",
                "text": "The gap stays same"
              },
              {
                "id": "c",
                "text": "The gap decreases by 1 each step"
              },
              {
                "id": "d",
                "text": "The gap oscillates"
              }
            ],
            "correct": "c",
            "explanation": "Fast moves 2, slow moves 1. Relative movement = 1. Gap shrinks by 1.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "If there's no cycle:",
            "options": [
              {
                "id": "a",
                "text": "Slow reaches null first"
              },
              {
                "id": "b",
                "text": "Fast reaches null first"
              },
              {
                "id": "c",
                "text": "Neither reaches null"
              },
              {
                "id": "d",
                "text": "Both reach null together"
              }
            ],
            "correct": "b",
            "explanation": "Fast moves faster, so it hits the end of the list first (or fast.next is null).",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "We continue the loop while:",
            "options": [
              {
                "id": "a",
                "text": "slow is not null"
              },
              {
                "id": "b",
                "text": "fast is not null AND fast.next is not null"
              },
              {
                "id": "c",
                "text": "slow != fast"
              },
              {
                "id": "d",
                "text": "We've visited n nodes"
              }
            ],
            "correct": "b",
            "explanation": "Fast moves 2 steps, so we need both fast and fast.next to exist.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "If slow == fast during traversal:",
            "options": [
              {
                "id": "a",
                "text": "There might be a cycle"
              },
              {
                "id": "b",
                "text": "There is definitely a cycle"
              },
              {
                "id": "c",
                "text": "There is no cycle"
              },
              {
                "id": "d",
                "text": "The list is empty"
              }
            ],
            "correct": "b",
            "explanation": "For them to meet, fast must have gone around and caught up. Only possible in a cycle.",
            "conceptId": "floyd-cycle"
          }
        ],
        "oneLiner": "Slow moves 1, fast moves 2. If cycle exists, fast catches slow. If no cycle, fast reaches null.",
        "pattern": "Linked List",
        "keyInsight": "Fast and slow pointers: if there's a cycle, they will eventually meet.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "linked list cycle",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def hasCycle(head: ListNode) -> bool:\n    slow = fast = head\n    \n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        \n        if slow == fast:\n            return True\n    \n    return False"
      },
      {
        "id": "04-reorder-list",
        "slug": "reorder-list",
        "title": "Reorder List",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "reorder-list"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given the head of a singly linked list. The list can be represented as:\n```\nL0 → L1 → L2 → ... → Ln-1 → Ln\n```\n\nReorder the list to be in the following form:\n```\nL0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...\n```\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.",
        "examples": [
          {
            "input": "head = [1,2,3,4]",
            "output": "[1,4,2,3]",
            "explanation": ""
          },
          {
            "input": "head = [1,2,3,4,5]",
            "output": "[1,5,2,4,3]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To access nodes from the end, we need to:",
            "options": [
              {
                "id": "a",
                "text": "Use recursion only"
              },
              {
                "id": "b",
                "text": "Reverse the entire list"
              },
              {
                "id": "c",
                "text": "Reverse just the second half"
              },
              {
                "id": "d",
                "text": "Copy to an array"
              }
            ],
            "correct": "c",
            "explanation": "We need first half forward, second half backward. Reverse only second half.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "To find the middle of a linked list efficiently:",
            "options": [
              {
                "id": "a",
                "text": "Count nodes, then traverse to n/2"
              },
              {
                "id": "b",
                "text": "Use fast and slow pointers"
              },
              {
                "id": "c",
                "text": "Use a stack"
              },
              {
                "id": "d",
                "text": "Guess"
              }
            ],
            "correct": "b",
            "explanation": "When fast reaches end, slow is at middle. O(n) time, O(1) space.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "For [1,2,3,4,5], the middle element (3) should:",
            "options": [
              {
                "id": "a",
                "text": "Go in the first half"
              },
              {
                "id": "b",
                "text": "Go in the second half"
              },
              {
                "id": "c",
                "text": "Be removed"
              },
              {
                "id": "d",
                "text": "Stay at its position"
              }
            ],
            "correct": "a",
            "explanation": "After merge, order is 1,5,2,4,3. The middle element ends up at the end of the result.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "When merging [1,2,3] and [5,4], we alternate:",
            "options": [
              {
                "id": "a",
                "text": "All of first, then all of second"
              },
              {
                "id": "b",
                "text": "1 from first, 1 from second, repeat"
              },
              {
                "id": "c",
                "text": "2 from first, 2 from second"
              },
              {
                "id": "d",
                "text": "Randomly"
              }
            ],
            "correct": "b",
            "explanation": "The pattern is L0, Ln, L1, Ln-1, ... — alternating from front and back.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We stop merging when:",
            "options": [
              {
                "id": "a",
                "text": "First half is exhausted"
              },
              {
                "id": "b",
                "text": "Second half is exhausted"
              },
              {
                "id": "c",
                "text": "Both are exhausted"
              },
              {
                "id": "d",
                "text": "They're equal length"
              }
            ],
            "correct": "b",
            "explanation": "Second half is equal or shorter. When it's done, first half might have one node left (the original middle).",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "This problem should be solved in:",
            "options": [
              {
                "id": "a",
                "text": "O(n) space"
              },
              {
                "id": "b",
                "text": "O(log n) space"
              },
              {
                "id": "c",
                "text": "O(1) space"
              },
              {
                "id": "d",
                "text": "Space doesn't matter"
              }
            ],
            "correct": "c",
            "explanation": "All three steps (find middle, reverse, merge) can be done in-place with O(1) extra space.",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Find middle, reverse second half, merge alternately. Three fundamental operations combined.",
        "pattern": "Linked List",
        "keyInsight": "Three steps: find middle with slow/fast, reverse second half, merge alternately.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reorder list",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reorderList(head: ListNode) -> None:\n    if not head or not head.next:\n        return\n    \n    # 1. Find middle with slow/fast\n    slow = fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # 2. Reverse second half\n    prev, curr = None, slow.next\n    slow.next = None  # Cut the list\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    # 3. Merge two halves alternately\n    first, second = head, prev\n    while second:\n        tmp1, tmp2 = first.next, second.next\n        first.next = second\n        second.next = tmp1\n        first, second = tmp1, tmp2"
      },
      {
        "id": "05-remove-nth-node-from-end",
        "slug": "remove-nth-node-from-end",
        "title": "Remove Nth Node From End of List",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "remove-nth-node-from-end-of-list"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `head` of a linked list, remove the `n`th node from the end of the list and return its head.",
        "examples": [
          {
            "input": "head = [1,2,3,4,5], n = 2",
            "output": "[1,2,3,5]",
            "explanation": "Remove 4 (2nd from end)"
          },
          {
            "input": "head = [1], n = 1",
            "output": "[]",
            "explanation": ""
          },
          {
            "input": "head = [1,2], n = 1",
            "output": "[1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A two-pass solution would:",
            "options": [
              {
                "id": "a",
                "text": "First count nodes, then remove (n-k+1)th"
              },
              {
                "id": "b",
                "text": "Not work for linked lists"
              },
              {
                "id": "c",
                "text": "Be faster than one-pass"
              },
              {
                "id": "d",
                "text": "Use less memory"
              }
            ],
            "correct": "a",
            "explanation": "Count length L, then remove node at position L-n+1 (0-indexed: L-n). This works but requires 2 traversals.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "If fast is n steps ahead of slow, when fast is at end:",
            "options": [
              {
                "id": "a",
                "text": "slow is at the target node"
              },
              {
                "id": "b",
                "text": "slow is right before the target node"
              },
              {
                "id": "c",
                "text": "slow is n steps past the target"
              },
              {
                "id": "d",
                "text": "slow is at the beginning"
              }
            ],
            "correct": "b",
            "explanation": "We want slow to stop at the node BEFORE the target, so we can do slow.next = slow.next.next.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "To create a gap of n, we:",
            "options": [
              {
                "id": "a",
                "text": "Move slow n steps first"
              },
              {
                "id": "b",
                "text": "Move fast n steps first"
              },
              {
                "id": "c",
                "text": "Move both n steps"
              },
              {
                "id": "d",
                "text": "Start fast at position n"
              }
            ],
            "correct": "b",
            "explanation": "Advance fast by n steps. Now fast is n ahead of slow (which is still at start).",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "If we need to remove the head (n equals list length):",
            "options": [
              {
                "id": "a",
                "text": "We can't use this method"
              },
              {
                "id": "b",
                "text": "Use a dummy node before head"
              },
              {
                "id": "c",
                "text": "Return null always"
              },
              {
                "id": "d",
                "text": "Move slow backward"
              }
            ],
            "correct": "b",
            "explanation": "Dummy node handles edge case. slow.next = slow.next.next works even when target is head.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We stop advancing when:",
            "options": [
              {
                "id": "a",
                "text": "fast is null"
              },
              {
                "id": "b",
                "text": "fast.next is null"
              },
              {
                "id": "c",
                "text": "slow.next is null"
              },
              {
                "id": "d",
                "text": "We've moved n times"
              }
            ],
            "correct": "a",
            "explanation": "We want slow to be one before target. Stop when fast reaches null.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "After fast is n ahead, we:",
            "options": [
              {
                "id": "a",
                "text": "Move only fast"
              },
              {
                "id": "b",
                "text": "Move only slow"
              },
              {
                "id": "c",
                "text": "Move both together until fast is null"
              },
              {
                "id": "d",
                "text": "Reverse the list"
              }
            ],
            "correct": "c",
            "explanation": "Maintain the gap. When fast reaches null, slow is in position.",
            "conceptId": "two-pointers"
          }
        ],
        "oneLiner": "Create n-step gap between fast and slow. Move both until fast at end. Slow is before target. Delete slow.next.",
        "pattern": "Linked List",
        "keyInsight": "Use two pointers with a gap of n nodes. When the fast pointer reaches the end, the slow pointer is at the node before the target.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "remove nth node from end of list",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def removeNthFromEnd(head: ListNode, n: int) -> ListNode:\n    dummy = ListNode(0, head)\n    slow = fast = dummy\n    \n    # Move fast n+1 steps ahead\n    for _ in range(n + 1):\n        fast = fast.next\n    \n    # Move both until fast reaches end\n    while fast:\n        slow = slow.next\n        fast = fast.next\n    \n    # Remove the nth node\n    slow.next = slow.next.next\n    \n    return dummy.next"
      },
      {
        "id": "06-copy-list-with-random-pointer",
        "slug": "copy-list-with-random-pointer",
        "title": "Copy List with Random Pointer",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "copy-list-with-random-pointer"
        ],
        "estimatedTime": 5,
        "problemStatement": "A linked list of length `n` is given such that each node contains an additional random pointer, which could point to any node in the list, or `null`.\n\nConstruct a deep copy of the list. The deep copy should consist of exactly `n` brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state.\n\nReturn the head of the copied linked list.",
        "examples": [
          {
            "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
            "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Simply creating nodes as we traverse fails because:",
            "options": [
              {
                "id": "a",
                "text": "We can't create new nodes"
              },
              {
                "id": "b",
                "text": "Random might point to a node not yet created"
              },
              {
                "id": "c",
                "text": "Next pointers are complex"
              },
              {
                "id": "d",
                "text": "Linked lists can't be copied"
              }
            ],
            "correct": "b",
            "explanation": "If node 1's random points to node 5, when we're at node 1, node 5's copy doesn't exist yet.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "Using a hash map {old_node: new_node} helps because:",
            "options": [
              {
                "id": "a",
                "text": "It stores values"
              },
              {
                "id": "b",
                "text": "We can look up corresponding new node for any old node"
              },
              {
                "id": "c",
                "text": "It's faster"
              },
              {
                "id": "d",
                "text": "It's required for linked lists"
              }
            ],
            "correct": "b",
            "explanation": "When setting random, we find old_node's random in the map to get the new target.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Interleaving means placing each new node:",
            "options": [
              {
                "id": "a",
                "text": "At the end of the list"
              },
              {
                "id": "b",
                "text": "At the beginning of the list"
              },
              {
                "id": "c",
                "text": "Right after its corresponding old node"
              },
              {
                "id": "d",
                "text": "In a separate list"
              }
            ],
            "correct": "c",
            "explanation": "old1 → new1 → old2 → new2 → ... This lets us access new nodes without a map.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "With interleaving, if old.random = X, then new.random should be:",
            "options": [
              {
                "id": "a",
                "text": "X"
              },
              {
                "id": "b",
                "text": "X.next"
              },
              {
                "id": "c",
                "text": "X.prev"
              },
              {
                "id": "d",
                "text": "null"
              }
            ],
            "correct": "b",
            "explanation": "X.next is the new copy of X (due to interleaving). So old.random.next = corresponding new node.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After setting all pointers, we need to:",
            "options": [
              {
                "id": "a",
                "text": "Leave the lists interleaved"
              },
              {
                "id": "b",
                "text": "Separate the lists (restore original and extract copy)"
              },
              {
                "id": "c",
                "text": "Delete the original list"
              },
              {
                "id": "d",
                "text": "Reverse the copy"
              }
            ],
            "correct": "b",
            "explanation": "We need to return a clean copy and restore the original list to its state.",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Challenge: random points to not-yet-created nodes. Solution: create all nodes first (map them), then set pointers. Or interleave for O(1) space.",
        "pattern": "Linked List",
        "keyInsight": "Map old nodes to new nodes. When setting random pointers, look up the corresponding new node.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "copy list with random pointer",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def copyRandomList(head: Node) -> Node:\n    if not head:\n        return None\n    \n    # Map old nodes to new nodes\n    old_to_new = {}\n    \n    # First pass: create all new nodes\n    curr = head\n    while curr:\n        old_to_new[curr] = Node(curr.val)\n        curr = curr.next\n    \n    # Second pass: set next and random pointers\n    curr = head\n    while curr:\n        old_to_new[curr].next = old_to_new.get(curr.next)\n        old_to_new[curr].random = old_to_new.get(curr.random)\n        curr = curr.next\n    \n    return old_to_new[head]"
      },
      {
        "id": "07-merge-k-sorted-lists",
        "slug": "merge-k-sorted-lists",
        "title": "Merge K Sorted Lists",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "merge-k-sorted-lists"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.",
        "examples": [
          {
            "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
            "output": "[1,1,2,3,4,4,5,6]",
            "explanation": ""
          },
          {
            "input": "lists = []",
            "output": "[]",
            "explanation": ""
          },
          {
            "input": "lists = [[]]",
            "output": "[]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Merge lists one by one: merge(merge(merge(l1,l2),l3),l4)... Time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(N)"
              },
              {
                "id": "b",
                "text": "O(N log k)"
              },
              {
                "id": "c",
                "text": "O(kN)"
              },
              {
                "id": "d",
                "text": "O(N²)"
              }
            ],
            "correct": "c",
            "explanation": "First merge is 2n, second is 3n, ..., total ≈ (2+3+...+k)n = O(kN).",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "Pair up lists and merge pairs, then repeat: Time complexity?",
            "options": [
              {
                "id": "a",
                "text": "O(N)"
              },
              {
                "id": "b",
                "text": "O(N log k)"
              },
              {
                "id": "c",
                "text": "O(kN)"
              },
              {
                "id": "d",
                "text": "O(N²)"
              }
            ],
            "correct": "b",
            "explanation": "log k levels of merging, each level processes all N nodes total.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "Using a min-heap of size k helps because:",
            "options": [
              {
                "id": "a",
                "text": "We can find minimum of k elements in O(log k)"
              },
              {
                "id": "b",
                "text": "It sorts the lists"
              },
              {
                "id": "c",
                "text": "It reduces total nodes"
              },
              {
                "id": "d",
                "text": "It merges pairs"
              }
            ],
            "correct": "a",
            "explanation": "Always extract minimum head in O(log k) instead of O(k) linear scan.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "The heap should store:",
            "options": [
              {
                "id": "a",
                "text": "All nodes from all lists"
              },
              {
                "id": "b",
                "text": "Just the head of each non-empty list"
              },
              {
                "id": "c",
                "text": "Only values, not nodes"
              },
              {
                "id": "d",
                "text": "Only the smallest node"
              }
            ],
            "correct": "b",
            "explanation": "We only need to compare current candidates (heads). After picking one, add its next to the heap.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For each of N nodes in the result:",
            "options": [
              {
                "id": "a",
                "text": "One push and one pop"
              },
              {
                "id": "b",
                "text": "k pushes and k pops"
              },
              {
                "id": "c",
                "text": "log k pushes"
              },
              {
                "id": "d",
                "text": "No heap operations"
              }
            ],
            "correct": "a",
            "explanation": "Pop the minimum, push its next (if exists). Both are O(log k).",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "N nodes, each requiring O(log k) heap operations:",
            "options": [
              {
                "id": "a",
                "text": "O(N)"
              },
              {
                "id": "b",
                "text": "O(N log k)"
              },
              {
                "id": "c",
                "text": "O(kN)"
              },
              {
                "id": "d",
                "text": "O(N log N)"
              }
            ],
            "correct": "b",
            "explanation": "N × O(log k) = O(N log k).",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Min-heap of k heads: always pop smallest, push its next. O(N log k) — each node does one push and one pop.",
        "pattern": "Linked List",
        "keyInsight": "Use a min-heap to always pick the smallest among k candidates.",
        "timeComplexity": "O(N log k)",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "merge k sorted lists",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef mergeKLists(lists: List[ListNode]) -> ListNode:\n    # Min heap: (value, index, node)\n    heap = []\n    \n    # Add head of each non-empty list\n    for i, node in enumerate(lists):\n        if node:\n            heapq.heappush(heap, (node.val, i, node))\n    \n    dummy = ListNode()\n    curr = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        curr.next = node\n        curr = curr.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next"
      },
      {
        "id": "08-reverse-nodes-in-k-group",
        "slug": "reverse-nodes-in-k-group",
        "title": "Reverse Nodes in K-Group",
        "category": "linked-list",
        "difficulty": "medium",
        "tags": [
          "linked-list",
          "reverse-nodes-in-k-group"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
        "examples": [
          {
            "input": "head = [1,2,3,4,5], k = 2",
            "output": "[2,1,4,3,5]",
            "explanation": ""
          },
          {
            "input": "head = [1,2,3,4,5], k = 3",
            "output": "[3,2,1,4,5]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Before reversing a group, we must:",
            "options": [
              {
                "id": "a",
                "text": "Reverse first, check later"
              },
              {
                "id": "b",
                "text": "Check if k nodes exist"
              },
              {
                "id": "c",
                "text": "Count all nodes in list"
              },
              {
                "id": "d",
                "text": "Check if next group exists"
              }
            ],
            "correct": "b",
            "explanation": "If fewer than k nodes remain, don't reverse this group.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "To reverse k nodes, we use:",
            "options": [
              {
                "id": "a",
                "text": "Stack of size k"
              },
              {
                "id": "b",
                "text": "Standard reversal, but stop after k iterations"
              },
              {
                "id": "c",
                "text": "Recursion only"
              },
              {
                "id": "d",
                "text": "Array conversion"
              }
            ],
            "correct": "b",
            "explanation": "Same reversal logic, just limited to k steps.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "After reversing [2, 3, 4] to [4, 3, 2], we need:",
            "options": [
              {
                "id": "a",
                "text": "Connect 4 to what came before, 2 to what comes after"
              },
              {
                "id": "b",
                "text": "Only connect 4 to what came before"
              },
              {
                "id": "c",
                "text": "No connections needed"
              },
              {
                "id": "d",
                "text": "Reverse the connections"
              }
            ],
            "correct": "a",
            "explanation": "The new head (4) must link to previous group's tail. The new tail (2) must link to next group's head.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "For each group, we track:",
            "options": [
              {
                "id": "a",
                "text": "Only the group's head"
              },
              {
                "id": "b",
                "text": "Previous group's tail and current group's head/tail"
              },
              {
                "id": "c",
                "text": "All nodes in all groups"
              },
              {
                "id": "d",
                "text": "Just the first node"
              }
            ],
            "correct": "b",
            "explanation": "prev_group_end points to where new head should attach. group_start becomes the new tail after reversal.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "A dummy node before head helps:",
            "options": [
              {
                "id": "a",
                "text": "Handle first group uniformly (no special case)"
              },
              {
                "id": "b",
                "text": "Store extra data"
              },
              {
                "id": "c",
                "text": "Double the list length"
              },
              {
                "id": "d",
                "text": "Nothing"
              }
            ],
            "correct": "a",
            "explanation": "Even the first group has a \"previous\" (the dummy), simplifying connections.",
            "conceptId": "linked-list"
          },
          {
            "type": "mcq",
            "question": "We stop when:",
            "options": [
              {
                "id": "a",
                "text": "We've done one reversal"
              },
              {
                "id": "b",
                "text": "Fewer than k nodes remain"
              },
              {
                "id": "c",
                "text": "We reach the original end"
              },
              {
                "id": "d",
                "text": "k groups are done"
              }
            ],
            "correct": "b",
            "explanation": "Each iteration checks if k nodes exist. If not, stop (leave remaining as is).",
            "conceptId": "linked-list"
          }
        ],
        "oneLiner": "Process k nodes at a time: check k exist, reverse them, connect to previous tail and next head, repeat until fewer than k remain.",
        "pattern": "Linked List",
        "keyInsight": "Break the problem into: check if k nodes exist, reverse k nodes, connect groups properly.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reverse nodes in k-group",
          "linked-list"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reverseKGroup(head: ListNode, k: int) -> ListNode:\n    dummy = ListNode(0, head)\n    group_prev = dummy\n    \n    while True:\n        # Check if k nodes exist\n        kth = group_prev\n        for _ in range(k):\n            kth = kth.next\n            if not kth:\n                return dummy.next\n        \n        group_next = kth.next\n        \n        # Reverse k nodes\n        prev, curr = kth.next, group_prev.next\n        while curr != group_next:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        \n        # Connect with previous group\n        tmp = group_prev.next\n        group_prev.next = kth\n        group_prev = tmp\n    \n    return dummy.next"
      }
    ],
    "trees": [
      {
        "id": "01-invert-binary-tree",
        "slug": "invert-binary-tree",
        "title": "Invert Binary Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "invert-binary-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, invert the tree, and return its root.\n\nInverting a binary tree means swapping every left child with its corresponding right child.",
        "examples": [
          {
            "input": "root = [4,2,7,1,3,6,9]",
            "output": "[4,7,2,9,6,3,1]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For a null node, we:",
            "options": [
              {
                "id": "a",
                "text": "Swap its children"
              },
              {
                "id": "b",
                "text": "Return null"
              },
              {
                "id": "c",
                "text": "Create new children"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "b",
            "explanation": "Nothing to swap in an empty tree. Just return null.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "At each node, we swap:",
            "options": [
              {
                "id": "a",
                "text": "Node values"
              },
              {
                "id": "b",
                "text": "Left and right child pointers"
              },
              {
                "id": "c",
                "text": "Parent and child"
              },
              {
                "id": "d",
                "text": "Node addresses"
              }
            ],
            "correct": "b",
            "explanation": "Swap the subtrees, not values. Node keeps its value, but its children switch sides.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "At each node, we can:",
            "options": [
              {
                "id": "a",
                "text": "Only swap then recurse"
              },
              {
                "id": "b",
                "text": "Only recurse then swap"
              },
              {
                "id": "c",
                "text": "Either order works"
              },
              {
                "id": "d",
                "text": "Neither order works"
              }
            ],
            "correct": "c",
            "explanation": "Swap first, then invert children. Or invert children first, then swap. Both produce correct result.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "After swapping, we:",
            "options": [
              {
                "id": "a",
                "text": "Stop (done)"
              },
              {
                "id": "b",
                "text": "Invert both children recursively"
              },
              {
                "id": "c",
                "text": "Only invert one child"
              },
              {
                "id": "d",
                "text": "Go to parent"
              }
            ],
            "correct": "b",
            "explanation": "Each subtree needs to be inverted too. Recurse on both.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "After inverting, we return:",
            "options": [
              {
                "id": "a",
                "text": "null"
              },
              {
                "id": "b",
                "text": "The original root"
              },
              {
                "id": "c",
                "text": "A new node"
              },
              {
                "id": "d",
                "text": "The left child"
              }
            ],
            "correct": "b",
            "explanation": "Return the (now inverted) root so caller can connect it.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Iteratively, we can use:",
            "options": [
              {
                "id": "a",
                "text": "Just a counter"
              },
              {
                "id": "b",
                "text": "BFS or DFS with queue/stack"
              },
              {
                "id": "c",
                "text": "Sorting"
              },
              {
                "id": "d",
                "text": "Binary search"
              }
            ],
            "correct": "b",
            "explanation": "Visit each node (any order), swap its children. Queue (BFS) or stack (DFS) both work.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "At each node, swap left and right children. Recursively invert both subtrees. Return root.",
        "pattern": "Tree Traversal",
        "keyInsight": "At each node, swap its left and right children. Then recursively do the same for each child.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "triggerWords": [
          "invert binary tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def invertTree(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    \n    # Swap left and right children\n    root.left, root.right = root.right, root.left\n    \n    # Recursively invert subtrees\n    invertTree(root.left)\n    invertTree(root.right)\n    \n    return root"
      },
      {
        "id": "02-maximum-depth-of-binary-tree",
        "slug": "maximum-depth-of-binary-tree",
        "title": "Maximum Depth of Binary Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "maximum-depth-of-binary-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
        "examples": [
          {
            "input": "root = [3,9,20,null,null,15,7]",
            "output": "3",
            "explanation": ""
          },
          {
            "input": "root = [1,null,2]",
            "output": "2",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The depth of an empty tree (null) is:",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "-1"
              },
              {
                "id": "c",
                "text": "0"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "c",
            "explanation": "No nodes means depth is 0. This is the foundation for counting.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "A tree with just a root (no children) has depth:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "2"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "One node = depth 1. Base case 0 + 1 = 1.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "depth(node) = ?",
            "options": [
              {
                "id": "a",
                "text": "depth(left) + depth(right)"
              },
              {
                "id": "b",
                "text": "max(depth(left), depth(right))"
              },
              {
                "id": "c",
                "text": "1 + max(depth(left), depth(right))"
              },
              {
                "id": "d",
                "text": "min(depth(left), depth(right))"
              }
            ],
            "correct": "c",
            "explanation": "Take the deeper subtree, add 1 for current node.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "We use max because:",
            "options": [
              {
                "id": "a",
                "text": "We want total nodes"
              },
              {
                "id": "b",
                "text": "We want the longest path"
              },
              {
                "id": "c",
                "text": "Sum is always larger"
              },
              {
                "id": "d",
                "text": "Random choice"
              }
            ],
            "correct": "b",
            "explanation": "We're finding maximum depth. The longest path determines it.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "This is an example of:",
            "options": [
              {
                "id": "a",
                "text": "Pre-order traversal"
              },
              {
                "id": "b",
                "text": "In-order traversal"
              },
              {
                "id": "c",
                "text": "Post-order traversal"
              },
              {
                "id": "d",
                "text": "Level-order traversal"
              }
            ],
            "correct": "c",
            "explanation": "We process children first, then combine results at parent. That's post-order.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "For iterative solution, we can use:",
            "options": [
              {
                "id": "a",
                "text": "BFS and count levels"
              },
              {
                "id": "b",
                "text": "Sorting"
              },
              {
                "id": "c",
                "text": "Binary search"
              },
              {
                "id": "d",
                "text": "Two pointers"
              }
            ],
            "correct": "a",
            "explanation": "Each level of BFS = one depth. Count total levels.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "Depth = 1 + max(left depth, right depth). Null has depth 0.",
        "pattern": "Tree Traversal",
        "keyInsight": "Depth of a node = 1 + max(depth of left subtree, depth of right subtree)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "triggerWords": [
          "maximum depth of binary tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxDepth(root: TreeNode) -> int:\n    if not root:\n        return 0\n    \n    left_depth = maxDepth(root.left)\n    right_depth = maxDepth(root.right)\n    \n    return 1 + max(left_depth, right_depth)"
      },
      {
        "id": "03-validate-binary-search-tree",
        "slug": "validate-binary-search-tree",
        "title": "Validate Binary Search Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "validate-binary-search-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.",
        "examples": [
          {
            "input": "root = [2,1,3]",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "root = [5,1,4,null,null,3,6]",
            "output": "false",
            "explanation": "3 is in right subtree of 5 but 3 < 5."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Checking only node.left.val < node.val fails because:",
            "options": [
              {
                "id": "a",
                "text": "It doesn't check right children"
              },
              {
                "id": "b",
                "text": "It doesn't enforce ancestor constraints"
              },
              {
                "id": "c",
                "text": "It's too slow"
              },
              {
                "id": "d",
                "text": "Values can be negative"
              }
            ],
            "correct": "b",
            "explanation": "A node in the right subtree must be greater than ALL ancestors up the left path, not just its parent.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "For a node in a BST, its value must be:",
            "options": [
              {
                "id": "a",
                "text": "Any value"
              },
              {
                "id": "b",
                "text": "Within a range defined by ancestor path"
              },
              {
                "id": "c",
                "text": "Greater than parent only"
              },
              {
                "id": "d",
                "text": "Less than parent only"
              }
            ],
            "correct": "b",
            "explanation": "Going left from ancestor X means value < X. Going right from Y means value > Y. All constraints apply.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "For the root node, the valid range is:",
            "options": [
              {
                "id": "a",
                "text": "[0, 100]"
              },
              {
                "id": "b",
                "text": "[min_int, max_int] or (-infinity, +infinity)"
              },
              {
                "id": "c",
                "text": "[root.val, root.val]"
              },
              {
                "id": "d",
                "text": "No range"
              }
            ],
            "correct": "b",
            "explanation": "No ancestors means no constraints yet. Any value is valid for root.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "When moving to left child, the range update is:",
            "options": [
              {
                "id": "a",
                "text": "Set new upper bound to parent's value"
              },
              {
                "id": "b",
                "text": "Set new lower bound to parent's value"
              },
              {
                "id": "c",
                "text": "No change"
              },
              {
                "id": "d",
                "text": "Reset to initial range"
              }
            ],
            "correct": "a",
            "explanation": "Left child must be < parent. So parent's value becomes the upper limit.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "When moving to right child, the range update is:",
            "options": [
              {
                "id": "a",
                "text": "Set new upper bound to parent's value"
              },
              {
                "id": "b",
                "text": "Set new lower bound to parent's value"
              },
              {
                "id": "c",
                "text": "No change"
              },
              {
                "id": "d",
                "text": "Reset to initial range"
              }
            ],
            "correct": "b",
            "explanation": "Right child must be > parent. So parent's value becomes the lower limit.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "BST in-order traversal produces:",
            "options": [
              {
                "id": "a",
                "text": "Random order"
              },
              {
                "id": "b",
                "text": "Descending order"
              },
              {
                "id": "c",
                "text": "Ascending order"
              },
              {
                "id": "d",
                "text": "Level order"
              }
            ],
            "correct": "c",
            "explanation": "In-order visits left, root, right. In BST, this gives sorted order. If not strictly increasing, not a valid BST.",
            "conceptId": "binary-search-tree"
          }
        ],
        "oneLiner": "Pass valid range (min, max) down. Each node must be within range. Left child: upper bound = parent. Right child: lower bound = parent.",
        "pattern": "Tree Traversal",
        "keyInsight": "Each node must be within a valid range defined by its ancestors.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "triggerWords": [
          "validate binary search tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isValidBST(root: TreeNode) -> bool:\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))"
      },
      {
        "id": "04-lowest-common-ancestor",
        "slug": "lowest-common-ancestor",
        "title": "Lowest Common Ancestor of a Binary Search Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "lowest-common-ancestor-of-a-binary-search-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nThe lowest common ancestor is defined as the lowest node in the tree that has both p and q as descendants (where we allow a node to be a descendant of itself).",
        "examples": [
          {
            "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
            "output": "6",
            "explanation": "LCA of 2 and 8 is 6."
          },
          {
            "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
            "output": "2",
            "explanation": "LCA of 2 and 4 is 2 (a node can be its own ancestor)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If p.val < root.val AND q.val < root.val:",
            "options": [
              {
                "id": "a",
                "text": "Root is the LCA"
              },
              {
                "id": "b",
                "text": "LCA is in left subtree"
              },
              {
                "id": "c",
                "text": "LCA is in right subtree"
              },
              {
                "id": "d",
                "text": "No LCA exists"
              }
            ],
            "correct": "b",
            "explanation": "Both nodes are smaller than root, so both are in the left subtree. LCA must be there.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "If p.val > root.val AND q.val > root.val:",
            "options": [
              {
                "id": "a",
                "text": "Root is the LCA"
              },
              {
                "id": "b",
                "text": "LCA is in left subtree"
              },
              {
                "id": "c",
                "text": "LCA is in right subtree"
              },
              {
                "id": "d",
                "text": "No LCA exists"
              }
            ],
            "correct": "c",
            "explanation": "Both nodes are larger than root, so both are in the right subtree. LCA must be there.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "If p.val < root.val AND q.val > root.val (or vice versa):",
            "options": [
              {
                "id": "a",
                "text": "Keep searching"
              },
              {
                "id": "b",
                "text": "Root is the LCA"
              },
              {
                "id": "c",
                "text": "LCA doesn't exist"
              },
              {
                "id": "d",
                "text": "Return null"
              }
            ],
            "correct": "b",
            "explanation": "One in left subtree, one in right. Root is the deepest node containing both.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "If p.val == root.val or q.val == root.val:",
            "options": [
              {
                "id": "a",
                "text": "Keep searching"
              },
              {
                "id": "b",
                "text": "Root is the LCA"
              },
              {
                "id": "c",
                "text": "Return the other node"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "b",
            "explanation": "If one node IS the root, root is an ancestor of both (itself and the other). This is the LCA.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "In a general binary tree, we can't use this approach because:",
            "options": [
              {
                "id": "a",
                "text": "Values might repeat"
              },
              {
                "id": "b",
                "text": "We can't determine which subtree contains a value"
              },
              {
                "id": "c",
                "text": "Trees are too deep"
              },
              {
                "id": "d",
                "text": "General trees don't have LCA"
              }
            ],
            "correct": "b",
            "explanation": "BST ordering tells us exactly where each value is. General trees require checking both subtrees.",
            "conceptId": "binary-search-tree"
          },
          {
            "type": "mcq",
            "question": "The time complexity is:",
            "options": [
              {
                "id": "a",
                "text": "O(n)"
              },
              {
                "id": "b",
                "text": "O(h) where h is height"
              },
              {
                "id": "c",
                "text": "O(log n) always"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "b",
            "explanation": "We traverse one path from root to LCA. In balanced BST, h = O(log n). In worst case (skewed), h = O(n).",
            "conceptId": "binary-search-tree"
          }
        ],
        "oneLiner": "BST LCA: if both smaller go left, if both larger go right, else current is LCA (split point or match).",
        "pattern": "Tree Traversal",
        "keyInsight": "Use BST property: if both p and q are smaller, go left. If both are larger, go right. Otherwise, current node is the LCA.",
        "timeComplexity": "O(h)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "lowest common ancestor of a binary search tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    curr = root\n    \n    while curr:\n        if p.val < curr.val and q.val < curr.val:\n            curr = curr.left\n        elif p.val > curr.val and q.val > curr.val:\n            curr = curr.right\n        else:\n            return curr\n    \n    return None"
      },
      {
        "id": "05-binary-tree-level-order-traversal",
        "slug": "binary-tree-level-order-traversal",
        "title": "Binary Tree Level Order Traversal",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "binary-tree-level-order-traversal"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
        "examples": [
          {
            "input": "root = [3,9,20,null,null,15,7]",
            "output": "[[3], [9, 20], [15, 7]]",
            "explanation": ""
          },
          {
            "input": "root = [1]",
            "output": "[[1]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "BFS is preferred for level-order because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "It naturally visits nodes level by level"
              },
              {
                "id": "c",
                "text": "DFS can't traverse trees"
              },
              {
                "id": "d",
                "text": "BFS uses less memory"
              }
            ],
            "correct": "b",
            "explanation": "Queue gives FIFO order. Nodes at level k are processed before level k+1.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "BFS uses:",
            "options": [
              {
                "id": "a",
                "text": "Stack"
              },
              {
                "id": "b",
                "text": "Queue"
              },
              {
                "id": "c",
                "text": "Heap"
              },
              {
                "id": "d",
                "text": "Array"
              }
            ],
            "correct": "b",
            "explanation": "Queue ensures FIFO - first in, first out. First discovered nodes processed first.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "To know when a level ends:",
            "options": [
              {
                "id": "a",
                "text": "Track depth of each node"
              },
              {
                "id": "b",
                "text": "Count nodes at each level before processing"
              },
              {
                "id": "c",
                "text": "Use a special marker"
              },
              {
                "id": "d",
                "text": "Guess based on values"
              }
            ],
            "correct": "b",
            "explanation": "Before processing level k, queue contains exactly all level-k nodes. Count them, process exactly that many.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Within a level, nodes are processed:",
            "options": [
              {
                "id": "a",
                "text": "Right to left"
              },
              {
                "id": "b",
                "text": "Left to right"
              },
              {
                "id": "c",
                "text": "Randomly"
              },
              {
                "id": "d",
                "text": "By value"
              }
            ],
            "correct": "b",
            "explanation": "We add left child before right child. Queue preserves this order.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "When processing a node, we add its children:",
            "options": [
              {
                "id": "a",
                "text": "Before processing the node"
              },
              {
                "id": "b",
                "text": "After processing the node"
              },
              {
                "id": "c",
                "text": "Only if they have values"
              },
              {
                "id": "d",
                "text": "Never"
              }
            ],
            "correct": "b",
            "explanation": "Add children to queue AFTER visiting node. They'll be processed in the next level.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "If a level has no nodes:",
            "options": [
              {
                "id": "a",
                "text": "We add an empty list"
              },
              {
                "id": "b",
                "text": "We skip it"
              },
              {
                "id": "c",
                "text": "This means we're done"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "c",
            "explanation": "If queue is empty at start of a level, there are no more nodes. Stop.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "BFS with level tracking: before processing, count queue size = level size. Process exactly that many nodes, adding children for next level.",
        "pattern": "Tree Traversal",
        "keyInsight": "Use BFS (Breadth-First Search). Process all nodes at current level before moving to the next.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(w)",
        "triggerWords": [
          "binary tree level order traversal",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import deque\n\ndef levelOrder(root: TreeNode) -> List[List[int]]:\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result"
      },
      {
        "id": "06-binary-tree-right-side-view",
        "slug": "binary-tree-right-side-view",
        "title": "Binary Tree Right Side View",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "binary-tree-right-side-view"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given the `root` of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
        "examples": [
          {
            "input": "root = [1,2,3,null,5,null,4]",
            "output": "[1, 3, 4]",
            "explanation": ""
          },
          {
            "input": "root = [1,null,3]",
            "output": "[1, 3]",
            "explanation": ""
          },
          {
            "input": "root = []",
            "output": "[]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "From the right side, you see:",
            "options": [
              {
                "id": "a",
                "text": "The first node of each level"
              },
              {
                "id": "b",
                "text": "The last node of each level"
              },
              {
                "id": "c",
                "text": "The largest value at each level"
              },
              {
                "id": "d",
                "text": "All nodes of each level"
              }
            ],
            "correct": "b",
            "explanation": "Rightmost node blocks view of nodes to its left at the same level.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "To find the last node of each level:",
            "options": [
              {
                "id": "a",
                "text": "Pre-order (DFS)"
              },
              {
                "id": "b",
                "text": "In-order (DFS)"
              },
              {
                "id": "c",
                "text": "Level-order (BFS)"
              },
              {
                "id": "d",
                "text": "Post-order (DFS)"
              }
            ],
            "correct": "c",
            "explanation": "BFS processes levels left-to-right. Last node processed in each level is the answer.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "With DFS, we can also solve this by:",
            "options": [
              {
                "id": "a",
                "text": "Visiting right child before left"
              },
              {
                "id": "b",
                "text": "Visiting left child before right"
              },
              {
                "id": "c",
                "text": "Only visiting right children"
              },
              {
                "id": "d",
                "text": "Counting nodes"
              }
            ],
            "correct": "a",
            "explanation": "If we go right-first, the first node we see at each depth is the rightmost. Track first visit per depth.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Using BFS, we keep:",
            "options": [
              {
                "id": "a",
                "text": "All nodes"
              },
              {
                "id": "b",
                "text": "First node of each level"
              },
              {
                "id": "c",
                "text": "Last node of each level"
              },
              {
                "id": "d",
                "text": "Middle node"
              }
            ],
            "correct": "c",
            "explanation": "The last one we process before moving to next level is the rightmost.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "In right-first DFS, we add a node to result when:",
            "options": [
              {
                "id": "a",
                "text": "It's a leaf node"
              },
              {
                "id": "b",
                "text": "It's the first node we see at its depth"
              },
              {
                "id": "c",
                "text": "It has a right child"
              },
              {
                "id": "d",
                "text": "It has no left child"
              }
            ],
            "correct": "b",
            "explanation": "First node at each depth (with right-first traversal) is the rightmost. Track depths we've seen.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "The result should be ordered:",
            "options": [
              {
                "id": "a",
                "text": "By value"
              },
              {
                "id": "b",
                "text": "By depth (top to bottom)"
              },
              {
                "id": "c",
                "text": "By breadth"
              },
              {
                "id": "d",
                "text": "Randomly"
              }
            ],
            "correct": "b",
            "explanation": "\"From top to bottom\" = depth 0, 1, 2, ... which is natural BFS/DFS order.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "Right side view = last node at each level. BFS: keep last of each level. DFS: go right-first, add first node at each depth.",
        "pattern": "Tree Traversal",
        "keyInsight": "Level-order traversal, but only keep the last node of each level.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(w)",
        "triggerWords": [
          "binary tree right side view",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import deque\n\ndef rightSideView(root: TreeNode) -> List[int]:\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        \n        for i in range(level_size):\n            node = queue.popleft()\n            \n            # Last node in this level\n            if i == level_size - 1:\n                result.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    \n    return result"
      },
      {
        "id": "07-serialize-and-deserialize-binary-tree",
        "slug": "serialize-and-deserialize-binary-tree",
        "title": "Serialize and Deserialize Binary Tree",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "serialize-and-deserialize-binary-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.",
        "examples": [
          {
            "input": "root = [1,2,3,null,null,4,5]",
            "output": "[1,2,3,null,null,4,5]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Storing just values [1, 2, 3, 4, 5] fails because:",
            "options": [
              {
                "id": "a",
                "text": "It's too short"
              },
              {
                "id": "b",
                "text": "It doesn't capture tree structure"
              },
              {
                "id": "c",
                "text": "Values can be negative"
              },
              {
                "id": "d",
                "text": "We can't store numbers as strings"
              }
            ],
            "correct": "b",
            "explanation": "Same values can form different trees. We need structure info.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Including \"null\" for missing children helps because:",
            "options": [
              {
                "id": "a",
                "text": "It makes the string longer"
              },
              {
                "id": "b",
                "text": "It marks where branches end"
              },
              {
                "id": "c",
                "text": "It's required by the problem"
              },
              {
                "id": "d",
                "text": "It balances the tree"
              }
            ],
            "correct": "b",
            "explanation": "Without nulls, we can't tell where a subtree ends. Nulls are the \"stop\" signals.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "Which traversals can uniquely serialize a tree with null markers?",
            "options": [
              {
                "id": "a",
                "text": "Only pre-order"
              },
              {
                "id": "b",
                "text": "Only level-order"
              },
              {
                "id": "c",
                "text": "Pre-order or level-order (both work)"
              },
              {
                "id": "d",
                "text": "In-order"
              }
            ],
            "correct": "c",
            "explanation": "Both work with null markers. In-order doesn't work because multiple trees can have the same in-order with nulls.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "For tree [1, [2], [3, [4], [5]]], pre-order with nulls is:",
            "options": [
              {
                "id": "a",
                "text": "1, 2, 3, 4, 5"
              },
              {
                "id": "b",
                "text": "1, 2, null, null, 3, 4, null, null, 5, null, null"
              },
              {
                "id": "c",
                "text": "null, 2, null, null, 1, 3, 4, null"
              },
              {
                "id": "d",
                "text": "1, 2, 3, null, null, null, null"
              }
            ],
            "correct": "b",
            "explanation": "Visit 1, go left (2, null, null), go right (3, left (4, null, null), right (5, null, null)).",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "When deserializing pre-order, we:",
            "options": [
              {
                "id": "a",
                "text": "Use a stack"
              },
              {
                "id": "b",
                "text": "Process values in order, recursively building left then right"
              },
              {
                "id": "c",
                "text": "Build from leaves up"
              },
              {
                "id": "d",
                "text": "Need the tree first"
              }
            ],
            "correct": "b",
            "explanation": "First value is root. Then recursively build left subtree, then right subtree. Nulls signal \"no child here.\"",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "When we encounter \"null\" during deserialization:",
            "options": [
              {
                "id": "a",
                "text": "Return None and move to next value"
              },
              {
                "id": "b",
                "text": "Create a node with value 0"
              },
              {
                "id": "c",
                "text": "Stop completely"
              },
              {
                "id": "d",
                "text": "Go to parent"
              }
            ],
            "correct": "a",
            "explanation": "Null means no node here. Return None, but continue processing remaining values.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "Pre-order with null markers: serialize by visiting root, left, right with 'null' for None. Deserialize by consuming values in same order, recursively building left then right.",
        "pattern": "Tree Traversal",
        "keyInsight": "Pre-order traversal with null markers creates a unique, reconstructable representation.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "serialize and deserialize binary tree",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class Codec:\n    def serialize(self, root: TreeNode) -> str:\n        result = []\n        \n        def preorder(node):\n            if not node:\n                result.append('N')\n                return\n            result.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n        \n        preorder(root)\n        return ','.join(result)\n    \n    def deserialize(self, data: str) -> TreeNode:\n        values = iter(data.split(','))\n        \n        def build():\n            val = next(values)\n            if val == 'N':\n                return None\n            node = TreeNode(int(val))\n            node.left = build()\n            node.right = build()\n            return node\n        \n        return build()"
      },
      {
        "id": "08-binary-tree-maximum-path-sum",
        "slug": "binary-tree-maximum-path-sum",
        "title": "Binary Tree Maximum Path Sum",
        "category": "trees",
        "difficulty": "medium",
        "tags": [
          "trees",
          "binary-tree-maximum-path-sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe path sum of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return the maximum path sum of any non-empty path.",
        "examples": [
          {
            "input": "root = [1,2,3]",
            "output": "6",
            "explanation": "Path 2 -> 1 -> 3 has sum 6."
          },
          {
            "input": "root = [-10,9,20,null,null,15,7]",
            "output": "42",
            "explanation": "Path 15 -> 20 -> 7 has sum 42."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A valid path in this problem:",
            "options": [
              {
                "id": "a",
                "text": "Must start at root"
              },
              {
                "id": "b",
                "text": "Must end at a leaf"
              },
              {
                "id": "c",
                "text": "Can start and end anywhere"
              },
              {
                "id": "d",
                "text": "Must include all nodes"
              }
            ],
            "correct": "c",
            "explanation": "A path is any connected sequence. It can be entirely in a subtree.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "A path can \"turn\" at node X, meaning:",
            "options": [
              {
                "id": "a",
                "text": "It includes both left and right children of X"
              },
              {
                "id": "b",
                "text": "It skips X"
              },
              {
                "id": "c",
                "text": "It visits X twice"
              },
              {
                "id": "d",
                "text": "It goes back to parent"
              }
            ],
            "correct": "a",
            "explanation": "Path goes through left subtree, through X, and through right subtree.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "When returning a value to parent, we can include:",
            "options": [
              {
                "id": "a",
                "text": "Both children's paths"
              },
              {
                "id": "b",
                "text": "At most one child's path"
              },
              {
                "id": "c",
                "text": "No children"
              },
              {
                "id": "d",
                "text": "All descendants"
              }
            ],
            "correct": "b",
            "explanation": "A path can't branch. If we go to parent, we came from one direction only.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "At each node, we compute two things:",
            "options": [
              {
                "id": "a",
                "text": "Left sum and right sum"
              },
              {
                "id": "b",
                "text": "Turn-sum (global update) and straight-sum (return)"
              },
              {
                "id": "c",
                "text": "Min and max"
              },
              {
                "id": "d",
                "text": "Sum and count"
              }
            ],
            "correct": "b",
            "explanation": "Turn-sum includes both children (potential answer). Straight-sum is what we can extend upward.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "If a child's contribution is negative:",
            "options": [
              {
                "id": "a",
                "text": "Include it anyway"
              },
              {
                "id": "b",
                "text": "Treat it as 0 (don't include it)"
              },
              {
                "id": "c",
                "text": "Use its absolute value"
              },
              {
                "id": "d",
                "text": "Error"
              }
            ],
            "correct": "b",
            "explanation": "A negative contribution makes the path worse. Better to not include that subtree.",
            "conceptId": "tree-traversal"
          },
          {
            "type": "mcq",
            "question": "For a null node, the contribution is:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "Negative infinity"
              },
              {
                "id": "c",
                "text": "The parent's value"
              },
              {
                "id": "d",
                "text": "1"
              }
            ],
            "correct": "a",
            "explanation": "No node = no contribution. Neutral value is 0.",
            "conceptId": "tree-traversal"
          }
        ],
        "oneLiner": "At each node: turn-sum = node + left + right (update global max). Return node + max(left, right) (one direction to parent). Ignore negative contributions.",
        "pattern": "Tree Traversal",
        "keyInsight": "At each node, compute two things: (1) path sum including both children (potential answer), (2) max single-branch sum to return to parent.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)",
        "triggerWords": [
          "binary tree maximum path sum",
          "trees"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxPathSum(root: TreeNode) -> int:\n    max_sum = float('-inf')\n    \n    def dfs(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        \n        # Get max gain from children (ignore negative)\n        left_gain = max(dfs(node.left), 0)\n        right_gain = max(dfs(node.right), 0)\n        \n        # Path sum if we \"turn\" at this node\n        path_sum = node.val + left_gain + right_gain\n        max_sum = max(max_sum, path_sum)\n        \n        # Return max gain we can extend to parent\n        return node.val + max(left_gain, right_gain)\n    \n    dfs(root)\n    return max_sum"
      }
    ],
    "tries": [
      {
        "id": "01-implement-trie",
        "slug": "implement-trie",
        "title": "Implement Trie (Prefix Tree)",
        "category": "tries",
        "difficulty": "medium",
        "tags": [
          "tries",
          "implement-trie-prefix-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n- `Trie()` Initializes the trie object.\n- `void insert(String word)` Inserts the string `word` into the trie.\n- `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.\n- `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.",
        "examples": [
          {
            "input": "[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]",
            "output": "[null, null, true, false, true, null, true]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Each trie node can have up to:",
            "options": [
              {
                "id": "a",
                "text": "2 children (binary)"
              },
              {
                "id": "b",
                "text": "26 children (for lowercase letters)"
              },
              {
                "id": "c",
                "text": "1 child"
              },
              {
                "id": "d",
                "text": "Unlimited children"
              }
            ],
            "correct": "b",
            "explanation": "For lowercase English, each node can branch to any of 26 characters.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "A trie node represents:",
            "options": [
              {
                "id": "a",
                "text": "A complete word"
              },
              {
                "id": "b",
                "text": "A single character in a prefix"
              },
              {
                "id": "c",
                "text": "The frequency of a word"
              },
              {
                "id": "d",
                "text": "A sorting criterion"
              }
            ],
            "correct": "b",
            "explanation": "Path from root to node = prefix. Each node = one more character added.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "Why do we need an \"is_end\" or \"is_word\" flag?",
            "options": [
              {
                "id": "a",
                "text": "To count words"
              },
              {
                "id": "b",
                "text": "To distinguish complete words from prefixes"
              },
              {
                "id": "c",
                "text": "To save space"
              },
              {
                "id": "d",
                "text": "To sort the trie"
              }
            ],
            "correct": "b",
            "explanation": "\"app\" might be a prefix of \"apple\". We need to know if \"app\" itself was inserted as a complete word.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "To insert \"cat\", we:",
            "options": [
              {
                "id": "a",
                "text": "Create one node with value \"cat\""
              },
              {
                "id": "b",
                "text": "Create nodes for 'c', 'a', 't' along a path, mark 't' as end"
              },
              {
                "id": "c",
                "text": "Hash the word"
              },
              {
                "id": "d",
                "text": "Sort the characters"
              }
            ],
            "correct": "b",
            "explanation": "Walk/create path c->a->t, mark the final node as a word end.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "The difference between search and startsWith:",
            "options": [
              {
                "id": "a",
                "text": "No difference"
              },
              {
                "id": "b",
                "text": "search checks is_end, startsWith doesn't"
              },
              {
                "id": "c",
                "text": "startsWith is faster"
              },
              {
                "id": "d",
                "text": "search uses BFS"
              }
            ],
            "correct": "b",
            "explanation": "search needs exact match (complete word). startsWith just needs the path to exist.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "Insert and search are:",
            "options": [
              {
                "id": "a",
                "text": "O(1)"
              },
              {
                "id": "b",
                "text": "O(log n)"
              },
              {
                "id": "c",
                "text": "O(m) where m is word length"
              },
              {
                "id": "d",
                "text": "O(n) where n is number of words"
              }
            ],
            "correct": "c",
            "explanation": "We traverse one node per character. Independent of total words stored.",
            "conceptId": "trie"
          }
        ],
        "oneLiner": "Trie: tree where each path = prefix. Insert creates path and marks end. Search verifies path AND end marker. StartsWith just verifies path exists.",
        "pattern": "Trie",
        "keyInsight": "Each node represents a character. A path from root spells a prefix. Mark nodes where words end.",
        "timeComplexity": "O(m) per operation",
        "spaceComplexity": "O(total chars)",
        "triggerWords": [
          "implement trie (prefix tree)",
          "tries"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n    \n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True"
      },
      {
        "id": "02-design-add-and-search-words",
        "slug": "design-add-and-search-words",
        "title": "Design Add and Search Words Data Structure",
        "category": "tries",
        "difficulty": "medium",
        "tags": [
          "tries",
          "design-add-and-search-words-data-structure"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the `WordDictionary` class:\n- `WordDictionary()` Initializes the object.\n- `void addWord(word)` Adds `word` to the data structure, it can be matched later.\n- `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `.` where dots can be matched with any letter.",
        "examples": [
          {
            "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]",
            "output": "[null,null,null,null,false,true,true,true]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Adding a word with dots like \"a.c\":",
            "options": [
              {
                "id": "a",
                "text": "Is allowed"
              },
              {
                "id": "b",
                "text": "Is not supported in this problem"
              },
              {
                "id": "c",
                "text": "Creates special nodes"
              },
              {
                "id": "d",
                "text": "Uses regex"
              }
            ],
            "correct": "b",
            "explanation": "Only search has wildcards. Words added are normal strings.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "Searching \"bad\" (no dots):",
            "options": [
              {
                "id": "a",
                "text": "Uses standard trie search"
              },
              {
                "id": "b",
                "text": "Tries all paths"
              },
              {
                "id": "c",
                "text": "Is not allowed"
              },
              {
                "id": "d",
                "text": "Uses hashing"
              }
            ],
            "correct": "a",
            "explanation": "No wildcards = normal trie traversal.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "The dot `.` matches:",
            "options": [
              {
                "id": "a",
                "text": "Only vowels"
              },
              {
                "id": "b",
                "text": "Only the letter 'd'"
              },
              {
                "id": "c",
                "text": "Any single character"
              },
              {
                "id": "d",
                "text": "Zero or more characters"
              }
            ],
            "correct": "c",
            "explanation": "Like regex `.`, it matches exactly one character, any character.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "To search \".ad\" in a trie:",
            "options": [
              {
                "id": "a",
                "text": "Look for node named \".\""
              },
              {
                "id": "b",
                "text": "Try all children of root, continue with \"ad\""
              },
              {
                "id": "c",
                "text": "Skip to \"ad\""
              },
              {
                "id": "d",
                "text": "Return false"
              }
            ],
            "correct": "b",
            "explanation": "First character is `.`, so we try 'a', 'b', 'c', ... all 26 possibilities for first character.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "When we hit a `.`:",
            "options": [
              {
                "id": "a",
                "text": "Stop searching"
              },
              {
                "id": "b",
                "text": "Recurse on ALL children with remaining pattern"
              },
              {
                "id": "c",
                "text": "Pick a random child"
              },
              {
                "id": "d",
                "text": "Backtrack"
              }
            ],
            "correct": "b",
            "explanation": "Each child is a valid match for `.`. If any path succeeds, return true.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "Searching \"...\" (all dots) in worst case:",
            "options": [
              {
                "id": "a",
                "text": "O(m) where m is pattern length"
              },
              {
                "id": "b",
                "text": "O(26^m) - exponential"
              },
              {
                "id": "c",
                "text": "O(n) where n is total words"
              },
              {
                "id": "d",
                "text": "O(1)"
              }
            ],
            "correct": "b",
            "explanation": "Each dot branches to 26 children. m dots = 26^m paths to explore.",
            "conceptId": "trie"
          }
        ],
        "oneLiner": "Standard trie, but search uses DFS. At `.`, recurse on ALL children. At regular char, follow that path only. Return true if any path reaches is_end.",
        "pattern": "Trie",
        "keyInsight": "Standard trie insert. For search, when we hit `.`, try ALL children recursively.",
        "timeComplexity": "O(m) add, O(26^m) search worst",
        "spaceComplexity": "O(total chars)",
        "triggerWords": [
          "design add and search words data structure",
          "tries"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def addWord(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n    \n    def search(self, word: str) -> bool:\n        def dfs(index, node):\n            if index == len(word):\n                return node.is_end\n            \n            char = word[index]\n            if char == '.':\n                # Try all children\n                for child in node.children.values():\n                    if dfs(index + 1, child):\n                        return True\n                return False\n            else:\n                if char not in node.children:\n                    return False\n                return dfs(index + 1, node.children[char])\n        \n        return dfs(0, self.root)"
      },
      {
        "id": "03-word-search-ii",
        "slug": "word-search-ii",
        "title": "Word Search II",
        "category": "tries",
        "difficulty": "medium",
        "tags": [
          "tries",
          "word-search-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` board of characters and a list of strings `words`, return all words on the board.\n\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
        "examples": [
          {
            "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
            "output": "[\"eat\",\"oath\"]",
            "explanation": ""
          },
          {
            "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
            "output": "[]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Using a trie for the word list helps because:",
            "options": [
              {
                "id": "a",
                "text": "It stores words alphabetically"
              },
              {
                "id": "b",
                "text": "We can check if current path is a valid prefix in O(1)"
              },
              {
                "id": "c",
                "text": "It compresses the board"
              },
              {
                "id": "d",
                "text": "It makes DFS faster"
              }
            ],
            "correct": "b",
            "explanation": "Trie lets us know instantly if a path could lead to any word, enabling early pruning.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "We should stop exploring a grid path when:",
            "options": [
              {
                "id": "a",
                "text": "We've visited 4 cells"
              },
              {
                "id": "b",
                "text": "Current path is not a prefix of any word"
              },
              {
                "id": "c",
                "text": "We find a word"
              },
              {
                "id": "d",
                "text": "The cell is 'z'"
              }
            ],
            "correct": "b",
            "explanation": "If no word starts with this prefix, don't waste time continuing.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "When DFS reaches a complete word in trie:",
            "options": [
              {
                "id": "a",
                "text": "Stop immediately"
              },
              {
                "id": "b",
                "text": "Add to results and continue exploring"
              },
              {
                "id": "c",
                "text": "Restart from the beginning"
              },
              {
                "id": "d",
                "text": "Remove the cell from board"
              }
            ],
            "correct": "b",
            "explanation": "\"oath\" might be found, but \"oaths\" could also exist. Continue exploring after finding a word.",
            "conceptId": "trie"
          },
          {
            "type": "mcq",
            "question": "To ensure the same cell isn't used twice in a word:",
            "options": [
              {
                "id": "a",
                "text": "Remove it from board permanently"
              },
              {
                "id": "b",
                "text": "Mark it during DFS, unmark on backtrack"
              },
              {
                "id": "c",
                "text": "Keep a global visited set"
              },
              {
                "id": "d",
                "text": "Check coordinates"
              }
            ],
            "correct": "b",
            "explanation": "Temporarily mark during exploration, restore when backtracking. Standard DFS pattern.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "After finding a word, we can:",
            "options": [
              {
                "id": "a",
                "text": "Keep it in trie"
              },
              {
                "id": "b",
                "text": "Remove it from trie to avoid duplicates"
              },
              {
                "id": "c",
                "text": "Add it again"
              },
              {
                "id": "d",
                "text": "Clear the whole trie"
              }
            ],
            "correct": "b",
            "explanation": "Prevents finding the same word again. Also allows pruning empty trie branches.",
            "conceptId": "trie"
          }
        ],
        "oneLiner": "Build trie from words. DFS on grid while walking trie simultaneously. Prune when path isn't a trie prefix. Store found words, remove from trie to avoid duplicates.",
        "pattern": "Trie",
        "keyInsight": "Build a trie from words. DFS on the grid, but use trie to prune impossible paths early.",
        "timeComplexity": "O(m * n * 4^L)",
        "spaceComplexity": "O(total chars in words)",
        "triggerWords": [
          "word search ii",
          "tries"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\ndef findWords(board: List[List[str]], words: List[str]) -> List[str]:\n    # Build trie\n    root = TrieNode()\n    for word in words:\n        node = root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.word = word\n    \n    result = []\n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c, node):\n        char = board[r][c]\n        if char not in node.children:\n            return\n        \n        next_node = node.children[char]\n        \n        # Found a word\n        if next_node.word:\n            result.append(next_node.word)\n            next_node.word = None  # Avoid duplicates\n        \n        # Mark visited\n        board[r][c] = '#'\n        \n        # Explore neighbors\n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] != '#':\n                dfs(nr, nc, next_node)\n        \n        # Restore\n        board[r][c] = char\n    \n    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, root)\n    \n    return result"
      }
    ],
    "backtracking": [
      {
        "id": "01-subsets",
        "slug": "subsets",
        "title": "Subsets",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "subsets"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums` of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
            "explanation": ""
          },
          {
            "input": "nums = [0]",
            "output": "[[],[0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For n elements, the total number of subsets is:",
            "options": [
              {
                "id": "a",
                "text": "n"
              },
              {
                "id": "b",
                "text": "n!"
              },
              {
                "id": "c",
                "text": "2^n"
              },
              {
                "id": "d",
                "text": "n^2"
              }
            ],
            "correct": "c",
            "explanation": "Each element is either in or out. 2 choices x n elements = 2^n subsets.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "The empty set [] is:",
            "options": [
              {
                "id": "a",
                "text": "Not a valid subset"
              },
              {
                "id": "b",
                "text": "Always a valid subset"
              },
              {
                "id": "c",
                "text": "Only valid for empty input"
              },
              {
                "id": "d",
                "text": "The only subset"
              }
            ],
            "correct": "b",
            "explanation": "Every set has an empty subset (choosing to include nothing).",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At element nums[i], we:",
            "options": [
              {
                "id": "a",
                "text": "Must include it"
              },
              {
                "id": "b",
                "text": "Must exclude it"
              },
              {
                "id": "c",
                "text": "Either include or exclude it"
              },
              {
                "id": "d",
                "text": "Include it twice"
              }
            ],
            "correct": "c",
            "explanation": "Both choices lead to valid subsets. We explore both paths.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We add the current subset to results:",
            "options": [
              {
                "id": "a",
                "text": "Only when all elements are processed"
              },
              {
                "id": "b",
                "text": "Only when subset is non-empty"
              },
              {
                "id": "c",
                "text": "At every decision point"
              },
              {
                "id": "d",
                "text": "Never"
              }
            ],
            "correct": "c",
            "explanation": "Every state is a valid subset. We add current subset at each recursive call.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To avoid duplicate subsets like [1,2] and [2,1]:",
            "options": [
              {
                "id": "a",
                "text": "Sort the result"
              },
              {
                "id": "b",
                "text": "Always process in increasing index order"
              },
              {
                "id": "c",
                "text": "Use a hash set"
              },
              {
                "id": "d",
                "text": "Check before adding"
              }
            ],
            "correct": "b",
            "explanation": "By only considering elements at index >= current, we avoid revisiting earlier elements.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "For each element: include or skip. Process in order (start index) to avoid duplicates. Backtrack after each choice.",
        "pattern": "Backtracking",
        "keyInsight": "For each element, make a binary choice: include it or not.",
        "timeComplexity": "O(n * 2^n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "subsets",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def subsets(nums: List[int]) -> List[List[int]]:\n    result = []\n    \n    def backtrack(start, current):\n        result.append(current[:])\n        \n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    backtrack(0, [])\n    return result"
      },
      {
        "id": "02-combination-sum",
        "slug": "combination-sum",
        "title": "Combination Sum",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "combination-sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order.\n\nThe same number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.",
        "examples": [
          {
            "input": "candidates = [2,3,6,7], target = 7",
            "output": "[[2,2,3],[7]]",
            "explanation": "2+2+3 = 7, 7 = 7"
          },
          {
            "input": "candidates = [2,3,5], target = 8",
            "output": "[[2,2,2,2],[2,3,3],[3,5]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "After choosing candidates[i], the next choice can:",
            "options": [
              {
                "id": "a",
                "text": "Only be candidates[i+1] or later"
              },
              {
                "id": "b",
                "text": "Be candidates[i] again"
              },
              {
                "id": "c",
                "text": "Only be candidates[i-1]"
              },
              {
                "id": "d",
                "text": "Only be from remaining candidates"
              }
            ],
            "correct": "b",
            "explanation": "\"Unlimited times\" means we can pick the same element again.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To avoid duplicate combinations like [2,3] and [3,2]:",
            "options": [
              {
                "id": "a",
                "text": "Sort before returning"
              },
              {
                "id": "b",
                "text": "Only pick elements at index >= current"
              },
              {
                "id": "c",
                "text": "Use a hash set"
              },
              {
                "id": "d",
                "text": "Skip odd indices"
              }
            ],
            "correct": "b",
            "explanation": "By never going backward, we get only one ordering.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We stop exploring when:",
            "options": [
              {
                "id": "a",
                "text": "Current sum > target"
              },
              {
                "id": "b",
                "text": "Current sum == target"
              },
              {
                "id": "c",
                "text": "We've seen all candidates"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "Stop if exceeded (invalid), found solution, or no more candidates.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We add current combination to result when:",
            "options": [
              {
                "id": "a",
                "text": "Current sum equals target"
              },
              {
                "id": "b",
                "text": "Current sum exceeds target"
              },
              {
                "id": "c",
                "text": "We've used all candidates"
              },
              {
                "id": "d",
                "text": "Combination has exactly target elements"
              }
            ],
            "correct": "a",
            "explanation": "We want exact sum. Add only when target reached.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "If candidates are sorted and current candidate > remaining:",
            "options": [
              {
                "id": "a",
                "text": "Continue anyway"
              },
              {
                "id": "b",
                "text": "Skip this and all larger candidates"
              },
              {
                "id": "c",
                "text": "Double the candidate"
              },
              {
                "id": "d",
                "text": "Reset"
              }
            ],
            "correct": "b",
            "explanation": "If this candidate alone exceeds remaining, so will all larger ones (if sorted).",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "After finding a valid combination:",
            "options": [
              {
                "id": "a",
                "text": "Stop searching"
              },
              {
                "id": "b",
                "text": "Continue exploring other possibilities"
              },
              {
                "id": "c",
                "text": "Clear the result"
              },
              {
                "id": "d",
                "text": "Start over"
              }
            ],
            "correct": "b",
            "explanation": "We want ALL combinations, not just one.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Like subsets, but pass same index (reuse allowed). Stop when sum = target (add result) or > target (prune). Move forward only to avoid duplicates.",
        "pattern": "Backtracking",
        "keyInsight": "Like subsets, but allow reusing elements and track sum against target.",
        "timeComplexity": "O(n^(target/min))",
        "spaceComplexity": "O(target/min)",
        "triggerWords": [
          "combination sum",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def combinationSum(candidates: List[int], target: int) -> List[List[int]]:\n    result = []\n    \n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        if remaining < 0:\n            return\n        \n        for i in range(start, len(candidates)):\n            current.append(candidates[i])\n            backtrack(i, current, remaining - candidates[i])\n            current.pop()\n    \n    backtrack(0, [], target)\n    return result"
      },
      {
        "id": "03-permutations",
        "slug": "permutations",
        "title": "Permutations",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "permutations"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
            "explanation": ""
          },
          {
            "input": "nums = [0,1]",
            "output": "[[0,1],[1,0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For n distinct elements, total permutations:",
            "options": [
              {
                "id": "a",
                "text": "2^n"
              },
              {
                "id": "b",
                "text": "n!"
              },
              {
                "id": "c",
                "text": "n^n"
              },
              {
                "id": "d",
                "text": "n^2"
              }
            ],
            "correct": "b",
            "explanation": "n choices for first, n-1 for second, ... = n!",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "In a permutation, each element:",
            "options": [
              {
                "id": "a",
                "text": "Can appear multiple times"
              },
              {
                "id": "b",
                "text": "Must appear exactly once"
              },
              {
                "id": "c",
                "text": "Can be skipped"
              },
              {
                "id": "d",
                "text": "Appears in fixed position"
              }
            ],
            "correct": "b",
            "explanation": "Permutation = rearrangement of ALL elements.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To ensure each element appears once, we:",
            "options": [
              {
                "id": "a",
                "text": "Remove elements from array"
              },
              {
                "id": "b",
                "text": "Track used indices/elements"
              },
              {
                "id": "c",
                "text": "Sort the array"
              },
              {
                "id": "d",
                "text": "Use fixed order"
              }
            ],
            "correct": "b",
            "explanation": "Know what's available vs. already placed.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We add current permutation when:",
            "options": [
              {
                "id": "a",
                "text": "It has length n"
              },
              {
                "id": "b",
                "text": "It has length 1"
              },
              {
                "id": "c",
                "text": "Any length is valid"
              },
              {
                "id": "d",
                "text": "All elements are used (same as A)"
              }
            ],
            "correct": "a",
            "explanation": "Permutation must include all n elements.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At each recursion level, we consider:",
            "options": [
              {
                "id": "a",
                "text": "Only elements after current index"
              },
              {
                "id": "b",
                "text": "All unused elements"
              },
              {
                "id": "c",
                "text": "Only adjacent elements"
              },
              {
                "id": "d",
                "text": "Random elements"
              }
            ],
            "correct": "b",
            "explanation": "Unlike subsets/combinations, order matters. Any unused element can go in current position.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "At each position, try all unused elements. Add to result when length = n. Unlike subsets, consider ALL unused elements at each level.",
        "pattern": "Backtracking",
        "keyInsight": "At each position, choose from remaining unused elements. Track what's been used.",
        "timeComplexity": "O(n * n!)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "permutations",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def permute(nums: List[int]) -> List[List[int]]:\n    result = []\n    \n    def backtrack(current, used):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        \n        for i in range(len(nums)):\n            if i in used:\n                continue\n            current.append(nums[i])\n            used.add(i)\n            backtrack(current, used)\n            current.pop()\n            used.remove(i)\n    \n    backtrack([], set())\n    return result"
      },
      {
        "id": "04-subsets-ii",
        "slug": "subsets-ii",
        "title": "Subsets II",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "subsets-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums` that may contain duplicates, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
        "examples": [
          {
            "input": "nums = [1,2,2]",
            "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
            "explanation": ""
          },
          {
            "input": "nums = [0]",
            "output": "[[],[0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Sorting the array helps because:",
            "options": [
              {
                "id": "a",
                "text": "It makes the output look nice"
              },
              {
                "id": "b",
                "text": "Duplicates become adjacent, easy to detect"
              },
              {
                "id": "c",
                "text": "It's faster"
              },
              {
                "id": "d",
                "text": "Required by the algorithm"
              }
            ],
            "correct": "b",
            "explanation": "After sorting, all 2s are together. We can skip consecutive same values.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We skip nums[i] if:",
            "options": [
              {
                "id": "a",
                "text": "It's the first element"
              },
              {
                "id": "b",
                "text": "nums[i] == nums[i-1] and i > start"
              },
              {
                "id": "c",
                "text": "It's negative"
              },
              {
                "id": "d",
                "text": "We've seen it before anywhere"
              }
            ],
            "correct": "b",
            "explanation": "If the previous element at THIS LEVEL was the same, we've already explored that branch.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "\"Same level\" means:",
            "options": [
              {
                "id": "a",
                "text": "Same depth in recursion"
              },
              {
                "id": "b",
                "text": "Same iteration of the for loop at current recursion"
              },
              {
                "id": "c",
                "text": "Same value"
              },
              {
                "id": "d",
                "text": "Same index"
              }
            ],
            "correct": "b",
            "explanation": "Within one call to backtrack, we loop through choices. Same-level duplicates happen in THIS loop.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "The condition i > start (not i > 0) is important because:",
            "options": [
              {
                "id": "a",
                "text": "We want to allow first element"
              },
              {
                "id": "b",
                "text": "start marks where valid choices begin for this level"
              },
              {
                "id": "c",
                "text": "It prevents index errors"
              },
              {
                "id": "d",
                "text": "0 is special"
              }
            ],
            "correct": "b",
            "explanation": "At recursion level with start=2, checking i>0 would wrongly skip element at i=2 if it matches i=1.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At the first level (start=0), for [1,2,2]:",
            "options": [
              {
                "id": "a",
                "text": "We try 1, 2, 2 (all three)"
              },
              {
                "id": "b",
                "text": "We try 1, then only the first 2"
              },
              {
                "id": "c",
                "text": "We skip all 2s"
              },
              {
                "id": "d",
                "text": "We only try 2"
              }
            ],
            "correct": "b",
            "explanation": "First 2 at index 1 is tried. Second 2 at index 2 is skipped (same as previous at same level).",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "After choosing first 2 (at index 1), from [1,2,2]:",
            "options": [
              {
                "id": "a",
                "text": "We can still choose the second 2"
              },
              {
                "id": "b",
                "text": "We must skip the second 2"
              },
              {
                "id": "c",
                "text": "We restart from 1"
              },
              {
                "id": "d",
                "text": "We stop"
              }
            ],
            "correct": "a",
            "explanation": "We moved to a new level (start=2). At THIS level, index 2 is the first choice, so not skipped.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Sort first. In backtrack loop, skip if nums[i] == nums[i-1] AND i > start. This avoids exploring duplicate branches at the same decision level.",
        "pattern": "Backtracking",
        "keyInsight": "Sort the array. Skip duplicates at the same decision level.",
        "timeComplexity": "O(n * 2^n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "subsets ii",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def subsetsWithDup(nums: List[int]) -> List[List[int]]:\n    nums.sort()\n    result = []\n    \n    def backtrack(start, current):\n        result.append(current[:])\n        \n        for i in range(start, len(nums)):\n            # Skip duplicates at same level\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    backtrack(0, [])\n    return result"
      },
      {
        "id": "05-combination-sum-ii",
        "slug": "combination-sum-ii",
        "title": "Combination Sum II",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "combination-sum-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.\n\nEach number in `candidates` may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.",
        "examples": [
          {
            "input": "candidates = [10,1,2,7,6,1,5], target = 8",
            "output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
            "explanation": ""
          },
          {
            "input": "candidates = [2,5,2,1,2], target = 5",
            "output": "[[1,2,2],[5]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "After choosing candidates[i], the next recursive call starts at:",
            "options": [
              {
                "id": "a",
                "text": "i (can reuse)"
              },
              {
                "id": "b",
                "text": "i + 1 (move forward)"
              },
              {
                "id": "c",
                "text": "0 (start over)"
              },
              {
                "id": "d",
                "text": "i - 1"
              }
            ],
            "correct": "b",
            "explanation": "Unlike Combination Sum I, each element can only be used once.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "For candidates = [1,1,2], to avoid duplicate [1,2]:",
            "options": [
              {
                "id": "a",
                "text": "Remove duplicates from input"
              },
              {
                "id": "b",
                "text": "Sort and skip same value at same level"
              },
              {
                "id": "c",
                "text": "Use a set"
              },
              {
                "id": "d",
                "text": "Ignore"
              }
            ],
            "correct": "b",
            "explanation": "Same pattern as Subsets II. Sort, then skip if nums[i] == nums[i-1] at same level.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We stop exploring when:",
            "options": [
              {
                "id": "a",
                "text": "Sum exceeds target"
              },
              {
                "id": "b",
                "text": "Sum equals target (after adding to result)"
              },
              {
                "id": "c",
                "text": "No more candidates (index out of bounds)"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "All are valid stopping conditions.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We skip candidates[i] if:",
            "options": [
              {
                "id": "a",
                "text": "candidates[i] > remaining target"
              },
              {
                "id": "b",
                "text": "i > start and candidates[i] == candidates[i-1]"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "We've already found a solution"
              }
            ],
            "correct": "c",
            "explanation": "Skip if too large (pruning) or duplicate at same level (dedup).",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "Sorting helps with:",
            "options": [
              {
                "id": "a",
                "text": "Early termination (larger elements after smaller)"
              },
              {
                "id": "b",
                "text": "Duplicate detection (same values adjacent)"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Sorting enables both optimizations.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "The key differences from Combination Sum I are:",
            "options": [
              {
                "id": "a",
                "text": "Use i+1 instead of i"
              },
              {
                "id": "b",
                "text": "Add duplicate skipping logic"
              },
              {
                "id": "c",
                "text": "Both A and B"
              },
              {
                "id": "d",
                "text": "Use a different data structure"
              }
            ],
            "correct": "c",
            "explanation": "Two changes: no reuse (i+1), and deduplication.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Combination Sum + Subsets II: move to i+1 (no reuse), skip if same as previous at same level (dedup), break if exceeds target (prune).",
        "pattern": "Backtracking",
        "keyInsight": "Combine Combination Sum's target tracking with Subsets II's duplicate skipping.",
        "timeComplexity": "O(2^n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "combination sum ii",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def combinationSum2(candidates: List[int], target: int) -> List[List[int]]:\n    candidates.sort()\n    result = []\n    \n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if candidates[i] > remaining:\n                break\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            current.append(candidates[i])\n            backtrack(i + 1, current, remaining - candidates[i])\n            current.pop()\n    \n    backtrack(0, [], target)\n    return result"
      },
      {
        "id": "06-word-search",
        "slug": "word-search",
        "title": "Word Search",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "word-search"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
        "examples": [
          {
            "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We start DFS from:",
            "options": [
              {
                "id": "a",
                "text": "Only (0,0)"
              },
              {
                "id": "b",
                "text": "Any cell matching word[0]"
              },
              {
                "id": "c",
                "text": "All cells"
              },
              {
                "id": "d",
                "text": "Random cells"
              }
            ],
            "correct": "b",
            "explanation": "Word could start anywhere. But only cells matching first character are valid starts.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "From each cell, we can move to:",
            "options": [
              {
                "id": "a",
                "text": "Only right and down"
              },
              {
                "id": "b",
                "text": "Only diagonal cells"
              },
              {
                "id": "c",
                "text": "All 4 adjacent cells (up, down, left, right)"
              },
              {
                "id": "d",
                "text": "8 surrounding cells"
              }
            ],
            "correct": "c",
            "explanation": "\"Adjacent\" = horizontal or vertical neighbors.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To prevent using the same cell twice:",
            "options": [
              {
                "id": "a",
                "text": "Delete the cell"
              },
              {
                "id": "b",
                "text": "Mark it temporarily during DFS"
              },
              {
                "id": "c",
                "text": "Use a global visited set"
              },
              {
                "id": "d",
                "text": "Check coordinates only"
              }
            ],
            "correct": "b",
            "explanation": "Mark during exploration, unmark during backtrack. Each path has its own visited state.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "At cell (r,c) with word index i, we proceed if:",
            "options": [
              {
                "id": "a",
                "text": "board[r][c] == word[i]"
              },
              {
                "id": "b",
                "text": "board[r][c] == word[0]"
              },
              {
                "id": "c",
                "text": "Cell is not visited"
              },
              {
                "id": "d",
                "text": "Both A and C"
              }
            ],
            "correct": "d",
            "explanation": "Cell must match current character AND not be already used in this path.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We return True when:",
            "options": [
              {
                "id": "a",
                "text": "We've visited all cells"
              },
              {
                "id": "b",
                "text": "We've matched all characters of word"
              },
              {
                "id": "c",
                "text": "We reach the bottom-right corner"
              },
              {
                "id": "d",
                "text": "We find any path"
              }
            ],
            "correct": "b",
            "explanation": "index == len(word) means we've matched every character.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "When a path fails (no valid continuation):",
            "options": [
              {
                "id": "a",
                "text": "Return False and let parent try another direction"
              },
              {
                "id": "b",
                "text": "Start over from beginning"
              },
              {
                "id": "c",
                "text": "Give up entirely"
              },
              {
                "id": "d",
                "text": "Skip to next cell"
              }
            ],
            "correct": "a",
            "explanation": "Backtrack to previous cell, try other directions. Classic DFS.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "DFS from each cell matching word[0]. At each step: check bounds, check match, mark visited, explore 4 directions, unmark (backtrack). Return True if all matched.",
        "pattern": "Backtracking",
        "keyInsight": "DFS from each cell that matches first letter. Mark visited cells to avoid reuse. Backtrack on failure.",
        "timeComplexity": "O(m * n * 4^L)",
        "spaceComplexity": "O(L)",
        "triggerWords": [
          "word search",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def exist(board: List[List[str]], word: str) -> bool:\n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c, index):\n        if index == len(word):\n            return True\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return False\n        if board[r][c] != word[index]:\n            return False\n        \n        # Mark visited\n        temp = board[r][c]\n        board[r][c] = '#'\n        \n        # Explore 4 directions\n        found = (dfs(r+1, c, index+1) or dfs(r-1, c, index+1) or\n                 dfs(r, c+1, index+1) or dfs(r, c-1, index+1))\n        \n        # Backtrack\n        board[r][c] = temp\n        return found\n    \n    for r in range(rows):\n        for c in range(cols):\n            if dfs(r, c, 0):\n                return True\n    return False"
      },
      {
        "id": "07-palindrome-partitioning",
        "slug": "palindrome-partitioning",
        "title": "Palindrome Partitioning",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "palindrome-partitioning"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of `s`.",
        "examples": [
          {
            "input": "s = \"aab\"",
            "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
            "explanation": ""
          },
          {
            "input": "s = \"a\"",
            "output": "[[\"a\"]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At position i, we choose:",
            "options": [
              {
                "id": "a",
                "text": "Whether to include character i"
              },
              {
                "id": "b",
                "text": "How far to extend the current palindrome"
              },
              {
                "id": "c",
                "text": "Which character to use"
              },
              {
                "id": "d",
                "text": "Whether to skip characters"
              }
            ],
            "correct": "b",
            "explanation": "We try all possible ending positions j where s[i:j] is a palindrome.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We add current partition to result when:",
            "options": [
              {
                "id": "a",
                "text": "We have n pieces"
              },
              {
                "id": "b",
                "text": "Current piece is a palindrome"
              },
              {
                "id": "c",
                "text": "We've processed the entire string"
              },
              {
                "id": "d",
                "text": "We found \"aa\""
              }
            ],
            "correct": "c",
            "explanation": "When start index reaches end of string, we've successfully partitioned everything.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We can extend from position i to j if:",
            "options": [
              {
                "id": "a",
                "text": "j > i"
              },
              {
                "id": "b",
                "text": "s[i:j+1] is a palindrome"
              },
              {
                "id": "c",
                "text": "s[i:j+1] has all same characters"
              },
              {
                "id": "d",
                "text": "j == len(s) - 1"
              }
            ],
            "correct": "b",
            "explanation": "Each piece must be a palindrome. We only proceed if the piece from i to j is valid.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "After choosing s[i:j] as a piece, we:",
            "options": [
              {
                "id": "a",
                "text": "Move to position j and continue"
              },
              {
                "id": "b",
                "text": "Start over from 0"
              },
              {
                "id": "c",
                "text": "Skip j characters"
              },
              {
                "id": "d",
                "text": "End the partition"
              }
            ],
            "correct": "a",
            "explanation": "We've used characters 0 to j-1. Now partition the rest starting at j.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To check if s[i:j] is a palindrome:",
            "options": [
              {
                "id": "a",
                "text": "Compare with reverse"
              },
              {
                "id": "b",
                "text": "Check if all characters are same"
              },
              {
                "id": "c",
                "text": "Check length"
              },
              {
                "id": "d",
                "text": "Use hash"
              }
            ],
            "correct": "a",
            "explanation": "A palindrome reads same forwards and backwards.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "For string \"aaa\", the number of valid partitions is:",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "3"
              },
              {
                "id": "c",
                "text": "4"
              },
              {
                "id": "d",
                "text": "8"
              }
            ],
            "correct": "c",
            "explanation": "[\"a\",\"a\",\"a\"], [\"a\",\"aa\"], [\"aa\",\"a\"], [\"aaa\"]. 4 ways.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "At each position, try all possible lengths. If s[i:j] is palindrome, take it and partition s[j:]. Add to result when string fully consumed.",
        "pattern": "Backtracking",
        "keyInsight": "At each position, try all possible palindrome prefixes. Then recursively partition the rest.",
        "timeComplexity": "O(n * 2^n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "palindrome partitioning",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def partition(s: str) -> List[List[str]]:\n    result = []\n    \n    def is_palindrome(sub):\n        return sub == sub[::-1]\n    \n    def backtrack(start, current):\n        if start == len(s):\n            result.append(current[:])\n            return\n        \n        for end in range(start + 1, len(s) + 1):\n            substring = s[start:end]\n            if is_palindrome(substring):\n                current.append(substring)\n                backtrack(end, current)\n                current.pop()\n    \n    backtrack(0, [])\n    return result"
      },
      {
        "id": "08-n-queens",
        "slug": "n-queens",
        "title": "N-Queens",
        "category": "backtracking",
        "difficulty": "hard",
        "tags": [
          "backtracking",
          "n-queens"
        ],
        "estimatedTime": 5,
        "problemStatement": "The n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.",
        "examples": [
          {
            "input": "n = 4",
            "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
            "explanation": ""
          },
          {
            "input": "n = 1",
            "output": "[[\"Q\"]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A queen can attack another queen if they share:",
            "options": [
              {
                "id": "a",
                "text": "Same row"
              },
              {
                "id": "b",
                "text": "Same column"
              },
              {
                "id": "c",
                "text": "Same diagonal"
              },
              {
                "id": "d",
                "text": "Any of the above"
              }
            ],
            "correct": "d",
            "explanation": "Queens attack horizontally, vertically, and diagonally.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "Since each queen attacks its entire row, each row can have:",
            "options": [
              {
                "id": "a",
                "text": "0 queens"
              },
              {
                "id": "b",
                "text": "Exactly 1 queen"
              },
              {
                "id": "c",
                "text": "2 queens"
              },
              {
                "id": "d",
                "text": "Any number"
              }
            ],
            "correct": "b",
            "explanation": "More than one queen in a row = they attack each other. We need exactly n queens in n rows.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "To ensure no two queens share a column:",
            "options": [
              {
                "id": "a",
                "text": "Sort the queens"
              },
              {
                "id": "b",
                "text": "Track which columns are used"
              },
              {
                "id": "c",
                "text": "Check board after placing all"
              },
              {
                "id": "d",
                "text": "Use diagonals"
              }
            ],
            "correct": "b",
            "explanation": "Keep a set of occupied columns. Skip columns already used.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "Cells on the same diagonal share:",
            "options": [
              {
                "id": "a",
                "text": "Same row - column value (for one diagonal direction)"
              },
              {
                "id": "b",
                "text": "Same row + column value (for other diagonal)"
              },
              {
                "id": "c",
                "text": "Both A and B identify the two diagonal directions"
              },
              {
                "id": "d",
                "text": "Nothing in common"
              }
            ],
            "correct": "c",
            "explanation": "(r-c) is constant on one diagonal, (r+c) on the other.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We backtrack when:",
            "options": [
              {
                "id": "a",
                "text": "No column in current row is safe"
              },
              {
                "id": "b",
                "text": "We've placed one queen"
              },
              {
                "id": "c",
                "text": "Row index exceeds n"
              },
              {
                "id": "d",
                "text": "All columns tried in first row"
              }
            ],
            "correct": "a",
            "explanation": "If no valid placement in current row, previous choices were wrong. Undo and try different.",
            "conceptId": "backtracking"
          },
          {
            "type": "mcq",
            "question": "We found a valid solution when:",
            "options": [
              {
                "id": "a",
                "text": "All columns are used"
              },
              {
                "id": "b",
                "text": "All n rows have a queen"
              },
              {
                "id": "c",
                "text": "Board looks symmetric"
              },
              {
                "id": "d",
                "text": "No queens attack"
              }
            ],
            "correct": "b",
            "explanation": "If we successfully place a queen in each of n rows, we have a valid configuration.",
            "conceptId": "backtracking"
          }
        ],
        "oneLiner": "Row by row: for each column, check if column, (row-col), and (row+col) are free. Place queen, recurse, backtrack. Found when row == n.",
        "pattern": "Backtracking",
        "keyInsight": "Place one queen per row. Track which columns and diagonals are occupied.",
        "timeComplexity": "O(n!)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "n-queens",
          "backtracking"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def solveNQueens(n: int) -> List[List[str]]:\n    result = []\n    cols = set()\n    pos_diag = set()  # r + c\n    neg_diag = set()  # r - c\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    \n    def backtrack(row):\n        if row == n:\n            result.append([''.join(r) for r in board])\n            return\n        \n        for col in range(n):\n            if col in cols or (row + col) in pos_diag or (row - col) in neg_diag:\n                continue\n            \n            cols.add(col)\n            pos_diag.add(row + col)\n            neg_diag.add(row - col)\n            board[row][col] = 'Q'\n            \n            backtrack(row + 1)\n            \n            cols.remove(col)\n            pos_diag.remove(row + col)\n            neg_diag.remove(row - col)\n            board[row][col] = '.'\n    \n    backtrack(0)\n    return result"
      }
    ],
    "heap": [
      {
        "id": "01-kth-largest-element-in-stream",
        "slug": "kth-largest-element-in-stream",
        "title": "Kth Largest Element in a Stream",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "kth-largest-element-in-a-stream"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a class to find the `k`th largest element in a stream. Note that it is the `k`th largest element in the sorted order, not the `k`th distinct element.\n\nImplement `KthLargest` class:\n- `KthLargest(int k, int[] nums)` Initializes the object with the integer `k` and the stream of integers `nums`.\n- `int add(int val)` Appends the integer `val` to the stream and returns the element representing the `k`th largest element in the stream.",
        "examples": [
          {
            "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]",
            "output": "[null, 4, 5, 5, 8, 8]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For kth largest, we use min-heap because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "Root gives us the smallest of the k largest = kth largest"
              },
              {
                "id": "c",
                "text": "We want minimum element"
              },
              {
                "id": "d",
                "text": "Heaps only come in min form"
              }
            ],
            "correct": "b",
            "explanation": "With k elements in min-heap, root is smallest = kth largest overall.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "We maintain heap of size:",
            "options": [
              {
                "id": "a",
                "text": "n (all elements)"
              },
              {
                "id": "b",
                "text": "k"
              },
              {
                "id": "c",
                "text": "n - k"
              },
              {
                "id": "d",
                "text": "1"
              }
            ],
            "correct": "b",
            "explanation": "Only keep the k largest. Anything smaller isn't relevant.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If new element > heap root and heap has k elements:",
            "options": [
              {
                "id": "a",
                "text": "Ignore new element"
              },
              {
                "id": "b",
                "text": "Pop root, push new element"
              },
              {
                "id": "c",
                "text": "Push without popping"
              },
              {
                "id": "d",
                "text": "Clear heap"
              }
            ],
            "correct": "b",
            "explanation": "New element should be in top k. Old minimum is no longer in top k.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If new element < heap root and heap has k elements:",
            "options": [
              {
                "id": "a",
                "text": "Pop root, push new element"
              },
              {
                "id": "b",
                "text": "Ignore new element"
              },
              {
                "id": "c",
                "text": "Replace all elements"
              },
              {
                "id": "d",
                "text": "Push anyway"
              }
            ],
            "correct": "b",
            "explanation": "New element isn't in top k. Don't add it.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If nums has fewer than k elements initially:",
            "options": [
              {
                "id": "a",
                "text": "Error"
              },
              {
                "id": "b",
                "text": "Push all, wait for more elements"
              },
              {
                "id": "c",
                "text": "Fill with zeros"
              },
              {
                "id": "d",
                "text": "Return -1"
              }
            ],
            "correct": "b",
            "explanation": "Start with what we have. Add more as they come.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "The kth largest is:",
            "options": [
              {
                "id": "a",
                "text": "Heap root"
              },
              {
                "id": "b",
                "text": "Sum of heap"
              },
              {
                "id": "c",
                "text": "Largest in heap"
              },
              {
                "id": "d",
                "text": "Random element"
              }
            ],
            "correct": "a",
            "explanation": "Min-heap root = smallest in heap = kth largest overall.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Min-heap of size k: if new element > root, replace root. Root always gives kth largest.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Use a min-heap of size k. The root is always the kth largest.",
        "timeComplexity": "O(log k) per add",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "kth largest element in a stream",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\nclass KthLargest:\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.heap = nums\n        heapq.heapify(self.heap)\n        \n        while len(self.heap) > k:\n            heapq.heappop(self.heap)\n    \n    def add(self, val: int) -> int:\n        heapq.heappush(self.heap, val)\n        \n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n        \n        return self.heap[0]"
      },
      {
        "id": "02-last-stone-weight",
        "slug": "last-stone-weight",
        "title": "Last Stone Weight",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "last-stone-weight"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of integers `stones` where `stones[i]` is the weight of the `i`th stone.\n\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n- If `x == y`, both stones are destroyed.\n- If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is at most one stone left.\n\nReturn the weight of the last remaining stone. If there are no stones left, return `0`.",
        "examples": [
          {
            "input": "stones = [2,7,4,1,8,1]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We use a heap because:",
            "options": [
              {
                "id": "a",
                "text": "We need sorted order"
              },
              {
                "id": "b",
                "text": "We need quick access to maximum elements"
              },
              {
                "id": "c",
                "text": "Heaps are faster than arrays"
              },
              {
                "id": "d",
                "text": "Problem says to use heap"
              }
            ],
            "correct": "b",
            "explanation": "Extracting two max elements repeatedly = heap's strength.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "We need:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap (default in Python)"
              },
              {
                "id": "b",
                "text": "Max-heap"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "b",
            "explanation": "We want the two heaviest. Max-heap gives max at root.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Python's heapq is a min-heap. To simulate max-heap:",
            "options": [
              {
                "id": "a",
                "text": "Use a different library"
              },
              {
                "id": "b",
                "text": "Negate all values"
              },
              {
                "id": "c",
                "text": "Sort the list"
              },
              {
                "id": "d",
                "text": "Reverse the heap"
              }
            ],
            "correct": "b",
            "explanation": "Negating turns max into min. pop gives -max = actual max.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "After smashing stones x and y (x <= y):",
            "options": [
              {
                "id": "a",
                "text": "Always push y-x"
              },
              {
                "id": "b",
                "text": "Push y-x only if y-x > 0"
              },
              {
                "id": "c",
                "text": "Push x-y"
              },
              {
                "id": "d",
                "text": "Push both"
              }
            ],
            "correct": "b",
            "explanation": "If y == x, both destroyed (nothing to push). Otherwise push remainder.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "We stop when:",
            "options": [
              {
                "id": "a",
                "text": "Heap is empty"
              },
              {
                "id": "b",
                "text": "Heap has 1 element"
              },
              {
                "id": "c",
                "text": "Heap has <= 1 element"
              },
              {
                "id": "d",
                "text": "After 10 iterations"
              }
            ],
            "correct": "c",
            "explanation": "With 0 stones, answer is 0. With 1 stone, answer is its weight.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Final answer is:",
            "options": [
              {
                "id": "a",
                "text": "Heap root if heap has 1 element, else 0"
              },
              {
                "id": "b",
                "text": "Always 0"
              },
              {
                "id": "c",
                "text": "Sum of remaining"
              },
              {
                "id": "d",
                "text": "Last extracted value"
              }
            ],
            "correct": "a",
            "explanation": "Either one stone left or no stones left.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Max-heap for 'heaviest two' access. Pop two, push difference if nonzero. Return last remaining or 0.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Max-heap gives O(log n) access to largest elements.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "last stone weight",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef lastStoneWeight(stones: List[int]) -> int:\n    # Use negative values for max-heap\n    heap = [-s for s in stones]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        y = -heapq.heappop(heap)  # Largest\n        x = -heapq.heappop(heap)  # Second largest\n        \n        if y != x:\n            heapq.heappush(heap, -(y - x))\n    \n    return -heap[0] if heap else 0"
      },
      {
        "id": "03-k-closest-points-to-origin",
        "slug": "k-closest-points-to-origin",
        "title": "K Closest Points to Origin",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "k-closest-points-to-origin"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.\n\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., `sqrt((x1 - x2)^2 + (y1 - y2)^2)`).\n\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).",
        "examples": [
          {
            "input": "points = [[1,3],[-2,2]], k = 1",
            "output": "[[-2,2]]",
            "explanation": "Distance of (1,3) = sqrt(10), (-2,2) = sqrt(8). Closest is (-2,2)."
          },
          {
            "input": "points = [[3,3],[5,-1],[-2,4]], k = 2",
            "output": "[[3,3],[-2,4]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To compare distances without computing sqrt, we can use:",
            "options": [
              {
                "id": "a",
                "text": "sqrt(x^2 + y^2) exactly"
              },
              {
                "id": "b",
                "text": "x^2 + y^2 (squared distance)"
              },
              {
                "id": "c",
                "text": "|x| + |y|"
              },
              {
                "id": "d",
                "text": "max(|x|, |y|)"
              }
            ],
            "correct": "b",
            "explanation": "sqrt is monotonic. Comparing squared distances gives same ordering, avoids floating point.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For k closest, we use:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap of all points"
              },
              {
                "id": "b",
                "text": "Max-heap of size k"
              },
              {
                "id": "c",
                "text": "Min-heap of size k"
              },
              {
                "id": "d",
                "text": "Max-heap of all points"
              }
            ],
            "correct": "b",
            "explanation": "We want the k smallest. Max-heap lets us kick out the largest among our k candidates.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "The heap should store:",
            "options": [
              {
                "id": "a",
                "text": "Just distances"
              },
              {
                "id": "b",
                "text": "Just points"
              },
              {
                "id": "c",
                "text": "(distance, point) pairs"
              },
              {
                "id": "d",
                "text": "Point indices"
              }
            ],
            "correct": "c",
            "explanation": "Need distance for comparison, need point for final answer.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If new point is closer than heap root (and heap full):",
            "options": [
              {
                "id": "a",
                "text": "Ignore new point"
              },
              {
                "id": "b",
                "text": "Pop root (farthest), push new point"
              },
              {
                "id": "c",
                "text": "Push without popping"
              },
              {
                "id": "d",
                "text": "Clear and restart"
              }
            ],
            "correct": "b",
            "explanation": "New point deserves to be in top k. Current farthest doesn't.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "After processing all points, the answer is:",
            "options": [
              {
                "id": "a",
                "text": "Just the heap root"
              },
              {
                "id": "b",
                "text": "All points in the heap"
              },
              {
                "id": "c",
                "text": "Points not in the heap"
              },
              {
                "id": "d",
                "text": "The last k points added"
              }
            ],
            "correct": "b",
            "explanation": "Heap contains exactly the k closest points.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Another valid O(n) average approach is:",
            "options": [
              {
                "id": "a",
                "text": "Sorting"
              },
              {
                "id": "b",
                "text": "Quickselect"
              },
              {
                "id": "c",
                "text": "Binary search"
              },
              {
                "id": "d",
                "text": "Two pointers"
              }
            ],
            "correct": "b",
            "explanation": "Quickselect finds k smallest in O(n) average. Heap is O(n log k).",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Max-heap of size k for 'k smallest': root is farthest among candidates. If new point closer than root, swap. Final heap = k closest.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Use max-heap of size k. Keep only the k smallest distances.",
        "timeComplexity": "O(n log k)",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "k closest points to origin",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef kClosest(points: List[List[int]], k: int) -> List[List[int]]:\n    # Max-heap of size k (negate distances)\n    heap = []\n    \n    for x, y in points:\n        dist = -(x*x + y*y)  # Negative for max-heap\n        \n        if len(heap) < k:\n            heapq.heappush(heap, (dist, x, y))\n        elif dist > heap[0][0]:  # Closer than farthest\n            heapq.heapreplace(heap, (dist, x, y))\n    \n    return [[x, y] for _, x, y in heap]"
      },
      {
        "id": "04-kth-largest-element-in-array",
        "slug": "kth-largest-element-in-array",
        "title": "Kth Largest Element in an Array",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "kth-largest-element-in-an-array"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums` and an integer `k`, return the `k`th largest element in the array.\n\nNote that it is the `k`th largest element in the sorted order, not the `k`th distinct element.\n\nCan you solve it without sorting?",
        "examples": [
          {
            "input": "nums = [3,2,1,5,6,4], k = 2",
            "output": "5",
            "explanation": ""
          },
          {
            "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
            "output": "4",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Sort descending, return arr[k-1]:",
            "options": [
              {
                "id": "a",
                "text": "Doesn't work"
              },
              {
                "id": "b",
                "text": "Works, O(n log n)"
              },
              {
                "id": "c",
                "text": "Works, O(n)"
              },
              {
                "id": "d",
                "text": "Works, O(1)"
              }
            ],
            "correct": "b",
            "explanation": "Sorting works but isn't optimal. O(n log n) time.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Min-heap of size k gives kth largest because:",
            "options": [
              {
                "id": "a",
                "text": "Heap root is always kth largest"
              },
              {
                "id": "b",
                "text": "We need to negate values"
              },
              {
                "id": "c",
                "text": "K largest elements are in heap, smallest of them is kth largest"
              },
              {
                "id": "d",
                "text": "Both A and C"
              }
            ],
            "correct": "d",
            "explanation": "Heap keeps k largest. Min among them = kth largest overall.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Using heap of size n vs size k:",
            "options": [
              {
                "id": "a",
                "text": "Size n is faster"
              },
              {
                "id": "b",
                "text": "Size k is faster for k << n"
              },
              {
                "id": "c",
                "text": "Same speed"
              },
              {
                "id": "d",
                "text": "Size k uses more memory"
              }
            ],
            "correct": "b",
            "explanation": "O(n log k) vs O(n log n). When k is small, log k << log n.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Quickselect is like quicksort but:",
            "options": [
              {
                "id": "a",
                "text": "Sorts completely"
              },
              {
                "id": "b",
                "text": "Only recurses on one side"
              },
              {
                "id": "c",
                "text": "Uses merge instead"
              },
              {
                "id": "d",
                "text": "Is always O(n log n)"
              }
            ],
            "correct": "b",
            "explanation": "We only care about kth position. Recurse only on the side containing it.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "After partition around pivot, if pivot is at index p:",
            "options": [
              {
                "id": "a",
                "text": "If p == n-k, pivot is the answer"
              },
              {
                "id": "b",
                "text": "If p < n-k, recurse right"
              },
              {
                "id": "c",
                "text": "If p > n-k, recurse left"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "Partition puts pivot in correct sorted position. Compare with target position n-k.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For guaranteed O(n log k) with simple code:",
            "options": [
              {
                "id": "a",
                "text": "Sorting"
              },
              {
                "id": "b",
                "text": "Heap"
              },
              {
                "id": "c",
                "text": "Quickselect"
              },
              {
                "id": "d",
                "text": "Linear scan"
              }
            ],
            "correct": "b",
            "explanation": "Quickselect is O(n) average but O(n^2) worst. Heap is reliably O(n log k).",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Min-heap of size k: process all elements, keeping k largest. Root is kth largest. Quickselect for O(n) average.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Min-heap of size k: process all elements, keeping k largest. Root is kth largest.",
        "timeComplexity": "O(n log k)",
        "spaceComplexity": "O(k)",
        "triggerWords": [
          "kth largest element in an array",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef findKthLargest(nums: List[int], k: int) -> int:\n    # Min-heap of size k\n    heap = []\n    \n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return heap[0]"
      },
      {
        "id": "05-task-scheduler",
        "slug": "task-scheduler",
        "title": "Task Scheduler",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "task-scheduler"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n\nHowever, there is a non-negative integer `n` that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least `n` units of time between any two same tasks.\n\nReturn the least number of units of times that the CPU will take to finish all the given tasks.",
        "examples": [
          {
            "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
            "output": "8",
            "explanation": "A -> B -> idle -> A -> B -> idle -> A -> B"
          },
          {
            "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0",
            "output": "6",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At each time unit, we should pick:",
            "options": [
              {
                "id": "a",
                "text": "Random available task"
              },
              {
                "id": "b",
                "text": "Task with highest remaining count"
              },
              {
                "id": "c",
                "text": "Alphabetically first task"
              },
              {
                "id": "d",
                "text": "Task used longest ago"
              }
            ],
            "correct": "b",
            "explanation": "Processing frequent tasks early gives more flexibility to schedule them with gaps.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "Greedy picks most frequent because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "It minimizes idle slots needed"
              },
              {
                "id": "c",
                "text": "It's alphabetically first"
              },
              {
                "id": "d",
                "text": "Random choice"
              }
            ],
            "correct": "b",
            "explanation": "High-frequency tasks need the most gaps. Handle them first to fill gaps optimally.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "To respect cooldown, we:",
            "options": [
              {
                "id": "a",
                "text": "Sort by last used time"
              },
              {
                "id": "b",
                "text": "Track when each task becomes available"
              },
              {
                "id": "c",
                "text": "Only use one task"
              },
              {
                "id": "d",
                "text": "Ignore cooldown"
              }
            ],
            "correct": "b",
            "explanation": "A task used at time t is available again at time t + n + 1.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "We idle when:",
            "options": [
              {
                "id": "a",
                "text": "There are tasks but none are available due to cooldown"
              },
              {
                "id": "b",
                "text": "All tasks are done"
              },
              {
                "id": "c",
                "text": "We've been working too long"
              },
              {
                "id": "d",
                "text": "Random"
              }
            ],
            "correct": "a",
            "explanation": "If all remaining tasks are on cooldown, must idle.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Max-heap helps because:",
            "options": [
              {
                "id": "a",
                "text": "O(log k) access to most frequent task"
              },
              {
                "id": "b",
                "text": "It tracks cooldown"
              },
              {
                "id": "c",
                "text": "It's faster than sorting"
              },
              {
                "id": "d",
                "text": "It stores time"
              }
            ],
            "correct": "a",
            "explanation": "We repeatedly need the task with max remaining count.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "A queue can track:",
            "options": [
              {
                "id": "a",
                "text": "Tasks currently on cooldown"
              },
              {
                "id": "b",
                "text": "All tasks"
              },
              {
                "id": "c",
                "text": "Completed tasks"
              },
              {
                "id": "d",
                "text": "Time elapsed"
              }
            ],
            "correct": "a",
            "explanation": "Queue holds (available_time, count) for tasks on cooldown. Pop when time arrives.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Greedy: always pick most frequent available task. Use formula: max(total_tasks, (maxFreq-1)*(n+1) + count_of_max_freq_tasks).",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Greedy: always process the most frequent task available.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "task scheduler",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import Counter\n\ndef leastInterval(tasks: List[str], n: int) -> int:\n    counts = Counter(tasks)\n    max_freq = max(counts.values())\n    max_freq_count = sum(1 for c in counts.values() if c == max_freq)\n    \n    # Formula: (max_freq - 1) cycles of (n + 1) slots + final tasks\n    min_time = (max_freq - 1) * (n + 1) + max_freq_count\n    \n    # At least need time for all tasks\n    return max(min_time, len(tasks))"
      },
      {
        "id": "06-design-twitter",
        "slug": "design-twitter",
        "title": "Design Twitter",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "design-twitter"
        ],
        "estimatedTime": 5,
        "problemStatement": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and see the 10 most recent tweets in the user's news feed.\n\nImplement the `Twitter` class:\n- `Twitter()` Initializes your twitter object.\n- `void postTweet(int userId, int tweetId)` Composes a new tweet with ID `tweetId` by the user `userId`. Each call to this function will be made with a unique `tweetId`.\n- `List<Integer> getNewsFeed(int userId)` Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themselves. Tweets must be ordered from most recent to least recent.\n- `void follow(int followerId, int followeeId)` The user with ID `followerId` started following the user with ID `followeeId`.\n- `void unfollow(int followerId, int followeeId)` The user with ID `followerId` started unfollowing the user with ID `followeeId`.",
        "examples": [
          {
            "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]",
            "output": "[null, null, [5], null, [6, 5], null, [5]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Each user's tweets should be stored as:",
            "options": [
              {
                "id": "a",
                "text": "Hash set"
              },
              {
                "id": "b",
                "text": "List ordered by time"
              },
              {
                "id": "c",
                "text": "Single most recent only"
              },
              {
                "id": "d",
                "text": "Linked list with random order"
              }
            ],
            "correct": "b",
            "explanation": "Need to retrieve by recency. Newest first (or append and iterate backwards).",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "User's followees should be stored as:",
            "options": [
              {
                "id": "a",
                "text": "List"
              },
              {
                "id": "b",
                "text": "Set"
              },
              {
                "id": "c",
                "text": "Queue"
              },
              {
                "id": "d",
                "text": "Stack"
              }
            ],
            "correct": "b",
            "explanation": "Need O(1) add, remove, and lookup. Set provides all three.",
            "conceptId": "hash-set"
          },
          {
            "type": "mcq",
            "question": "To get 10 most recent from k users:",
            "options": [
              {
                "id": "a",
                "text": "Collect all tweets, sort, take 10"
              },
              {
                "id": "b",
                "text": "Use heap to merge k sorted lists"
              },
              {
                "id": "c",
                "text": "Take 10 from each user"
              },
              {
                "id": "d",
                "text": "Random selection"
              }
            ],
            "correct": "b",
            "explanation": "Merge k sorted lists is the classic heap problem. O(k log k) for 10 items.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For merging k tweet lists to get most recent:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap"
              },
              {
                "id": "b",
                "text": "Max-heap"
              },
              {
                "id": "c",
                "text": "Either works"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "b",
            "explanation": "We want the most recent (largest timestamp). Max-heap by timestamp.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Getting 10 tweets from k followed users:",
            "options": [
              {
                "id": "a",
                "text": "O(k)"
              },
              {
                "id": "b",
                "text": "O(k log k) for 10 items = O(k log k)"
              },
              {
                "id": "c",
                "text": "O(10 log k) = O(log k)"
              },
              {
                "id": "d",
                "text": "O(n) for all tweets"
              }
            ],
            "correct": "b",
            "explanation": "Initialize heap with k users' latest tweets: O(k). Extract 10: O(10 log k).",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Merge k sorted tweet lists using heap. Each user's tweets are time-ordered. Heap holds one 'pointer' per user, extracting top 10.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "NewsFeed = merge k sorted lists (each user's tweets are time-ordered).",
        "timeComplexity": "O(k log k) for getNewsFeed",
        "spaceComplexity": "O(users + tweets)",
        "triggerWords": [
          "design twitter",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)  # userId -> [(time, tweetId)]\n        self.following = defaultdict(set)  # userId -> set of followeeIds\n    \n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n    \n    def getNewsFeed(self, userId: int) -> List[int]:\n        # Get tweets from user and all followees\n        heap = []\n        users = self.following[userId] | {userId}\n        \n        for uid in users:\n            if self.tweets[uid]:\n                idx = len(self.tweets[uid]) - 1\n                time, tweetId = self.tweets[uid][idx]\n                heap.append((-time, tweetId, uid, idx))\n        \n        heapq.heapify(heap)\n        result = []\n        \n        while heap and len(result) < 10:\n            _, tweetId, uid, idx = heapq.heappop(heap)\n            result.append(tweetId)\n            \n            if idx > 0:\n                time, tweetId = self.tweets[uid][idx - 1]\n                heapq.heappush(heap, (-time, tweetId, uid, idx - 1))\n        \n        return result\n    \n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n    \n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].discard(followeeId)"
      },
      {
        "id": "07-find-median-from-data-stream",
        "slug": "find-median-from-data-stream",
        "title": "Find Median from Data Stream",
        "category": "heap",
        "difficulty": "hard",
        "tags": [
          "heap",
          "find-median-from-data-stream"
        ],
        "estimatedTime": 5,
        "problemStatement": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nImplement the `MedianFinder` class:\n- `MedianFinder()` initializes the MedianFinder object.\n- `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far.",
        "examples": [
          {
            "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]",
            "output": "[null, null, null, 1.5, null, 2.0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Using a sorted list for each insert:",
            "options": [
              {
                "id": "a",
                "text": "O(1) insert, O(n) find median"
              },
              {
                "id": "b",
                "text": "O(n) insert, O(1) find median"
              },
              {
                "id": "c",
                "text": "O(log n) for both"
              },
              {
                "id": "d",
                "text": "Doesn't work"
              }
            ],
            "correct": "b",
            "explanation": "Inserting into sorted list is O(n). We want O(log n) insert.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For the smaller half, we use:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap"
              },
              {
                "id": "b",
                "text": "Max-heap"
              },
              {
                "id": "c",
                "text": "Either"
              },
              {
                "id": "d",
                "text": "Not a heap"
              }
            ],
            "correct": "b",
            "explanation": "We need quick access to the LARGEST of the smaller half. Max-heap gives max at root.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "For the larger half, we use:",
            "options": [
              {
                "id": "a",
                "text": "Min-heap"
              },
              {
                "id": "b",
                "text": "Max-heap"
              },
              {
                "id": "c",
                "text": "Either"
              },
              {
                "id": "d",
                "text": "Not a heap"
              }
            ],
            "correct": "a",
            "explanation": "We need quick access to the SMALLEST of the larger half. Min-heap gives min at root.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "The heaps should be balanced such that:",
            "options": [
              {
                "id": "a",
                "text": "Sizes are exactly equal"
              },
              {
                "id": "b",
                "text": "Sizes differ by at most 1"
              },
              {
                "id": "c",
                "text": "Left is always larger"
              },
              {
                "id": "d",
                "text": "Right is always larger"
              }
            ],
            "correct": "b",
            "explanation": "For odd count, one heap has one extra element (median is its top). For even, both same size.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If total count is odd, median is:",
            "options": [
              {
                "id": "a",
                "text": "Top of larger heap"
              },
              {
                "id": "b",
                "text": "Top of smaller heap"
              },
              {
                "id": "c",
                "text": "Top of the heap with more elements"
              },
              {
                "id": "d",
                "text": "Average of tops"
              }
            ],
            "correct": "c",
            "explanation": "The extra element is the median. Whichever heap has n/2+1 elements has the median.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "If total count is even, median is:",
            "options": [
              {
                "id": "a",
                "text": "Top of max-heap"
              },
              {
                "id": "b",
                "text": "Top of min-heap"
              },
              {
                "id": "c",
                "text": "Average of both tops"
              },
              {
                "id": "d",
                "text": "Sum of both tops"
              }
            ],
            "correct": "c",
            "explanation": "Two middle elements are at the boundary. Average them.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Two heaps: max-heap for smaller half, min-heap for larger half. Keep balanced (sizes differ <= 1). Median = top of larger heap or average of tops.",
        "pattern": "Heap / Priority Queue",
        "keyInsight": "Use two heaps: max-heap for smaller half, min-heap for larger half.",
        "timeComplexity": "O(log n) add, O(1) find",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "find median from data stream",
          "heap"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # Max-heap (negated values)\n        self.large = []  # Min-heap\n    \n    def addNum(self, num: int) -> None:\n        # Add to max-heap (smaller half)\n        heapq.heappush(self.small, -num)\n        \n        # Balance: move largest from small to large\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        \n        # Ensure small has >= elements as large\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    \n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2"
      }
    ],
    "graphs": [
      {
        "id": "01-number-of-islands",
        "slug": "number-of-islands",
        "title": "Number of Islands",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "number-of-islands"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
        "examples": [
          {
            "input": "grid = [",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "grid = [",
            "output": "3",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "An island is:",
            "options": [
              {
                "id": "a",
                "text": "Any single '1'"
              },
              {
                "id": "b",
                "text": "A connected group of '1's"
              },
              {
                "id": "c",
                "text": "All '1's in the grid"
              },
              {
                "id": "d",
                "text": "'1's on the edge"
              }
            ],
            "correct": "b",
            "explanation": "Adjacent '1's (up/down/left/right) form one island.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Each '1' cell is:",
            "options": [
              {
                "id": "a",
                "text": "An edge"
              },
              {
                "id": "b",
                "text": "A node with edges to adjacent '1's"
              },
              {
                "id": "c",
                "text": "Not part of the graph"
              },
              {
                "id": "d",
                "text": "Always isolated"
              }
            ],
            "correct": "b",
            "explanation": "Think of it as a graph. Nodes = land cells. Edges = adjacency.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "To count islands, we:",
            "options": [
              {
                "id": "a",
                "text": "Count all '1's"
              },
              {
                "id": "b",
                "text": "Count connected components of '1's"
              },
              {
                "id": "c",
                "text": "Count '0's between '1's"
              },
              {
                "id": "d",
                "text": "Count rows with '1's"
              }
            ],
            "correct": "b",
            "explanation": "Each connected component = one island.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We can use:",
            "options": [
              {
                "id": "a",
                "text": "DFS"
              },
              {
                "id": "b",
                "text": "BFS"
              },
              {
                "id": "c",
                "text": "Union-Find"
              },
              {
                "id": "d",
                "text": "Any of the above"
              }
            ],
            "correct": "d",
            "explanation": "All three work. DFS is simplest. Union-Find is elegant for component counting.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "To avoid counting the same island twice:",
            "options": [
              {
                "id": "a",
                "text": "Use a separate visited matrix"
              },
              {
                "id": "b",
                "text": "Modify the grid in-place (change '1' to '0')"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "Don't track visited"
              }
            ],
            "correct": "c",
            "explanation": "Both work. In-place saves space but modifies input.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We increment island count when:",
            "options": [
              {
                "id": "a",
                "text": "We find any '1'"
              },
              {
                "id": "b",
                "text": "We find an unvisited '1'"
              },
              {
                "id": "c",
                "text": "We finish traversing an island"
              },
              {
                "id": "d",
                "text": "Both B and C"
              }
            ],
            "correct": "d",
            "explanation": "We increment when starting a new island (unvisited '1'). This is also when we finish that we've counted it.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Count connected components: for each unvisited '1', increment count and flood-fill to mark the entire island.",
        "pattern": "Graph Traversal",
        "keyInsight": "When you find a '1', mark the entire island (all connected '1's) as visited. Count how many times you start a new island.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m × n)",
        "triggerWords": [
          "number of islands",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def numIslands(grid: List[List[str]]) -> int:\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if grid[r][c] != '1':\n            return\n        \n        grid[r][c] = '0'  # Mark visited\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                count += 1\n                dfs(r, c)\n    \n    return count"
      },
      {
        "id": "02-clone-graph",
        "slug": "clone-graph",
        "title": "Clone Graph",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "clone-graph"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Copying node.neighbors directly fails because:",
            "options": [
              {
                "id": "a",
                "text": "It copies the list"
              },
              {
                "id": "b",
                "text": "It still points to original nodes"
              },
              {
                "id": "c",
                "text": "Neighbors don't exist"
              },
              {
                "id": "d",
                "text": "Values are wrong"
              }
            ],
            "correct": "b",
            "explanation": "We need neighbors to point to NEW cloned nodes, not originals.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "The old→new hashmap:",
            "options": [
              {
                "id": "a",
                "text": "Stores node values"
              },
              {
                "id": "b",
                "text": "Maps original nodes to their clones"
              },
              {
                "id": "c",
                "text": "Counts visits"
              },
              {
                "id": "d",
                "text": "Stores edges"
              }
            ],
            "correct": "b",
            "explanation": "When we need the clone of a node, we look it up in the map.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "For cycles (node A's neighbor is B, B's neighbor is A):",
            "options": [
              {
                "id": "a",
                "text": "Skip duplicate nodes"
              },
              {
                "id": "b",
                "text": "Check hashmap before creating new clone"
              },
              {
                "id": "c",
                "text": "Only process once"
              },
              {
                "id": "d",
                "text": "B and C"
              }
            ],
            "correct": "d",
            "explanation": "If we've already cloned a node (it's in hashmap), reuse that clone instead of creating another.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We can traverse the graph using:",
            "options": [
              {
                "id": "a",
                "text": "DFS"
              },
              {
                "id": "b",
                "text": "BFS"
              },
              {
                "id": "c",
                "text": "Either"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Both work. We just need to visit all nodes.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We create a clone:",
            "options": [
              {
                "id": "a",
                "text": "Before visiting a node"
              },
              {
                "id": "b",
                "text": "When we first visit a node"
              },
              {
                "id": "c",
                "text": "After visiting all neighbors"
              },
              {
                "id": "d",
                "text": "Only for leaf nodes"
              }
            ],
            "correct": "b",
            "explanation": "Create clone immediately, add to hashmap, then process neighbors.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "For clone of node N, its neighbors are:",
            "options": [
              {
                "id": "a",
                "text": "Copies of N.neighbors"
              },
              {
                "id": "b",
                "text": "Clones of each neighbor (from hashmap)"
              },
              {
                "id": "c",
                "text": "Empty list"
              },
              {
                "id": "d",
                "text": "Same as N.neighbors"
              }
            ],
            "correct": "b",
            "explanation": "Each neighbor must be the cloned version, which we look up (or create).",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "DFS/BFS with old→new hashmap. For each node: create clone if not in map, then set neighbors to cloned versions (lookup in map).",
        "pattern": "Graph Traversal",
        "keyInsight": "Map old nodes to new nodes. When setting neighbors, look up the clone.",
        "timeComplexity": "O(V + E)",
        "spaceComplexity": "O(V)",
        "triggerWords": [
          "clone graph",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def cloneGraph(node: 'Node') -> 'Node':\n    if not node:\n        return None\n    \n    old_to_new = {}\n    \n    def dfs(node):\n        if node in old_to_new:\n            return old_to_new[node]\n        \n        # Create clone\n        copy = Node(node.val)\n        old_to_new[node] = copy\n        \n        # Clone neighbors\n        for neighbor in node.neighbors:\n            copy.neighbors.append(dfs(neighbor))\n        \n        return copy\n    \n    return dfs(node)"
      },
      {
        "id": "03-pacific-atlantic-water-flow",
        "slug": "pacific-atlantic-water-flow",
        "title": "Pacific Atlantic Water Flow",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "pacific-atlantic-water-flow"
        ],
        "estimatedTime": 5,
        "problemStatement": "There is an `m x n` rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\n\nThe island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the height above sea level of the cell at coordinate `(r, c)`.\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\nReturn a 2D list of grid coordinates `result` where `result[i] = [ri, ci]` denotes that rain water can flow from cell `(ri, ci)` to both the Pacific and Atlantic oceans.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Water flows from cell A to B if:",
            "options": [
              {
                "id": "a",
                "text": "A's height > B's height"
              },
              {
                "id": "b",
                "text": "A's height >= B's height (water flows downhill or flat)"
              },
              {
                "id": "c",
                "text": "A's height < B's height"
              },
              {
                "id": "d",
                "text": "They're adjacent"
              }
            ],
            "correct": "b",
            "explanation": "Water flows to equal or lower heights.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Searching \"uphill\" from ocean means:",
            "options": [
              {
                "id": "a",
                "text": "Move to cells with lower height"
              },
              {
                "id": "b",
                "text": "Move to cells with >= height"
              },
              {
                "id": "c",
                "text": "Always move up"
              },
              {
                "id": "d",
                "text": "Move to cells with exactly equal height"
              }
            ],
            "correct": "b",
            "explanation": "Reverse of downhill. If water can flow from B to A, we can reach B from A when going uphill.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Starting from oceans is better because:",
            "options": [
              {
                "id": "a",
                "text": "Fewer starting points (only edges)"
              },
              {
                "id": "b",
                "text": "It's the same as starting from each cell"
              },
              {
                "id": "c",
                "text": "Water only flows to oceans"
              },
              {
                "id": "d",
                "text": "It's faster to go uphill"
              }
            ],
            "correct": "a",
            "explanation": "Edge cells are O(m+n), vs O(mn) interior cells. Two DFS from edges, then intersect.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Pacific-adjacent cells are:",
            "options": [
              {
                "id": "a",
                "text": "Top row only"
              },
              {
                "id": "b",
                "text": "Left column only"
              },
              {
                "id": "c",
                "text": "Top row and left column"
              },
              {
                "id": "d",
                "text": "All edge cells"
              }
            ],
            "correct": "c",
            "explanation": "Pacific touches top and left edges.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "A cell is in the answer if:",
            "options": [
              {
                "id": "a",
                "text": "Reachable from Pacific"
              },
              {
                "id": "b",
                "text": "Reachable from Atlantic"
              },
              {
                "id": "c",
                "text": "Reachable from both"
              },
              {
                "id": "d",
                "text": "Reachable from neither"
              }
            ],
            "correct": "c",
            "explanation": "Must be able to flow to BOTH oceans.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We run DFS:",
            "options": [
              {
                "id": "a",
                "text": "Once from all ocean cells together"
              },
              {
                "id": "b",
                "text": "Once from Pacific edges, once from Atlantic edges"
              },
              {
                "id": "c",
                "text": "From every cell"
              },
              {
                "id": "d",
                "text": "Only from corners"
              }
            ],
            "correct": "b",
            "explanation": "Track reachability separately, then find intersection.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Reverse the flow: DFS 'uphill' from Pacific edges, DFS 'uphill' from Atlantic edges. Answer = intersection of both reachable sets.",
        "pattern": "Graph Traversal",
        "keyInsight": "Reverse the flow: start from oceans and flow \"uphill.\"",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m × n)",
        "triggerWords": [
          "pacific atlantic water flow",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def pacificAtlantic(heights: List[List[int]]) -> List[List[int]]:\n    rows, cols = len(heights), len(heights[0])\n    pacific, atlantic = set(), set()\n    \n    def dfs(r, c, visit, prev_height):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or\n            (r, c) in visit or heights[r][c] < prev_height):\n            return\n        \n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])\n    \n    for c in range(cols):\n        dfs(0, c, pacific, 0)        # Top row (Pacific)\n        dfs(rows - 1, c, atlantic, 0) # Bottom row (Atlantic)\n    \n    for r in range(rows):\n        dfs(r, 0, pacific, 0)        # Left col (Pacific)\n        dfs(r, cols - 1, atlantic, 0) # Right col (Atlantic)\n    \n    return list(pacific & atlantic)"
      },
      {
        "id": "04-course-schedule",
        "slug": "course-schedule",
        "title": "Course Schedule",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "course-schedule"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.",
        "examples": [
          {
            "input": "numCourses = 2, prerequisites = [[1,0]]",
            "output": "true",
            "explanation": "Take course 0 first, then course 1."
          },
          {
            "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
            "output": "false",
            "explanation": "Circular dependency. Can't finish either."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "prerequisites = [[1,0], [2,1]] means:",
            "options": [
              {
                "id": "a",
                "text": "0→1→2 (edges)"
              },
              {
                "id": "b",
                "text": "To take 1, need 0; to take 2, need 1"
              },
              {
                "id": "c",
                "text": "1→0 and 2→1 (edges)"
              },
              {
                "id": "d",
                "text": "Both B and C"
              }
            ],
            "correct": "d",
            "explanation": "[a,b] means b must come before a. Edge from b to a, or \"b→a\".",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "A cycle in prerequisites means:",
            "options": [
              {
                "id": "a",
                "text": "Some courses have no prereqs"
              },
              {
                "id": "b",
                "text": "Some courses form a circular dependency"
              },
              {
                "id": "c",
                "text": "All courses are independent"
              },
              {
                "id": "d",
                "text": "There are too many courses"
              }
            ],
            "correct": "b",
            "explanation": "A→B→C→A means you can't start any of them.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "To detect cycles in directed graph:",
            "options": [
              {
                "id": "a",
                "text": "BFS only"
              },
              {
                "id": "b",
                "text": "DFS with visited states"
              },
              {
                "id": "c",
                "text": "Count edges"
              },
              {
                "id": "d",
                "text": "Sort nodes"
              }
            ],
            "correct": "b",
            "explanation": "DFS with \"visiting\" (in current path) and \"visited\" (fully processed) states.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "In cycle detection DFS, each node can be:",
            "options": [
              {
                "id": "a",
                "text": "Visited or unvisited (2 states)"
              },
              {
                "id": "b",
                "text": "Unvisited, visiting, visited (3 states)"
              },
              {
                "id": "c",
                "text": "Red, blue, green"
              },
              {
                "id": "d",
                "text": "Open, closed"
              }
            ],
            "correct": "b",
            "explanation": "Unvisited = not seen. Visiting = in current DFS path. Visited = fully processed.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "A cycle exists if during DFS we reach:",
            "options": [
              {
                "id": "a",
                "text": "An unvisited node"
              },
              {
                "id": "b",
                "text": "A visited (completed) node"
              },
              {
                "id": "c",
                "text": "A \"visiting\" node"
              },
              {
                "id": "d",
                "text": "The start node"
              }
            ],
            "correct": "c",
            "explanation": "Reaching a node that's currently in our path = we've found a back edge = cycle.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Using Kahn's algorithm (BFS topological sort):",
            "options": [
              {
                "id": "a",
                "text": "If queue empties before all nodes processed, there's a cycle"
              },
              {
                "id": "b",
                "text": "If queue empties, no cycle"
              },
              {
                "id": "c",
                "text": "Queue length indicates cycle length"
              },
              {
                "id": "d",
                "text": "BFS doesn't detect cycles"
              }
            ],
            "correct": "a",
            "explanation": "Kahn's removes nodes with 0 in-degree. If cycle exists, some nodes never reach 0 in-degree.",
            "conceptId": "topological-sort"
          }
        ],
        "oneLiner": "Cycle in directed graph = can't finish. DFS with 3 states (unvisited/visiting/visited): if we reach a 'visiting' node, cycle found. Or use Kahn's: if completed < numCourses, cycle exists.",
        "pattern": "Graph Traversal",
        "keyInsight": "If there's a cycle in prerequisites, you can't finish. No cycle = can finish.",
        "timeComplexity": "O(V + E)",
        "spaceComplexity": "O(V + E)",
        "triggerWords": [
          "course schedule",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n    # Build adjacency list\n    graph = {i: [] for i in range(numCourses)}\n    for course, prereq in prerequisites:\n        graph[course].append(prereq)\n    \n    # 0 = unvisited, 1 = visiting, 2 = visited\n    state = [0] * numCourses\n    \n    def dfs(course):\n        if state[course] == 1:  # Cycle detected\n            return False\n        if state[course] == 2:  # Already processed\n            return True\n        \n        state[course] = 1  # Mark visiting\n        \n        for prereq in graph[course]:\n            if not dfs(prereq):\n                return False\n        \n        state[course] = 2  # Mark visited\n        return True\n    \n    for course in range(numCourses):\n        if not dfs(course):\n            return False\n    \n    return True"
      },
      {
        "id": "05-course-schedule-ii",
        "slug": "course-schedule-ii",
        "title": "Course Schedule II",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "course-schedule-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\n\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.",
        "examples": [
          {
            "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
            "output": "[0,2,1,3] or [0,1,2,3]",
            "explanation": ""
          },
          {
            "input": "numCourses = 1, prerequisites = []",
            "output": "[0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A topological order of a DAG is:",
            "options": [
              {
                "id": "a",
                "text": "Alphabetical order"
              },
              {
                "id": "b",
                "text": "Order where all prerequisites come before dependents"
              },
              {
                "id": "c",
                "text": "Shortest path order"
              },
              {
                "id": "d",
                "text": "Random order"
              }
            ],
            "correct": "b",
            "explanation": "If A must come before B, A appears earlier in topological order.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "DFS topological sort uses:",
            "options": [
              {
                "id": "a",
                "text": "Pre-order traversal"
              },
              {
                "id": "b",
                "text": "Post-order traversal (then reverse)"
              },
              {
                "id": "c",
                "text": "In-order traversal"
              },
              {
                "id": "d",
                "text": "Level-order traversal"
              }
            ],
            "correct": "b",
            "explanation": "We add nodes to result AFTER processing all descendants. Reversing gives correct order.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "Kahn's algorithm processes nodes in order of:",
            "options": [
              {
                "id": "a",
                "text": "Value"
              },
              {
                "id": "b",
                "text": "In-degree (starting with 0 in-degree)"
              },
              {
                "id": "c",
                "text": "Out-degree"
              },
              {
                "id": "d",
                "text": "Random"
              }
            ],
            "correct": "b",
            "explanation": "Nodes with no prerequisites can be taken first. Remove them, update in-degrees, repeat.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "If there's a cycle:",
            "options": [
              {
                "id": "a",
                "text": "We get a partial ordering"
              },
              {
                "id": "b",
                "text": "We can't produce any valid ordering"
              },
              {
                "id": "c",
                "text": "We include cycle nodes at the end"
              },
              {
                "id": "d",
                "text": "We ignore cycle nodes"
              }
            ],
            "correct": "b",
            "explanation": "Cyclic dependencies have no valid ordering. Return empty.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "For prerequisites [[1,0],[2,0]], valid orderings include:",
            "options": [
              {
                "id": "a",
                "text": "[0,1,2] only"
              },
              {
                "id": "b",
                "text": "[0,2,1] only"
              },
              {
                "id": "c",
                "text": "Both [0,1,2] and [0,2,1]"
              },
              {
                "id": "d",
                "text": "[1,2,0]"
              }
            ],
            "correct": "c",
            "explanation": "0 must come first, but 1 and 2 can be in either order.",
            "conceptId": "topological-sort"
          }
        ],
        "oneLiner": "Topological sort: DFS post-order (reversed) or Kahn's (process 0 in-degree first). If can't include all nodes, cycle exists, return empty.",
        "pattern": "Graph Traversal",
        "keyInsight": "Topological sort: order nodes so all edges go forward.",
        "timeComplexity": "O(V + E)",
        "spaceComplexity": "O(V + E)",
        "triggerWords": [
          "course schedule ii",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findOrder(numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n    graph = {i: [] for i in range(numCourses)}\n    for course, prereq in prerequisites:\n        graph[course].append(prereq)\n    \n    result = []\n    state = [0] * numCourses  # 0=unvisited, 1=visiting, 2=visited\n    \n    def dfs(course):\n        if state[course] == 1:  # Cycle\n            return False\n        if state[course] == 2:  # Already added\n            return True\n        \n        state[course] = 1\n        \n        for prereq in graph[course]:\n            if not dfs(prereq):\n                return False\n        \n        state[course] = 2\n        result.append(course)  # Post-order\n        return True\n    \n    for course in range(numCourses):\n        if not dfs(course):\n            return []\n    \n    return result  # Already in correct order (prereqs first)"
      },
      {
        "id": "06-rotting-oranges",
        "slug": "rotting-oranges",
        "title": "Rotting Oranges",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "rotting-oranges"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an `m x n` grid where each cell can have one of three values:\n- `0` representing an empty cell,\n- `1` representing a fresh orange, or\n- `2` representing a rotten orange.\n\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\n\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return `-1`.",
        "examples": [
          {
            "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
            "output": "4",
            "explanation": ""
          },
          {
            "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
            "output": "-1",
            "explanation": "Orange at (2,0) is isolated."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "BFS is preferred because:",
            "options": [
              {
                "id": "a",
                "text": "It's faster"
              },
              {
                "id": "b",
                "text": "It naturally processes in \"waves\" (levels)"
              },
              {
                "id": "c",
                "text": "DFS can't handle grids"
              },
              {
                "id": "d",
                "text": "BFS uses less memory"
              }
            ],
            "correct": "b",
            "explanation": "Each BFS level = 1 minute. All oranges at distance k rot at minute k.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We start BFS from:",
            "options": [
              {
                "id": "a",
                "text": "Top-left corner"
              },
              {
                "id": "b",
                "text": "All fresh oranges"
              },
              {
                "id": "c",
                "text": "All rotten oranges"
              },
              {
                "id": "d",
                "text": "Random cells"
              }
            ],
            "correct": "c",
            "explanation": "Rot spreads FROM rotten oranges. They're our sources.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Multi-source BFS means:",
            "options": [
              {
                "id": "a",
                "text": "Multiple separate BFS runs"
              },
              {
                "id": "b",
                "text": "All sources start in queue at once"
              },
              {
                "id": "c",
                "text": "Sources take turns"
              },
              {
                "id": "d",
                "text": "Only one source at a time"
              }
            ],
            "correct": "b",
            "explanation": "All rotten oranges start in queue at time 0. BFS processes them together.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We track time/minutes by:",
            "options": [
              {
                "id": "a",
                "text": "A separate timer variable"
              },
              {
                "id": "b",
                "text": "Processing level by level"
              },
              {
                "id": "c",
                "text": "Counting total pops"
              },
              {
                "id": "d",
                "text": "Random increments"
              }
            ],
            "correct": "b",
            "explanation": "One level = one minute. After processing all oranges at time t, move to time t+1.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We return -1 when:",
            "options": [
              {
                "id": "a",
                "text": "Grid is empty"
              },
              {
                "id": "b",
                "text": "There are no rotten oranges"
              },
              {
                "id": "c",
                "text": "Fresh oranges remain after BFS"
              },
              {
                "id": "d",
                "text": "Grid has zeros"
              }
            ],
            "correct": "c",
            "explanation": "If any fresh orange is unreachable from rotten ones, it stays fresh forever.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Multi-source BFS: start from all rotten oranges, spread level by level. Each level = 1 minute. If fresh remain after BFS, return -1.",
        "pattern": "Graph Traversal",
        "keyInsight": "Start BFS from ALL rotten oranges simultaneously. Each wave = 1 minute.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m × n)",
        "triggerWords": [
          "rotting oranges",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import deque\n\ndef orangesRotting(grid: List[List[int]]) -> int:\n    rows, cols = len(grid), len(grid[0])\n    queue = deque()\n    fresh = 0\n    \n    # Find all rotten oranges and count fresh\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 2:\n                queue.append((r, c))\n            elif grid[r][c] == 1:\n                fresh += 1\n    \n    minutes = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    while queue and fresh > 0:\n        minutes += 1\n        for _ in range(len(queue)):  # Process one level\n            r, c = queue.popleft()\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    queue.append((nr, nc))\n    \n    return minutes if fresh == 0 else -1"
      },
      {
        "id": "07-surrounded-regions",
        "slug": "surrounded-regions",
        "title": "Surrounded Regions",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "surrounded-regions"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` matrix `board` containing `'X'` and `'O'`, capture all regions that are 4-directionally surrounded by `'X'`.\n\nA region is captured by flipping all `'O'`s into `'X'`s in that surrounded region.",
        "examples": [
          {
            "input": "board = [[\"X\",\"X\",\"X\",\"X\"],",
            "output": "[[\"X\",\"X\",\"X\",\"X\"],",
            "explanation": "'O' at (3,1) is not surrounded (touches edge)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "An 'O' is surrounded if:",
            "options": [
              {
                "id": "a",
                "text": "It's not on the boundary"
              },
              {
                "id": "b",
                "text": "It's not connected to any boundary 'O'"
              },
              {
                "id": "c",
                "text": "It has 4 'X' neighbors"
              },
              {
                "id": "d",
                "text": "It's alone"
              }
            ],
            "correct": "b",
            "explanation": "If connected to boundary (directly or through other 'O's), it reaches the edge = not surrounded.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Checking from each 'O' whether it reaches boundary:",
            "options": [
              {
                "id": "a",
                "text": "Works perfectly"
              },
              {
                "id": "b",
                "text": "Is inefficient — O(m×n) per 'O'"
              },
              {
                "id": "c",
                "text": "Doesn't work"
              },
              {
                "id": "d",
                "text": "Is optimal"
              }
            ],
            "correct": "b",
            "explanation": "Each 'O' might need to traverse to check. Better to mark from boundary.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Instead of finding surrounded, we:",
            "options": [
              {
                "id": "a",
                "text": "Find all 'O's"
              },
              {
                "id": "b",
                "text": "Find 'O's connected to boundary (safe)"
              },
              {
                "id": "c",
                "text": "Count 'X's"
              },
              {
                "id": "d",
                "text": "Random selection"
              }
            ],
            "correct": "b",
            "explanation": "Mark safe 'O's first, then flip the rest.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "We start DFS/BFS from:",
            "options": [
              {
                "id": "a",
                "text": "All 'O's"
              },
              {
                "id": "b",
                "text": "Corner 'O's only"
              },
              {
                "id": "c",
                "text": "All boundary 'O's"
              },
              {
                "id": "d",
                "text": "Center"
              }
            ],
            "correct": "c",
            "explanation": "Only 'O's on the four edges. Any 'O' connected to them is safe.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Reverse: DFS from boundary 'O's to mark safe. Then flip all remaining 'O' to 'X'. Restore safe back to 'O'.",
        "pattern": "Graph Traversal",
        "keyInsight": "Reverse thinking: mark 'O's connected to boundary as \"safe,\" then flip everything else.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m × n)",
        "triggerWords": [
          "surrounded regions",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def solve(board: List[List[str]]) -> None:\n    if not board:\n        return\n    \n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if board[r][c] != 'O':\n            return\n        \n        board[r][c] = 'T'  # Mark as safe (temporary)\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    # Mark all 'O's connected to boundary\n    for r in range(rows):\n        dfs(r, 0)\n        dfs(r, cols - 1)\n    for c in range(cols):\n        dfs(0, c)\n        dfs(rows - 1, c)\n    \n    # Flip remaining 'O' to 'X', restore 'T' to 'O'\n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == 'O':\n                board[r][c] = 'X'\n            elif board[r][c] == 'T':\n                board[r][c] = 'O'"
      },
      {
        "id": "08-graph-valid-tree",
        "slug": "graph-valid-tree",
        "title": "Graph Valid Tree",
        "category": "graphs",
        "difficulty": "medium",
        "tags": [
          "graphs",
          "graph-valid-tree"
        ],
        "estimatedTime": 5,
        "problemStatement": "You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given an integer `n` and a list of edges where `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in the graph.\n\nReturn `true` if the edges of the given graph make up a valid tree, or `false` otherwise.",
        "examples": [
          {
            "input": "n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]",
            "output": "false (has cycle: 1-2-3-1)",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A tree with n nodes has exactly:",
            "options": [
              {
                "id": "a",
                "text": "n edges"
              },
              {
                "id": "b",
                "text": "n - 1 edges"
              },
              {
                "id": "c",
                "text": "n + 1 edges"
              },
              {
                "id": "d",
                "text": "2n edges"
              }
            ],
            "correct": "b",
            "explanation": "Tree is minimally connected. n-1 edges for n nodes.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "If len(edges) != n - 1:",
            "options": [
              {
                "id": "a",
                "text": "It could still be a tree"
              },
              {
                "id": "b",
                "text": "It's definitely not a tree"
              },
              {
                "id": "c",
                "text": "Need more checks"
              },
              {
                "id": "d",
                "text": "It's always a tree"
              }
            ],
            "correct": "b",
            "explanation": "Too few edges = disconnected. Too many = cycle.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "If len(edges) == n - 1:",
            "options": [
              {
                "id": "a",
                "text": "It's always a tree"
              },
              {
                "id": "b",
                "text": "It's a tree iff connected"
              },
              {
                "id": "c",
                "text": "It could have cycles"
              },
              {
                "id": "d",
                "text": "It's always connected"
              }
            ],
            "correct": "b",
            "explanation": "n-1 edges and connected → no cycles (exactly enough edges). n-1 edges and disconnected → some component has extra edges (cycle).",
            "conceptId": "union-find"
          },
          {
            "type": "mcq",
            "question": "To check if all nodes are connected:",
            "options": [
              {
                "id": "a",
                "text": "DFS/BFS from any node, count visited"
              },
              {
                "id": "b",
                "text": "Count edges"
              },
              {
                "id": "c",
                "text": "Check degrees"
              },
              {
                "id": "d",
                "text": "Sort nodes"
              }
            ],
            "correct": "a",
            "explanation": "If DFS visits all n nodes, graph is connected.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Using Union-Find to check valid tree:",
            "options": [
              {
                "id": "a",
                "text": "Union all edges, check if n-1 merges and no cycles"
              },
              {
                "id": "b",
                "text": "If any union fails (same parent), there's a cycle"
              },
              {
                "id": "c",
                "text": "Count components at end = 1"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Union-Find detects cycles (union nodes already connected) and counts components.",
            "conceptId": "union-find"
          }
        ],
        "oneLiner": "Valid tree: exactly n-1 edges AND connected. Check edge count first, then verify all nodes reachable via DFS/BFS.",
        "pattern": "Graph Traversal",
        "keyInsight": "A tree has exactly n-1 edges, is connected, and has no cycles.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "graph valid tree",
          "graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def validTree(n: int, edges: List[List[int]]) -> bool:\n    # Tree must have exactly n-1 edges\n    if len(edges) != n - 1:\n        return False\n    \n    # Build adjacency list\n    graph = {i: [] for i in range(n)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Check if all nodes are connected (DFS from node 0)\n    visited = set()\n    \n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n    \n    dfs(0)\n    \n    return len(visited) == n"
      }
    ],
    "advanced-graphs": [
      {
        "id": "01-min-cost-to-connect-all-points",
        "slug": "min-cost-to-connect-all-points",
        "title": "Min Cost to Connect All Points",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "min-cost-to-connect-all-points"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the manhattan distance between them: `|xi - xj| + |yi - yj|`.\n\nReturn the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.",
        "examples": [
          {
            "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
            "output": "20",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A Minimum Spanning Tree:",
            "options": [
              {
                "id": "a",
                "text": "Contains all nodes with minimum edges (n-1)"
              },
              {
                "id": "b",
                "text": "Has minimum total edge weight"
              },
              {
                "id": "c",
                "text": "Connects all nodes without cycles"
              },
              {
                "id": "d",
                "text": "All of the above"
              }
            ],
            "correct": "d",
            "explanation": "MST has n-1 edges, minimum total weight, and no cycles.",
            "conceptId": "union-find"
          },
          {
            "type": "mcq",
            "question": "For dense graphs (many edges), prefer:",
            "options": [
              {
                "id": "a",
                "text": "Prim's with min-heap"
              },
              {
                "id": "b",
                "text": "Kruskal's with sorting"
              },
              {
                "id": "c",
                "text": "Either is same"
              },
              {
                "id": "d",
                "text": "Neither works"
              }
            ],
            "correct": "a",
            "explanation": "Kruskal's sorts all edges O(E log E). Prim's processes O(V) nodes with heap.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "MST problem: Prim's (grow tree greedily from one node) or Kruskal's (add smallest edges that don't form cycles). Both give minimum total edge weight.",
        "pattern": "Advanced Graphs",
        "keyInsight": "This is classic MST: connect all nodes with minimum total edge weight.",
        "timeComplexity": "O(n² log n)",
        "spaceComplexity": "O(n²)",
        "triggerWords": [
          "min cost to connect all points",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef minCostConnectPoints(points: List[List[int]]) -> int:\n    n = len(points)\n    if n <= 1:\n        return 0\n    \n    # Prim's algorithm\n    visited = set()\n    min_heap = [(0, 0)]  # (cost, point_index)\n    total_cost = 0\n    \n    while len(visited) < n:\n        cost, i = heapq.heappop(min_heap)\n        \n        if i in visited:\n            continue\n        \n        visited.add(i)\n        total_cost += cost\n        \n        # Add edges to all unvisited points\n        for j in range(n):\n            if j not in visited:\n                dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(min_heap, (dist, j))\n    \n    return total_cost"
      },
      {
        "id": "02-network-delay-time",
        "slug": "network-delay-time",
        "title": "Network Delay Time",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "network-delay-time"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return the minimum time it takes for all the `n` nodes to receive the signal. If it is impossible for all the `n` nodes to receive the signal, return `-1`.",
        "examples": [
          {
            "input": "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2",
            "output": "2",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Dijkstra's is used because:",
            "options": [
              {
                "id": "a",
                "text": "We need shortest paths from a single source"
              },
              {
                "id": "b",
                "text": "Edge weights are non-negative"
              },
              {
                "id": "c",
                "text": "We need paths to ALL nodes"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Dijkstra's finds shortest paths from one source to all nodes with non-negative weights.",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "We maintain for each node:",
            "options": [
              {
                "id": "a",
                "text": "Shortest distance from source"
              },
              {
                "id": "b",
                "text": "Whether it's been finalized"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Number of paths"
              }
            ],
            "correct": "c",
            "explanation": "Signal reaches all when the farthest node receives it.",
            "conceptId": "dijkstra"
          }
        ],
        "oneLiner": "Dijkstra from source k to find shortest paths to all nodes. Answer = max shortest path. If any node unreachable, return -1.",
        "pattern": "Advanced Graphs",
        "keyInsight": "Dijkstra's algorithm: find shortest path from source to all nodes.",
        "timeComplexity": "O((V + E) log V)",
        "spaceComplexity": "O(V + E)",
        "triggerWords": [
          "network delay time",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\nfrom collections import defaultdict\n\ndef networkDelayTime(times: List[List[int]], n: int, k: int) -> int:\n    # Build adjacency list\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    # Dijkstra's algorithm\n    min_heap = [(0, k)]  # (time, node)\n    dist = {}\n    \n    while min_heap:\n        time, node = heapq.heappop(min_heap)\n        \n        if node in dist:\n            continue\n        \n        dist[node] = time\n        \n        for neighbor, weight in graph[node]:\n            if neighbor not in dist:\n                heapq.heappush(min_heap, (time + weight, neighbor))\n    \n    # Check if all nodes reached\n    if len(dist) == n:\n        return max(dist.values())\n    return -1"
      },
      {
        "id": "03-swim-in-rising-water",
        "slug": "swim-in-rising-water",
        "title": "Swim in Rising Water",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "swim-in-rising-water"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.\n\nThe rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares is at most `t`.\n\nReturn the least time until you can reach the bottom right square `(n - 1, n - 1)` starting from the top left square `(0, 0)`.",
        "examples": [
          {
            "input": "grid = [[0,2],[1,3]]",
            "output": "3",
            "explanation": "At time 3, we can swim anywhere."
          },
          {
            "input": "grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]",
            "output": "16",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We can traverse a cell when:",
            "options": [
              {
                "id": "a",
                "text": "Water level >= our current elevation"
              },
              {
                "id": "b",
                "text": "Water level >= that cell's elevation"
              },
              {
                "id": "c",
                "text": "Water level >= sum of elevations"
              },
              {
                "id": "d",
                "text": "Water level >= average elevation"
              }
            ],
            "correct": "b",
            "explanation": "We can enter a cell only when water covers it.",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "The minimum time to reach destination:",
            "options": [
              {
                "id": "a",
                "text": "Sum of all elevations on path"
              },
              {
                "id": "b",
                "text": "Maximum elevation on any path"
              },
              {
                "id": "c",
                "text": "Minimum of (maximum elevation) across all paths"
              },
              {
                "id": "d",
                "text": "Shortest path length"
              }
            ],
            "correct": "c",
            "explanation": "We need water to cover the highest point on our path. We want the path with smallest \"highest point\".",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "For minimax path, use:",
            "options": [
              {
                "id": "a",
                "text": "BFS (all edges equal)"
              },
              {
                "id": "b",
                "text": "DFS (explore all paths)"
              },
              {
                "id": "c",
                "text": "Dijkstra with max instead of sum"
              },
              {
                "id": "d",
                "text": "Floyd-Warshall"
              }
            ],
            "correct": "c",
            "explanation": "Dijkstra's greedy approach works - always expand the cell with minimum \"max so far\".",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "The min-heap should store:",
            "options": [
              {
                "id": "a",
                "text": "(distance, position)"
              },
              {
                "id": "b",
                "text": "(max_elevation_to_reach, position)"
              },
              {
                "id": "c",
                "text": "(cell_elevation, position)"
              },
              {
                "id": "d",
                "text": "(path_length, position)"
              }
            ],
            "correct": "b",
            "explanation": "We prioritize by the maximum elevation needed to reach each cell.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "When moving to neighbor, the new \"cost\" is:",
            "options": [
              {
                "id": "a",
                "text": "current_cost + neighbor_elevation"
              },
              {
                "id": "b",
                "text": "max(current_cost, neighbor_elevation)"
              },
              {
                "id": "c",
                "text": "min(current_cost, neighbor_elevation)"
              },
              {
                "id": "d",
                "text": "neighbor_elevation only"
              }
            ],
            "correct": "b",
            "explanation": "The cost to reach neighbor is the max of (cost to reach current, neighbor's elevation).",
            "conceptId": "dijkstra"
          }
        ],
        "oneLiner": "Minimax path problem: Dijkstra's where we minimize the maximum elevation along the path. Priority = max elevation needed to reach each cell.",
        "pattern": "Advanced Graphs",
        "keyInsight": "This is \"minimax path\" - minimize the maximum edge weight. Use modified Dijkstra's.",
        "timeComplexity": "O(n² log n)",
        "spaceComplexity": "O(n²)",
        "triggerWords": [
          "swim in rising water",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "import heapq\n\ndef swimInWater(grid: List[List[int]]) -> int:\n    n = len(grid)\n    visited = set()\n    min_heap = [(grid[0][0], 0, 0)]  # (max_elevation, row, col)\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while min_heap:\n        max_elev, r, c = heapq.heappop(min_heap)\n        \n        if (r, c) in visited:\n            continue\n        \n        visited.add((r, c))\n        \n        # Reached destination\n        if r == n - 1 and c == n - 1:\n            return max_elev\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited:\n                # New cost is max of current max and neighbor's elevation\n                new_max = max(max_elev, grid[nr][nc])\n                heapq.heappush(min_heap, (new_max, nr, nc))\n    \n    return -1"
      },
      {
        "id": "04-alien-dictionary",
        "slug": "alien-dictionary",
        "title": "Alien Dictionary",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "alien-dictionary"
        ],
        "estimatedTime": 5,
        "problemStatement": "There is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you.\n\nYou are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are sorted lexicographically by the rules of this new language.\n\nReturn a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return `\"\"`. If there are multiple solutions, return any of them.",
        "examples": [
          {
            "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
            "output": "\"wertf\"",
            "explanation": ""
          },
          {
            "input": "words = [\"z\",\"x\"]",
            "output": "\"zx\"",
            "explanation": ""
          },
          {
            "input": "words = [\"z\",\"x\",\"z\"]",
            "output": "\"\" (invalid - z can't come before and after x)",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "From sorted words [\"abc\", \"abd\"]:",
            "options": [
              {
                "id": "a",
                "text": "a < b < c < d"
              },
              {
                "id": "b",
                "text": "c < d (only)"
              },
              {
                "id": "c",
                "text": "a = a, b = b, c < d"
              },
              {
                "id": "d",
                "text": "Nothing"
              }
            ],
            "correct": "b",
            "explanation": "First difference is at position 2: 'c' vs 'd'. So c comes before d.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "For words [\"ab\", \"a\"]:",
            "options": [
              {
                "id": "a",
                "text": "b comes first"
              },
              {
                "id": "b",
                "text": "This is invalid ordering"
              },
              {
                "id": "c",
                "text": "a comes first"
              },
              {
                "id": "d",
                "text": "No constraint"
              }
            ],
            "correct": "b",
            "explanation": "A prefix (\"a\") should come BEFORE a longer word (\"ab\"). This violates that.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "From n sorted words, we get:",
            "options": [
              {
                "id": "a",
                "text": "n constraints"
              },
              {
                "id": "b",
                "text": "At most n-1 constraints"
              },
              {
                "id": "c",
                "text": "n² constraints"
              },
              {
                "id": "d",
                "text": "Exactly 26 constraints"
              }
            ],
            "correct": "b",
            "explanation": "We compare adjacent pairs. n words = n-1 pairs = at most n-1 constraints.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "We have edges like (a→b means a before b). Next:",
            "options": [
              {
                "id": "a",
                "text": "Sort alphabetically"
              },
              {
                "id": "b",
                "text": "Topological sort"
              },
              {
                "id": "c",
                "text": "BFS"
              },
              {
                "id": "d",
                "text": "Binary search"
              }
            ],
            "correct": "b",
            "explanation": "Constraints form a directed graph. Topological sort gives valid ordering.",
            "conceptId": "topological-sort"
          },
          {
            "type": "mcq",
            "question": "No valid ordering exists when:",
            "options": [
              {
                "id": "a",
                "text": "Graph has a cycle"
              },
              {
                "id": "b",
                "text": "Graph is disconnected"
              },
              {
                "id": "c",
                "text": "Multiple valid orderings"
              },
              {
                "id": "d",
                "text": "All characters appear"
              }
            ],
            "correct": "a",
            "explanation": "Cycle means a < b < ... < a, which is impossible.",
            "conceptId": "topological-sort"
          }
        ],
        "oneLiner": "Compare adjacent words to extract 'char A before char B' edges. Build graph. Topological sort. Cycle = invalid.",
        "pattern": "Advanced Graphs",
        "keyInsight": "Compare adjacent words to extract \"char A comes before char B\" relationships. Then topological sort.",
        "timeComplexity": "O(C)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "alien dictionary",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import defaultdict, deque\n\ndef alienOrder(words: List[str]) -> str:\n    # Build graph\n    graph = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    \n    # Compare adjacent words\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        min_len = min(len(w1), len(w2))\n        \n        # Check for invalid case: prefix comes after longer word\n        if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n            return \"\"\n        \n        # Find first difference\n        for j in range(min_len):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    in_degree[w2[j]] += 1\n                break\n    \n    # Topological sort (Kahn's algorithm)\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    result = []\n    \n    while queue:\n        c = queue.popleft()\n        result.append(c)\n        for neighbor in graph[c]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check for cycle\n    if len(result) != len(in_degree):\n        return \"\"\n    \n    return \"\".join(result)"
      },
      {
        "id": "05-cheapest-flights-within-k-stops",
        "slug": "cheapest-flights-within-k-stops",
        "title": "Cheapest Flights Within K Stops",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "cheapest-flights-within-k-stops"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return the cheapest price from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`.",
        "examples": [
          {
            "input": "n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1",
            "output": "700",
            "explanation": "0 → 1 → 3 with 1 stop costs 700."
          },
          {
            "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1",
            "output": "200",
            "explanation": "0 → 1 → 2 with 1 stop costs 200."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Standard Dijkstra fails here because:",
            "options": [
              {
                "id": "a",
                "text": "Negative edges"
              },
              {
                "id": "b",
                "text": "It ignores the stop constraint"
              },
              {
                "id": "c",
                "text": "Multiple destinations"
              },
              {
                "id": "d",
                "text": "Undirected graph"
              }
            ],
            "correct": "b",
            "explanation": "Dijkstra prunes paths greedily. A path with more stops but lower cost might be optimal.",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "At each node, we need to know:",
            "options": [
              {
                "id": "a",
                "text": "Just the minimum cost"
              },
              {
                "id": "b",
                "text": "Cost AND number of stops"
              },
              {
                "id": "c",
                "text": "Just the number of stops"
              },
              {
                "id": "d",
                "text": "Previous node only"
              }
            ],
            "correct": "b",
            "explanation": "A node might be reached cheaply with many stops, or expensively with few stops. Both matter.",
            "conceptId": "dijkstra"
          },
          {
            "type": "mcq",
            "question": "Bellman-Ford after k+1 iterations gives:",
            "options": [
              {
                "id": "a",
                "text": "Shortest path of any length"
              },
              {
                "id": "b",
                "text": "Shortest path using at most k+1 edges"
              },
              {
                "id": "c",
                "text": "Shortest path using exactly k+1 edges"
              },
              {
                "id": "d",
                "text": "Longest path"
              }
            ],
            "correct": "b",
            "explanation": "Each iteration extends paths by one edge. k+1 iterations = paths of at most k+1 edges.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For modified Dijkstra, heap stores:",
            "options": [
              {
                "id": "a",
                "text": "(cost, node)"
              },
              {
                "id": "b",
                "text": "(cost, node, stops)"
              },
              {
                "id": "c",
                "text": "(stops, node)"
              },
              {
                "id": "d",
                "text": "(node, cost)"
              }
            ],
            "correct": "b",
            "explanation": "We need to track stops to enforce the constraint.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Skip processing if:",
            "options": [
              {
                "id": "a",
                "text": "Cost is higher than current best"
              },
              {
                "id": "b",
                "text": "Stops exceed k"
              },
              {
                "id": "c",
                "text": "Node already visited"
              },
              {
                "id": "d",
                "text": "Node is destination"
              }
            ],
            "correct": "b",
            "explanation": "We can revisit nodes with fewer stops. Only skip if we've exceeded stop limit.",
            "conceptId": "dijkstra"
          }
        ],
        "oneLiner": "Bellman-Ford with k+1 iterations finds shortest path using at most k+1 edges. Each iteration extends paths by one hop.",
        "pattern": "Advanced Graphs",
        "keyInsight": "Bellman-Ford for k+1 iterations OR modified Dijkstra tracking stops.",
        "timeComplexity": "O(k × E)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "cheapest flights within k stops",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findCheapestPrice(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n    # Bellman-Ford with k+1 iterations\n    # prices[i] = min cost to reach city i\n    prices = [float('inf')] * n\n    prices[src] = 0\n    \n    # k stops means k+1 edges\n    for _ in range(k + 1):\n        # Use copy to avoid using updated values in same iteration\n        temp = prices.copy()\n        \n        for u, v, cost in flights:\n            if prices[u] != float('inf'):\n                temp[v] = min(temp[v], prices[u] + cost)\n        \n        prices = temp\n    \n    return prices[dst] if prices[dst] != float('inf') else -1"
      },
      {
        "id": "06-reconstruct-itinerary",
        "slug": "reconstruct-itinerary",
        "title": "Reconstruct Itinerary",
        "category": "advanced-graphs",
        "difficulty": "hard",
        "tags": [
          "advanced-graphs",
          "reconstruct-itinerary"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a list of airline `tickets` where `tickets[i] = [fromi, toi]` represent the departure and arrival airports of one flight. Reconstruct the itinerary in order and return it.\n\nAll the tickets belong to a man who departs from `\"JFK\"`, thus, the itinerary must begin with `\"JFK\"`. If there are multiple valid itineraries, return the itinerary that has the smallest lexical order when read as a single string.\n\nYou must use all the tickets once and only once.",
        "examples": [
          {
            "input": "tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
            "output": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]",
            "explanation": ""
          },
          {
            "input": "tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]",
            "output": "[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]",
            "explanation": "Another valid itinerary is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it's lexicographically larger."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Using every ticket (edge) exactly once is:",
            "options": [
              {
                "id": "a",
                "text": "Hamiltonian path (every node once)"
              },
              {
                "id": "b",
                "text": "Eulerian path (every edge once)"
              },
              {
                "id": "c",
                "text": "Shortest path"
              },
              {
                "id": "d",
                "text": "Minimum spanning tree"
              }
            ],
            "correct": "b",
            "explanation": "We must traverse every edge (ticket) exactly once.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Simple DFS from JFK might fail because:",
            "options": [
              {
                "id": "a",
                "text": "Can get stuck before using all tickets"
              },
              {
                "id": "b",
                "text": "Too slow"
              },
              {
                "id": "c",
                "text": "Can't handle cycles"
              },
              {
                "id": "d",
                "text": "Wrong starting point"
              }
            ],
            "correct": "a",
            "explanation": "Greedy DFS might take a path that doesn't use all edges. Need to backtrack or use Hierholzer's.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "Hierholzer's algorithm:",
            "options": [
              {
                "id": "a",
                "text": "Pre-order traversal"
              },
              {
                "id": "b",
                "text": "Post-order collection + reverse"
              },
              {
                "id": "c",
                "text": "Level-order traversal"
              },
              {
                "id": "d",
                "text": "In-order traversal"
              }
            ],
            "correct": "b",
            "explanation": "Add node to path AFTER visiting all its neighbors. Reverse at end. Handles dead-ends correctly.",
            "conceptId": "graph-traversal"
          },
          {
            "type": "mcq",
            "question": "To ensure smallest lexical order:",
            "options": [
              {
                "id": "a",
                "text": "Sort result at end"
              },
              {
                "id": "b",
                "text": "Visit neighbors in sorted order"
              },
              {
                "id": "c",
                "text": "Random order"
              },
              {
                "id": "d",
                "text": "Reverse alphabetical"
              }
            ],
            "correct": "b",
            "explanation": "Process neighbors in sorted order, so we always try the lexicographically smaller option first.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Adding to result after all neighbors are processed:",
            "options": [
              {
                "id": "a",
                "text": "Puts dead-ends first in reversed result"
              },
              {
                "id": "b",
                "text": "Ensures we use all edges before finalizing"
              },
              {
                "id": "c",
                "text": "Is just a coincidence"
              },
              {
                "id": "d",
                "text": "Only works for trees"
              }
            ],
            "correct": "b",
            "explanation": "A node only gets added when all its outgoing edges are used. Dead-ends added first, start added last, then reverse.",
            "conceptId": "graph-traversal"
          }
        ],
        "oneLiner": "Eulerian path with Hierholzer's: DFS with post-order collection (add node after visiting all edges). Process neighbors in sorted order. Reverse result at end.",
        "pattern": "Advanced Graphs",
        "keyInsight": "Hierholzer's algorithm: DFS with post-order collection. Visit neighbors in sorted order for lexicographic result.",
        "timeComplexity": "O(E log E)",
        "spaceComplexity": "O(E)",
        "triggerWords": [
          "reconstruct itinerary",
          "advanced-graphs"
        ],
        "relatedPatterns": [],
        "pythonSolution": "from collections import defaultdict\n\ndef findItinerary(tickets: List[List[str]]) -> List[str]:\n    # Build adjacency list with sorted destinations\n    graph = defaultdict(list)\n    for src, dst in sorted(tickets, reverse=True):\n        graph[src].append(dst)\n    \n    result = []\n    \n    def dfs(airport):\n        while graph[airport]:\n            # Pop from end (smallest lexicographically due to reverse sort)\n            next_airport = graph[airport].pop()\n            dfs(next_airport)\n        result.append(airport)  # Post-order\n    \n    dfs(\"JFK\")\n    \n    return result[::-1]  # Reverse for correct order"
      }
    ],
    "1d-dp": [
      {
        "id": "01-climbing-stairs",
        "slug": "climbing-stairs",
        "title": "Climbing Stairs",
        "category": "1d-dp",
        "difficulty": "easy",
        "tags": [
          "1d-dp",
          "climbing-stairs"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
        "examples": [
          {
            "input": "n = 2",
            "output": "2",
            "explanation": "(1+1) or (2)"
          },
          {
            "input": "n = 3",
            "output": "3",
            "explanation": "(1+1+1), (1+2), (2+1)"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To reach step n, the last move was:",
            "options": [
              {
                "id": "a",
                "text": "Always 1 step"
              },
              {
                "id": "b",
                "text": "Always 2 steps"
              },
              {
                "id": "c",
                "text": "Either 1 or 2 steps"
              },
              {
                "id": "d",
                "text": "Depends on n"
              }
            ],
            "correct": "c",
            "explanation": "From any step, you can take 1 or 2 steps. So you arrived from n-1 or n-2.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "ways(n) equals:",
            "options": [
              {
                "id": "a",
                "text": "ways(n-1) * 2"
              },
              {
                "id": "b",
                "text": "ways(n-1) + ways(n-2)"
              },
              {
                "id": "c",
                "text": "ways(n-1) * ways(n-2)"
              },
              {
                "id": "d",
                "text": "ways(n/2) * 2"
              }
            ],
            "correct": "b",
            "explanation": "Ways from n-1 (then take 1 step) PLUS ways from n-2 (then take 2 steps).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Base cases are:",
            "options": [
              {
                "id": "a",
                "text": "ways(0) = 0, ways(1) = 1"
              },
              {
                "id": "b",
                "text": "ways(0) = 1, ways(1) = 1"
              },
              {
                "id": "c",
                "text": "ways(1) = 1, ways(2) = 1"
              },
              {
                "id": "d",
                "text": "ways(1) = 2, ways(2) = 2"
              }
            ],
            "correct": "b",
            "explanation": "ways(1)=1 (one way: take 1 step). ways(0)=1 (one way: do nothing - you're there).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "The sequence 1, 1, 2, 3, 5, 8, 13... is:",
            "options": [
              {
                "id": "a",
                "text": "Powers of 2"
              },
              {
                "id": "b",
                "text": "Fibonacci sequence"
              },
              {
                "id": "c",
                "text": "Triangular numbers"
              },
              {
                "id": "d",
                "text": "Primes"
              }
            ],
            "correct": "b",
            "explanation": "Each term is sum of previous two. Classic Fibonacci.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Instead of array, we only need:",
            "options": [
              {
                "id": "a",
                "text": "One variable"
              },
              {
                "id": "b",
                "text": "Two variables"
              },
              {
                "id": "c",
                "text": "Three variables"
              },
              {
                "id": "d",
                "text": "Full array"
              }
            ],
            "correct": "b",
            "explanation": "Only need previous two values to compute current.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "To reach step n, add ways to reach n-1 and n-2. It's Fibonacci.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "To reach step n, you either came from step n-1 (took 1 step) or step n-2 (took 2 steps).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "climbing stairs",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def climbStairs(n: int) -> int:\n    if n <= 2:\n        return n\n    \n    # Only need previous two values\n    prev2, prev1 = 1, 2\n    \n    for i in range(3, n + 1):\n        curr = prev1 + prev2\n        prev2 = prev1\n        prev1 = curr\n    \n    return prev1"
      },
      {
        "id": "02-min-cost-climbing-stairs",
        "slug": "min-cost-climbing-stairs",
        "title": "Min Cost Climbing Stairs",
        "category": "1d-dp",
        "difficulty": "easy",
        "tags": [
          "1d-dp",
          "min-cost-climbing-stairs"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index `0`, or the step with index `1`.\n\nReturn the minimum cost to reach the top of the floor.",
        "examples": [
          {
            "input": "cost = [10,15,20]",
            "output": "15",
            "explanation": "Start at index 1, pay 15, climb two steps to reach the top."
          },
          {
            "input": "cost = [1,100,1,1,1,100,1,1,100,1]",
            "output": "6",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For cost = [10, 15, 20], the top is:",
            "options": [
              {
                "id": "a",
                "text": "Index 2"
              },
              {
                "id": "b",
                "text": "Beyond index 2 (index 3)"
              },
              {
                "id": "c",
                "text": "Index 0"
              },
              {
                "id": "d",
                "text": "Sum of all costs"
              }
            ],
            "correct": "b",
            "explanation": "We need to go PAST the last step. Top is at index n (one beyond array).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "We pay cost[i] when:",
            "options": [
              {
                "id": "a",
                "text": "We arrive at step i"
              },
              {
                "id": "b",
                "text": "We leave step i"
              },
              {
                "id": "c",
                "text": "We look at step i"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "b",
            "explanation": "Pay the cost of the step you're standing on to climb away from it.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Minimum cost to reach step i:",
            "options": [
              {
                "id": "a",
                "text": "min(dp[i-1], dp[i-2])"
              },
              {
                "id": "b",
                "text": "dp[i-1] + dp[i-2]"
              },
              {
                "id": "c",
                "text": "cost[i-1] + cost[i-2]"
              },
              {
                "id": "d",
                "text": "min(cost[i-1], cost[i-2])"
              }
            ],
            "correct": "a",
            "explanation": "Come from i-1 (paying cost[i-1]) or from i-2 (paying cost[i-2]). Take minimum.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0] and dp[1] are:",
            "options": [
              {
                "id": "a",
                "text": "cost[0] and cost[1]"
              },
              {
                "id": "b",
                "text": "0 and 0"
              },
              {
                "id": "c",
                "text": "0 and cost[0]"
              },
              {
                "id": "d",
                "text": "cost[0] and 0"
              }
            ],
            "correct": "b",
            "explanation": "We can START at step 0 or 1 for free. We pay when we LEAVE, not arrive.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "The answer is:",
            "options": [
              {
                "id": "a",
                "text": "dp[n-1]"
              },
              {
                "id": "b",
                "text": "dp[n]"
              },
              {
                "id": "c",
                "text": "min(dp[n-1], dp[n])"
              },
              {
                "id": "d",
                "text": "dp[n] + cost[n-1]"
              }
            ],
            "correct": "b",
            "explanation": "We want to reach the \"top\" which is position n (beyond the array).",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "dp[i] = min cost to reach step i. dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]). Answer is dp[n].",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "dp[i] = min cost to reach step i. To reach step i, pay either cost[i-1] from step i-1 or cost[i-2] from step i-2.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "min cost climbing stairs",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minCostClimbingStairs(cost: List[int]) -> int:\n    n = len(cost)\n    \n    # dp[i] = min cost to reach step i\n    # Only need previous two values\n    prev2, prev1 = 0, 0\n    \n    for i in range(2, n + 1):\n        curr = min(prev1 + cost[i - 1], prev2 + cost[i - 2])\n        prev2 = prev1\n        prev1 = curr\n    \n    return prev1"
      },
      {
        "id": "03-house-robber",
        "slug": "house-robber",
        "title": "House Robber",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "house-robber"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
        "examples": [
          {
            "input": "nums = [1,2,3,1]",
            "output": "4",
            "explanation": "Rob house 0 (1) + house 2 (3) = 4"
          },
          {
            "input": "nums = [2,7,9,3,1]",
            "output": "12",
            "explanation": "Rob house 0 (2) + house 2 (9) + house 4 (1) = 12"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At house i, you can:",
            "options": [
              {
                "id": "a",
                "text": "Rob it (can't rob i-1)"
              },
              {
                "id": "b",
                "text": "Skip it (keep previous best)"
              },
              {
                "id": "c",
                "text": "Rob both i and i-1"
              },
              {
                "id": "d",
                "text": "A and B both valid"
              }
            ],
            "correct": "d",
            "explanation": "At each house, choose: rob this one (skip i-1) or skip this one (keep i-1's best).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you rob house i, the best you can add to is:",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1] (include i-1)"
              },
              {
                "id": "b",
                "text": "dp[i-2] (skip i-1)"
              },
              {
                "id": "c",
                "text": "dp[i-3]"
              },
              {
                "id": "d",
                "text": "0"
              }
            ],
            "correct": "b",
            "explanation": "Can't rob adjacent. So if you rob i, you can only add to best result up to i-2.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you skip house i:",
            "options": [
              {
                "id": "a",
                "text": "You get dp[i-1]"
              },
              {
                "id": "b",
                "text": "You get dp[i-2]"
              },
              {
                "id": "c",
                "text": "You get 0"
              },
              {
                "id": "d",
                "text": "You must rob i-1"
              }
            ],
            "correct": "a",
            "explanation": "Skipping i means the best up to i is same as best up to i-1.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i] = ?",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1] + dp[i-2]"
              },
              {
                "id": "b",
                "text": "max(dp[i-1], dp[i-2])"
              },
              {
                "id": "c",
                "text": "max(nums[i] + dp[i-2], dp[i-1])"
              },
              {
                "id": "d",
                "text": "nums[i] + max(dp[i-1], dp[i-2])"
              }
            ],
            "correct": "c",
            "explanation": "Rob house i (nums[i] + dp[i-2]) OR skip it (dp[i-1]). Take max.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For one house nums[0]:",
            "options": [
              {
                "id": "a",
                "text": "dp[0] = 0"
              },
              {
                "id": "b",
                "text": "dp[0] = nums[0]"
              },
              {
                "id": "c",
                "text": "dp[0] = max(0, nums[0])"
              },
              {
                "id": "d",
                "text": "Depends on neighbors"
              }
            ],
            "correct": "b",
            "explanation": "With only one house, rob it.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "At each house: rob it (add to dp[i-2]) or skip it (keep dp[i-1]). Take the max.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "For each house: either rob it (add to best from 2 houses back) or skip it (take best from 1 house back).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "house robber",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def rob(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    # prev2 = max profit up to i-2\n    # prev1 = max profit up to i-1\n    prev2, prev1 = 0, nums[0]\n    \n    for i in range(1, len(nums)):\n        # Rob current (nums[i] + prev2) or skip (prev1)\n        curr = max(nums[i] + prev2, prev1)\n        prev2 = prev1\n        prev1 = curr\n    \n    return prev1"
      },
      {
        "id": "04-house-robber-ii",
        "slug": "house-robber-ii",
        "title": "House Robber II",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "house-robber-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
        "examples": [
          {
            "input": "nums = [2,3,2]",
            "output": "3",
            "explanation": "Cannot rob house 0 and 2 (adjacent in circle). Rob house 1."
          },
          {
            "input": "nums = [1,2,3,1]",
            "output": "4",
            "explanation": "Rob house 0 (1) + house 2 (3) = 4"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "In a circle, houses 0 and n-1 are:",
            "options": [
              {
                "id": "a",
                "text": "Independent"
              },
              {
                "id": "b",
                "text": "Adjacent (can't both be robbed)"
              },
              {
                "id": "c",
                "text": "The same house"
              },
              {
                "id": "d",
                "text": "Always robbed together"
              }
            ],
            "correct": "b",
            "explanation": "Circle means first and last are neighbors.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "We can split this into:",
            "options": [
              {
                "id": "a",
                "text": "Rob first OR rob last"
              },
              {
                "id": "b",
                "text": "Consider houses [0, n-2] OR [1, n-1]"
              },
              {
                "id": "c",
                "text": "Just use House Robber I solution"
              },
              {
                "id": "d",
                "text": "Divide into two equal halves"
              }
            ],
            "correct": "b",
            "explanation": "If we exclude last house, first can be robbed. If we exclude first, last can be robbed. One of these is optimal.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "max(rob[0..n-2], rob[1..n-1]) is correct because:",
            "options": [
              {
                "id": "a",
                "text": "One range includes first, other includes last"
              },
              {
                "id": "b",
                "text": "They don't overlap"
              },
              {
                "id": "c",
                "text": "They cover all houses"
              },
              {
                "id": "d",
                "text": "It's a heuristic"
              }
            ],
            "correct": "a",
            "explanation": "[0..n-2] allows robbing first but not last. [1..n-1] allows robbing last but not first. The optimal answer falls into one of these.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Middle houses (not first or last):",
            "options": [
              {
                "id": "a",
                "text": "Are in both ranges"
              },
              {
                "id": "b",
                "text": "Are excluded"
              },
              {
                "id": "c",
                "text": "Are special cases"
              },
              {
                "id": "d",
                "text": "Need separate handling"
              }
            ],
            "correct": "a",
            "explanation": "Both ranges include middle houses. They can be robbed in either scenario.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "With only one house:",
            "options": [
              {
                "id": "a",
                "text": "Return 0"
              },
              {
                "id": "b",
                "text": "Return nums[0]"
              },
              {
                "id": "c",
                "text": "Return -1"
              },
              {
                "id": "d",
                "text": "Not possible"
              }
            ],
            "correct": "b",
            "explanation": "One house has no neighbors (including itself). Rob it.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Circle = first and last adjacent. Break it: max(rob houses 0 to n-2, rob houses 1 to n-1). Solve two linear House Robber problems.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "Break the circle: either skip the first house OR skip the last house. Solve two linear problems.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "house robber ii",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def rob(nums: List[int]) -> int:\n    if len(nums) == 1:\n        return nums[0]\n    \n    def rob_linear(houses):\n        prev2, prev1 = 0, 0\n        for money in houses:\n            curr = max(money + prev2, prev1)\n            prev2 = prev1\n            prev1 = curr\n        return prev1\n    \n    # Skip last house OR skip first house\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"
      },
      {
        "id": "05-longest-palindromic-substring",
        "slug": "longest-palindromic-substring",
        "title": "Longest Palindromic Substring",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "longest-palindromic-substring"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s`, return the longest palindromic substring in `s`.",
        "examples": [
          {
            "input": "s = \"babad\"",
            "output": "\"bab\" (or \"aba\")",
            "explanation": ""
          },
          {
            "input": "s = \"cbbd\"",
            "output": "\"bb\"",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "\"aba\" has center at:",
            "options": [
              {
                "id": "a",
                "text": "'a' (index 0)"
              },
              {
                "id": "b",
                "text": "'b' (index 1)"
              },
              {
                "id": "c",
                "text": "'a' (index 2)"
              },
              {
                "id": "d",
                "text": "Between characters"
              }
            ],
            "correct": "b",
            "explanation": "Odd-length palindromes have a single character center.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "\"abba\" has center:",
            "options": [
              {
                "id": "a",
                "text": "At 'b' (index 1)"
              },
              {
                "id": "b",
                "text": "At 'b' (index 2)"
              },
              {
                "id": "c",
                "text": "Between the two 'b's"
              },
              {
                "id": "d",
                "text": "Doesn't have a center"
              }
            ],
            "correct": "c",
            "explanation": "Even-length palindromes have center between two characters.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "For string of length n, total possible centers:",
            "options": [
              {
                "id": "a",
                "text": "n"
              },
              {
                "id": "b",
                "text": "n - 1"
              },
              {
                "id": "c",
                "text": "2n - 1"
              },
              {
                "id": "d",
                "text": "n²"
              }
            ],
            "correct": "c",
            "explanation": "n single-char centers + (n-1) between-char centers = 2n - 1.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "When expanding from center (left, right):",
            "options": [
              {
                "id": "a",
                "text": "Expand if s[left] == s[right]"
              },
              {
                "id": "b",
                "text": "Expand if left < right"
              },
              {
                "id": "c",
                "text": "Expand if palindrome found"
              },
              {
                "id": "d",
                "text": "Always expand once"
              }
            ],
            "correct": "a",
            "explanation": "Keep expanding while characters match. Stop when mismatch or boundary.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Expand around center vs DP:",
            "options": [
              {
                "id": "a",
                "text": "DP is O(n²) time AND space"
              },
              {
                "id": "b",
                "text": "Expand is O(n²) time, O(1) space"
              },
              {
                "id": "c",
                "text": "They're the same"
              },
              {
                "id": "d",
                "text": "DP is faster"
              }
            ],
            "correct": "b",
            "explanation": "Expand around center is more space-efficient for this problem.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Every palindrome has a center. Try all 2n-1 centers, expand outward while characters match. Track longest.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "Expand around center: every palindrome has a center (one char for odd length, two chars for even length).",
        "timeComplexity": "O(n²)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "longest palindromic substring",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def longestPalindrome(s: str) -> str:\n    result = \"\"\n    \n    def expand(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    for i in range(len(s)):\n        # Odd length palindrome (single char center)\n        odd = expand(i, i)\n        if len(odd) > len(result):\n            result = odd\n        \n        # Even length palindrome (between chars center)\n        even = expand(i, i + 1)\n        if len(even) > len(result):\n            result = even\n    \n    return result"
      },
      {
        "id": "06-palindromic-substrings",
        "slug": "palindromic-substrings",
        "title": "Palindromic Substrings",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "palindromic-substrings"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s`, return the number of palindromic substrings in it.\n\nA string is a palindrome when it reads the same backward as forward.\n\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
          {
            "input": "s = \"abc\"",
            "output": "3",
            "explanation": "\"a\", \"b\", \"c\" (each single char is a palindrome)"
          },
          {
            "input": "s = \"aaa\"",
            "output": "6",
            "explanation": "\"a\" (3 times), \"aa\" (2 times), \"aaa\" (1 time)"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Each single character is:",
            "options": [
              {
                "id": "a",
                "text": "Not a palindrome"
              },
              {
                "id": "b",
                "text": "Always a palindrome"
              },
              {
                "id": "c",
                "text": "Sometimes a palindrome"
              },
              {
                "id": "d",
                "text": "A center only"
              }
            ],
            "correct": "b",
            "explanation": "Any single character reads same forwards and backwards.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "When expanding from center and s[left] == s[right]:",
            "options": [
              {
                "id": "a",
                "text": "Found one palindrome, stop"
              },
              {
                "id": "b",
                "text": "Found one palindrome, continue expanding"
              },
              {
                "id": "c",
                "text": "Not a palindrome yet"
              },
              {
                "id": "d",
                "text": "Found all palindromes"
              }
            ],
            "correct": "b",
            "explanation": "Each successful expansion is a NEW palindrome. \"a\", \"aba\", \"cabac\" are all different palindromes from same center.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Palindromic substrings in \"aba\":",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "2"
              },
              {
                "id": "c",
                "text": "3"
              },
              {
                "id": "d",
                "text": "4"
              }
            ],
            "correct": "d",
            "explanation": "\"a\" (pos 0), \"b\", \"a\" (pos 2), \"aba\" = 4 palindromes.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "The expand function should return:",
            "options": [
              {
                "id": "a",
                "text": "True/False"
              },
              {
                "id": "b",
                "text": "Length of palindrome"
              },
              {
                "id": "c",
                "text": "Count of palindromes found"
              },
              {
                "id": "d",
                "text": "Starting index"
              }
            ],
            "correct": "c",
            "explanation": "Each expansion step = one palindrome. Return total count from this center.",
            "conceptId": "two-pointers"
          },
          {
            "type": "mcq",
            "question": "Total palindromes = sum of:",
            "options": [
              {
                "id": "a",
                "text": "Palindromes from each odd center + even center"
              },
              {
                "id": "b",
                "text": "All substrings"
              },
              {
                "id": "c",
                "text": "Unique characters"
              },
              {
                "id": "d",
                "text": "Longest palindrome"
              }
            ],
            "correct": "a",
            "explanation": "Try all 2n-1 centers, sum up palindromes found from each.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Expand from each of 2n-1 centers. Each successful expansion = one more palindrome. Sum all counts.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "Same as Longest Palindromic Substring: expand around each center, but COUNT instead of track max.",
        "timeComplexity": "O(n²)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "palindromic substrings",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def countSubstrings(s: str) -> int:\n    count = 0\n    \n    def expand(left, right):\n        nonlocal count\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    \n    for i in range(len(s)):\n        expand(i, i)      # Odd length\n        expand(i, i + 1)  # Even length\n    \n    return count"
      },
      {
        "id": "07-decode-ways",
        "slug": "decode-ways",
        "title": "Decode Ways",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "decode-ways"
        ],
        "estimatedTime": 5,
        "problemStatement": "A message containing letters from `A-Z` can be encoded into numbers using the following mapping:\n\n```\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nGiven a string `s` containing only digits, return the number of ways to decode it.",
        "examples": [
          {
            "input": "s = \"12\"",
            "output": "2",
            "explanation": "\"12\" can be decoded as \"AB\" (1 2) or \"L\" (12)."
          },
          {
            "input": "s = \"226\"",
            "output": "3",
            "explanation": "\"226\" can be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
          },
          {
            "input": "s = \"06\"",
            "output": "0",
            "explanation": "\"06\" cannot be decoded. \"6\" is valid but not \"06\"."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A single digit is valid if:",
            "options": [
              {
                "id": "a",
                "text": "It's 0-9"
              },
              {
                "id": "b",
                "text": "It's 1-9"
              },
              {
                "id": "c",
                "text": "It's 1-26"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "b",
            "explanation": "'0' alone has no letter. Only '1'-'9' map to 'A'-'I'.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Two digits \"XY\" are valid if:",
            "options": [
              {
                "id": "a",
                "text": "10 ≤ XY ≤ 26"
              },
              {
                "id": "b",
                "text": "1 ≤ XY ≤ 26"
              },
              {
                "id": "c",
                "text": "XY ≤ 26"
              },
              {
                "id": "d",
                "text": "X is not 0"
              }
            ],
            "correct": "a",
            "explanation": "Must be 10-26. Numbers like \"01\", \"05\" are invalid (leading zero).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i] = number of ways to decode s[0:i]. dp[i] = ?",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1] + dp[i-2]"
              },
              {
                "id": "b",
                "text": "dp[i-1] (if s[i-1] valid) + dp[i-2] (if s[i-2:i] valid)"
              },
              {
                "id": "c",
                "text": "max(dp[i-1], dp[i-2])"
              },
              {
                "id": "d",
                "text": "dp[i-1] * dp[i-2]"
              }
            ],
            "correct": "b",
            "explanation": "Add ways from using 1 digit (if valid) and from using 2 digits (if valid).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "How many ways to decode \"06\"?",
            "options": [
              {
                "id": "a",
                "text": "1"
              },
              {
                "id": "b",
                "text": "2"
              },
              {
                "id": "c",
                "text": "0"
              },
              {
                "id": "d",
                "text": "6"
              }
            ],
            "correct": "c",
            "explanation": "\"0\" is invalid single digit. \"06\" is invalid (leading zero). No valid decoding.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0] (empty string) should be:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "Undefined"
              },
              {
                "id": "d",
                "text": "-1"
              }
            ],
            "correct": "b",
            "explanation": "One way to decode empty string: do nothing. Needed for recurrence to work.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Like climbing stairs, but with validity checks. dp[i] = dp[i-1] (if single digit valid) + dp[i-2] (if two digits valid).",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "At each position: either take 1 digit (if valid) or 2 digits (if valid). Similar to climbing stairs with conditions.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "decode ways",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def numDecodings(s: str) -> int:\n    if not s or s[0] == '0':\n        return 0\n    \n    # prev2 = dp[i-2], prev1 = dp[i-1]\n    prev2, prev1 = 1, 1\n    \n    for i in range(1, len(s)):\n        curr = 0\n        \n        # Single digit valid (1-9)\n        if s[i] != '0':\n            curr += prev1\n        \n        # Two digits valid (10-26)\n        two_digit = int(s[i-1:i+1])\n        if 10 <= two_digit <= 26:\n            curr += prev2\n        \n        prev2 = prev1\n        prev1 = curr\n    \n    return prev1"
      },
      {
        "id": "08-word-break",
        "slug": "word-break",
        "title": "Word Break",
        "category": "1d-dp",
        "difficulty": "medium",
        "tags": [
          "1d-dp",
          "word-break"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.",
        "examples": [
          {
            "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
            "output": "true",
            "explanation": "\"leetcode\" = \"leet\" + \"code\""
          },
          {
            "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
            "output": "true",
            "explanation": "\"applepenapple\" = \"apple\" + \"pen\" + \"apple\""
          },
          {
            "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "dp[i] represents:",
            "options": [
              {
                "id": "a",
                "text": "Number of ways to segment s[0:i]"
              },
              {
                "id": "b",
                "text": "Whether s[0:i] can be segmented"
              },
              {
                "id": "c",
                "text": "Length of longest word ending at i"
              },
              {
                "id": "d",
                "text": "Number of words used"
              }
            ],
            "correct": "b",
            "explanation": "Boolean - can we successfully segment the first i characters?",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i] is True if:",
            "options": [
              {
                "id": "a",
                "text": "s[0:i] is in dictionary"
              },
              {
                "id": "b",
                "text": "For some j, dp[j] is True AND s[j:i] is in dictionary"
              },
              {
                "id": "c",
                "text": "s[i-1:i] is in dictionary"
              },
              {
                "id": "d",
                "text": "All characters are in dictionary"
              }
            ],
            "correct": "b",
            "explanation": "If we can segment s[0:j], and s[j:i] is a word, then s[0:i] is segmentable.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0] should be:",
            "options": [
              {
                "id": "a",
                "text": "False"
              },
              {
                "id": "b",
                "text": "True"
              },
              {
                "id": "c",
                "text": "Depends on first character"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "Empty string is \"trivially\" segmented. Needed for recurrence.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For dp[i], we check j from:",
            "options": [
              {
                "id": "a",
                "text": "0 to i-1"
              },
              {
                "id": "b",
                "text": "i-1 to 0"
              },
              {
                "id": "c",
                "text": "Only j = i-1"
              },
              {
                "id": "d",
                "text": "Random order"
              }
            ],
            "correct": "a",
            "explanation": "Try all possible \"last word\" lengths. Either order works, but forward is typical.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "We can optimize by:",
            "options": [
              {
                "id": "a",
                "text": "Using a set for wordDict"
              },
              {
                "id": "b",
                "text": "Only checking j where (i-j) ≤ max word length"
              },
              {
                "id": "c",
                "text": "Breaking early when dp[i] becomes True"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Set for O(1) lookup, limit j range by max word length, early exit.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "dp[i] = can s[0:i] be segmented? True if for any j < i, dp[j] is True AND s[j:i] is in dictionary.",
        "pattern": "1D Dynamic Programming",
        "keyInsight": "dp[i] = can s[0:i] be segmented? Check all possible last words.",
        "timeComplexity": "O(n² × m)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "word break",
          "1d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def wordBreak(s: str, wordDict: List[str]) -> bool:\n    word_set = set(wordDict)\n    n = len(s)\n    \n    # dp[i] = can s[0:i] be segmented?\n    dp = [False] * (n + 1)\n    dp[0] = True  # Empty string\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            # If s[0:j] can be segmented and s[j:i] is a word\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[n]"
      }
    ],
    "2d-dp": [
      {
        "id": "01-unique-paths",
        "slug": "unique-paths",
        "title": "Unique Paths",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "unique-paths"
        ],
        "estimatedTime": 5,
        "problemStatement": "There is a robot on an `m x n` grid. The robot is initially located at the top-left corner (i.e., `grid[0][0]`). The robot tries to move to the bottom-right corner (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
        "examples": [
          {
            "input": "m = 3, n = 7",
            "output": "28",
            "explanation": ""
          },
          {
            "input": "m = 3, n = 2",
            "output": "3",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To reach cell (i, j), you came from:",
            "options": [
              {
                "id": "a",
                "text": "(i-1, j) only"
              },
              {
                "id": "b",
                "text": "(i, j-1) only"
              },
              {
                "id": "c",
                "text": "(i-1, j) or (i, j-1)"
              },
              {
                "id": "d",
                "text": "Any adjacent cell"
              }
            ],
            "correct": "c",
            "explanation": "Can only move right or down. So you arrived from above or from left.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] = ?",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1][j] × dp[i][j-1]"
              },
              {
                "id": "b",
                "text": "dp[i-1][j] + dp[i][j-1]"
              },
              {
                "id": "c",
                "text": "max(dp[i-1][j], dp[i][j-1])"
              },
              {
                "id": "d",
                "text": "min(dp[i-1][j], dp[i][j-1])"
              }
            ],
            "correct": "b",
            "explanation": "Total ways = ways from top + ways from left.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For cells in the first row (i=0):",
            "options": [
              {
                "id": "a",
                "text": "dp[0][j] = 0"
              },
              {
                "id": "b",
                "text": "dp[0][j] = 1"
              },
              {
                "id": "c",
                "text": "dp[0][j] = j"
              },
              {
                "id": "d",
                "text": "dp[0][j] = j + 1"
              }
            ],
            "correct": "b",
            "explanation": "Only one way to reach any cell in first row: keep going right.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "For cells in the first column (j=0):",
            "options": [
              {
                "id": "a",
                "text": "dp[i][0] = 0"
              },
              {
                "id": "b",
                "text": "dp[i][0] = 1"
              },
              {
                "id": "c",
                "text": "dp[i][0] = i"
              },
              {
                "id": "d",
                "text": "dp[i][0] = i + 1"
              }
            ],
            "correct": "b",
            "explanation": "Only one way to reach any cell in first column: keep going down.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "We can reduce space to O(n) because:",
            "options": [
              {
                "id": "a",
                "text": "We only need the previous row"
              },
              {
                "id": "b",
                "text": "We only need diagonal"
              },
              {
                "id": "c",
                "text": "We don't need any previous values"
              },
              {
                "id": "d",
                "text": "Grid is symmetric"
              }
            ],
            "correct": "a",
            "explanation": "Each row only depends on the row above it.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "dp[i][j] = dp[i-1][j] + dp[i][j-1]. First row and column are all 1s. Or use combinatorics: C(m+n-2, m-1).",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "To reach cell (i,j), you either came from (i-1,j) or (i,j-1).",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "unique paths",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def uniquePaths(m: int, n: int) -> int:\n    # Space-optimized 1D DP\n    dp = [1] * n\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            dp[j] += dp[j - 1]\n    \n    return dp[n - 1]"
      },
      {
        "id": "02-longest-common-subsequence",
        "slug": "longest-common-subsequence",
        "title": "Longest Common Subsequence",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "longest-common-subsequence"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `text1` and `text2`, return the length of their longest common subsequence. If there is no common subsequence, return `0`.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",
        "examples": [
          {
            "input": "text1 = \"abcde\", text2 = \"ace\"",
            "output": "3",
            "explanation": "The longest common subsequence is \"ace\"."
          },
          {
            "input": "text1 = \"abc\", text2 = \"abc\"",
            "output": "3",
            "explanation": ""
          },
          {
            "input": "text1 = \"abc\", text2 = \"def\"",
            "output": "0",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If text1[i-1] == text2[j-1], then:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j] = dp[i-1][j-1]"
              },
              {
                "id": "b",
                "text": "dp[i][j] = dp[i-1][j-1] + 1"
              },
              {
                "id": "c",
                "text": "dp[i][j] = dp[i-1][j] + dp[i][j-1]"
              },
              {
                "id": "d",
                "text": "dp[i][j] = 1"
              }
            ],
            "correct": "b",
            "explanation": "Matching characters extend the LCS by 1.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If text1[i-1] != text2[j-1], then:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j] = 0"
              },
              {
                "id": "b",
                "text": "dp[i][j] = dp[i-1][j-1]"
              },
              {
                "id": "c",
                "text": "dp[i][j] = max(dp[i-1][j], dp[i][j-1])"
              },
              {
                "id": "d",
                "text": "dp[i][j] = dp[i-1][j] + dp[i][j-1]"
              }
            ],
            "correct": "c",
            "explanation": "Characters don't match, so skip one character from either string. Take the better result.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0][j] and dp[i][0] should be:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "-1"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "a",
            "explanation": "Empty string has no common subsequence with anything. LCS = 0.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "When chars don't match, we try both dp[i-1][j] and dp[i][j-1] because:",
            "options": [
              {
                "id": "a",
                "text": "The optimal LCS might not include text1[i-1]"
              },
              {
                "id": "b",
                "text": "The optimal LCS might not include text2[j-1]"
              },
              {
                "id": "c",
                "text": "We don't know which exclusion leads to longer LCS"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Either character might be useless for the LCS. Try excluding each.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] represents LCS of:",
            "options": [
              {
                "id": "a",
                "text": "text1[0:i] and text2[0:j]"
              },
              {
                "id": "b",
                "text": "text1[i:] and text2[j:]"
              },
              {
                "id": "c",
                "text": "text1[i] and text2[j] only"
              },
              {
                "id": "d",
                "text": "First i and j characters respectively"
              }
            ],
            "correct": "a",
            "explanation": "1-indexed DP where dp[i][j] = LCS of first i chars of text1, first j chars of text2.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Match → dp[i-1][j-1] + 1. No match → max(dp[i-1][j], dp[i][j-1]). Classic 2D DP on two strings.",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "If characters match, extend LCS by 1. Otherwise, take max of excluding each character.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "longest common subsequence",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    \n    # Space-optimized: only need previous row\n    prev = [0] * (n + 1)\n    \n    for i in range(1, m + 1):\n        curr = [0] * (n + 1)\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                curr[j] = prev[j - 1] + 1\n            else:\n                curr[j] = max(prev[j], curr[j - 1])\n        prev = curr\n    \n    return prev[n]"
      },
      {
        "id": "03-best-time-to-buy-and-sell-stock-with-cooldown",
        "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "best-time-to-buy-and-sell-stock-with-cooldown"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n- After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "examples": [
          {
            "input": "prices = [1,2,3,0,2]",
            "output": "3",
            "explanation": "transactions = [buy, sell, cooldown, buy, sell]"
          },
          {
            "input": "prices = [1]",
            "output": "0",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At any day, you can be in state:",
            "options": [
              {
                "id": "a",
                "text": "Holding stock"
              },
              {
                "id": "b",
                "text": "Just sold (cooldown)"
              },
              {
                "id": "c",
                "text": "Resting (no stock, ready to buy)"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Three states capture all situations.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you're holding stock today, tomorrow you can:",
            "options": [
              {
                "id": "a",
                "text": "Keep holding"
              },
              {
                "id": "b",
                "text": "Sell (go to \"sold\" state)"
              },
              {
                "id": "c",
                "text": "Buy more"
              },
              {
                "id": "d",
                "text": "A and B only"
              }
            ],
            "correct": "d",
            "explanation": "Either keep holding or sell. Can't buy more (already holding).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you just sold today, tomorrow you MUST:",
            "options": [
              {
                "id": "a",
                "text": "Buy"
              },
              {
                "id": "b",
                "text": "Sell again"
              },
              {
                "id": "c",
                "text": "Rest (cooldown)"
              },
              {
                "id": "d",
                "text": "Any action"
              }
            ],
            "correct": "c",
            "explanation": "Cooldown forces you to rest the day after selling.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If you're resting (no stock, not in cooldown), tomorrow you can:",
            "options": [
              {
                "id": "a",
                "text": "Buy"
              },
              {
                "id": "b",
                "text": "Keep resting"
              },
              {
                "id": "c",
                "text": "Sell"
              },
              {
                "id": "d",
                "text": "A and B only"
              }
            ],
            "correct": "d",
            "explanation": "Can buy or continue resting. Can't sell (no stock).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "hold[i] = max(hold[i-1], rest[i-1] - prices[i])\\nsold[i] = hold[i-1] + prices[i]\\nrest[i] = max(rest[i-1], sold[i-1])\\n\\nThe pattern is:",
            "options": [
              {
                "id": "a",
                "text": "Each state updates from previous states"
              },
              {
                "id": "b",
                "text": "Cooldown is encoded in sold→rest transition"
              },
              {
                "id": "c",
                "text": "Both"
              }
            ],
            "correct": "c",
            "explanation": "State machine DP where each state has specific transitions.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "State machine with 3 states: hold, sold (cooldown), rest. Sold must go to rest. Rest can go to hold. Each day update all states.",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "State machine: track whether you're holding stock or not, and if you just sold.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "best time to buy and sell stock with cooldown",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxProfit(prices: List[int]) -> int:\n    if not prices:\n        return 0\n    \n    # State machine: hold, sold, rest\n    hold = -prices[0]  # Bought stock\n    sold = 0           # Just sold (cooldown next)\n    rest = 0           # Resting (can buy)\n    \n    for i in range(1, len(prices)):\n        prev_hold = hold\n        hold = max(hold, rest - prices[i])  # Keep or buy\n        rest = max(rest, sold)              # Keep resting or cooldown done\n        sold = prev_hold + prices[i]        # Sell\n    \n    return max(sold, rest)"
      },
      {
        "id": "04-coin-change-ii",
        "slug": "coin-change-ii",
        "title": "Coin Change II",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "coin-change-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return `0`.\n\nYou may assume that you have an infinite number of each kind of coin.",
        "examples": [
          {
            "input": "amount = 5, coins = [1, 2, 5]",
            "output": "4",
            "explanation": "5=5, 5=2+2+1, 5=2+1+1+1, 5=1+1+1+1+1"
          },
          {
            "input": "amount = 3, coins = [2]",
            "output": "0",
            "explanation": ""
          },
          {
            "input": "amount = 10, coins = [10]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Why is this different from \"ways to reach amount\"?",
            "options": [
              {
                "id": "a",
                "text": "[1,2] and [2,1] are different in climbing stairs"
              },
              {
                "id": "b",
                "text": "[1,2] and [2,1] are same combination here"
              },
              {
                "id": "c",
                "text": "We need combinations, not permutations"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Order matters in permutations (stairs), not in combinations (coins).",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "To count combinations only:",
            "options": [
              {
                "id": "a",
                "text": "Process amounts first, coins second (permutations)"
              },
              {
                "id": "b",
                "text": "Process coins first, amounts second (combinations)"
              },
              {
                "id": "c",
                "text": "Order doesn't matter"
              },
              {
                "id": "d",
                "text": "Use recursion only"
              }
            ],
            "correct": "b",
            "explanation": "Process each coin completely before moving to next. Ensures each combination counted once.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Outer loop on coins ensures:",
            "options": [
              {
                "id": "a",
                "text": "Each coin used at most once"
              },
              {
                "id": "b",
                "text": "Combinations like [1,2] and [2,1] counted once"
              },
              {
                "id": "c",
                "text": "Smaller coins first"
              },
              {
                "id": "d",
                "text": "Faster computation"
              }
            ],
            "correct": "b",
            "explanation": "By fixing coin order (coin1, then coin2, ...), we only count [coin1, coin1, coin2], never [coin2, coin1, coin1].",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[j] after considering coin:",
            "options": [
              {
                "id": "a",
                "text": "dp[j] + dp[j - coin]"
              },
              {
                "id": "b",
                "text": "dp[j] * dp[j - coin]"
              },
              {
                "id": "c",
                "text": "max(dp[j], dp[j - coin])"
              },
              {
                "id": "d",
                "text": "dp[j - coin] only"
              }
            ],
            "correct": "a",
            "explanation": "Ways without this coin + ways using at least one of this coin.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0] should be:",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "Number of coins"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "One way to make amount 0: use no coins.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Unbounded knapsack for counting. Outer loop on coins (not amounts) ensures combinations, not permutations. dp[j] += dp[j - coin].",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "Process coins one at a time to avoid counting permutations.",
        "timeComplexity": "O(amount × coins)",
        "spaceComplexity": "O(amount)",
        "triggerWords": [
          "coin change ii",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def change(amount: int, coins: List[int]) -> int:\n    dp = [0] * (amount + 1)\n    dp[0] = 1  # One way to make 0: use nothing\n    \n    # Outer loop on coins = combinations (not permutations)\n    for coin in coins:\n        for j in range(coin, amount + 1):\n            dp[j] += dp[j - coin]\n    \n    return dp[amount]"
      },
      {
        "id": "05-target-sum",
        "slug": "target-sum",
        "title": "Target Sum",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "target-sum"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `nums` and an integer `target`.\n\nYou want to build an expression out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.\n\nReturn the number of different expressions that you can build, which evaluates to `target`.",
        "examples": [
          {
            "input": "nums = [1,1,1,1,1], target = 3",
            "output": "5",
            "explanation": ""
          },
          {
            "input": "nums = [1], target = 1",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Assigning +/- splits numbers into:",
            "options": [
              {
                "id": "a",
                "text": "Two equal groups"
              },
              {
                "id": "b",
                "text": "Positive group P and negative group N"
              },
              {
                "id": "c",
                "text": "Odd and even groups"
              },
              {
                "id": "d",
                "text": "Random groups"
              }
            ],
            "correct": "b",
            "explanation": "Numbers with + form P, numbers with - form N.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If P = sum of positive, N = sum of negative:",
            "options": [
              {
                "id": "a",
                "text": "P - N = target AND P + N = sum"
              },
              {
                "id": "b",
                "text": "P + N = target"
              },
              {
                "id": "c",
                "text": "P - N = sum"
              },
              {
                "id": "d",
                "text": "P × N = target"
              }
            ],
            "correct": "a",
            "explanation": "P - N gives target. P + N = total sum of all numbers.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "From P - N = target and P + N = sum:",
            "options": [
              {
                "id": "a",
                "text": "P = (sum + target) / 2"
              },
              {
                "id": "b",
                "text": "P = (sum - target) / 2"
              },
              {
                "id": "c",
                "text": "P = sum + target"
              },
              {
                "id": "d",
                "text": "P = target / 2"
              }
            ],
            "correct": "a",
            "explanation": "Adding equations: 2P = sum + target, so P = (sum + target) / 2.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "No solution exists if:",
            "options": [
              {
                "id": "a",
                "text": "(sum + target) is odd"
              },
              {
                "id": "b",
                "text": "|target| > sum"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "P must be integer (odd sum+target is impossible). Target beyond range is impossible.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "This becomes:",
            "options": [
              {
                "id": "a",
                "text": "Coin Change"
              },
              {
                "id": "b",
                "text": "Subset Sum counting"
              },
              {
                "id": "c",
                "text": "LCS"
              },
              {
                "id": "d",
                "text": "Knapsack"
              }
            ],
            "correct": "b",
            "explanation": "Count subsets with sum = (sum + target) / 2.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Transform: P - N = target, P + N = sum → P = (sum+target)/2. Count subsets summing to P. Classic 0/1 knapsack with reverse loop.",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "Split into two groups: positive (P) and negative (N). P - N = target, P + N = sum. Solve for P.",
        "timeComplexity": "O(n × sum)",
        "spaceComplexity": "O(sum)",
        "triggerWords": [
          "target sum",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def findTargetSumWays(nums: List[int], target: int) -> int:\n    total = sum(nums)\n    \n    # P - N = target, P + N = total\n    # 2P = total + target, P = (total + target) / 2\n    if (total + target) % 2 != 0 or abs(target) > total:\n        return 0\n    \n    P = (total + target) // 2\n    \n    # Count subsets summing to P (0/1 knapsack)\n    dp = [0] * (P + 1)\n    dp[0] = 1\n    \n    for num in nums:\n        for j in range(P, num - 1, -1):  # Reverse to avoid reuse\n            dp[j] += dp[j - num]\n    \n    return dp[P]"
      },
      {
        "id": "06-interleaving-string",
        "slug": "interleaving-string",
        "title": "Interleaving String",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "interleaving-string"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an interleaving of `s1` and `s2`.\n\nAn interleaving of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that:\n\n- `s = s1 + s2 + ... + sn`\n- `t = t1 + t2 + ... + tm`\n- `|n - m| <= 1`\n- The interleaving is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`",
        "examples": [
          {
            "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
            "output": "true",
            "explanation": "One way: aa + dbbc + bc + a + c"
          },
          {
            "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If len(s1) + len(s2) != len(s3):",
            "options": [
              {
                "id": "a",
                "text": "Might still work"
              },
              {
                "id": "b",
                "text": "Definitely impossible"
              },
              {
                "id": "c",
                "text": "Need more checking"
              },
              {
                "id": "d",
                "text": "Only works for empty strings"
              }
            ],
            "correct": "b",
            "explanation": "Interleaving uses all characters from both strings exactly once.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] represents:",
            "options": [
              {
                "id": "a",
                "text": "LCS of s1[0:i] and s2[0:j]"
              },
              {
                "id": "b",
                "text": "Whether s1[0:i] + s2[0:j] equals s3[0:i+j]"
              },
              {
                "id": "c",
                "text": "Whether s1[0:i] and s2[0:j] can interleave to form s3[0:i+j]"
              },
              {
                "id": "d",
                "text": "Number of interleavings"
              }
            ],
            "correct": "c",
            "explanation": "Boolean - can we form s3[0:i+j] using exactly i chars from s1 and j chars from s2.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] is True if:",
            "options": [
              {
                "id": "a",
                "text": "dp[i-1][j] and s1[i-1] == s3[i+j-1]"
              },
              {
                "id": "b",
                "text": "dp[i][j-1] and s2[j-1] == s3[i+j-1]"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "Both A and B must be true"
              }
            ],
            "correct": "c",
            "explanation": "s3[i+j-1] came from either s1[i-1] or s2[j-1]. Either path works.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0][0] should be:",
            "options": [
              {
                "id": "a",
                "text": "False"
              },
              {
                "id": "b",
                "text": "True"
              },
              {
                "id": "c",
                "text": "Depends on s3"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "Empty strings interleave to form empty string.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[0][j] is True if:",
            "options": [
              {
                "id": "a",
                "text": "s2[0:j] == s3[0:j]"
              },
              {
                "id": "b",
                "text": "Always True"
              },
              {
                "id": "c",
                "text": "Always False"
              },
              {
                "id": "d",
                "text": "Random"
              }
            ],
            "correct": "a",
            "explanation": "Using 0 chars from s1, j chars from s2 must exactly match s3[0:j].",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "dp[i][j] = can s1[0:i] and s2[0:j] interleave to form s3[0:i+j]? Transition: next char in s3 comes from s1 or s2.",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "dp[i][j] = can first i chars of s1 and first j chars of s2 form first i+j chars of s3?",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "interleaving string",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isInterleave(s1: str, s2: str, s3: str) -> bool:\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n    \n    # Space-optimized 1D DP\n    dp = [False] * (n + 1)\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 and j == 0:\n                dp[j] = True\n            elif i == 0:\n                dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n            elif j == 0:\n                dp[j] = dp[j] and s1[i - 1] == s3[i - 1]\n            else:\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or \\\n                        (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n    \n    return dp[n]"
      },
      {
        "id": "07-edit-distance",
        "slug": "edit-distance",
        "title": "Edit Distance",
        "category": "2d-dp",
        "difficulty": "medium",
        "tags": [
          "2d-dp",
          "edit-distance"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have the following three operations permitted on a word:\n- Insert a character\n- Delete a character\n- Replace a character",
        "examples": [
          {
            "input": "word1 = \"horse\", word2 = \"ros\"",
            "output": "3",
            "explanation": "horse → rorse (replace 'h' with 'r')"
          },
          {
            "input": "word1 = \"intention\", word2 = \"execution\"",
            "output": "5",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If word1[i-1] == word2[j-1]:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j] = dp[i-1][j-1]"
              },
              {
                "id": "b",
                "text": "dp[i][j] = dp[i-1][j-1] + 1"
              },
              {
                "id": "c",
                "text": "dp[i][j] = 0"
              },
              {
                "id": "d",
                "text": "dp[i][j] = min of three operations"
              }
            ],
            "correct": "a",
            "explanation": "Characters match, no operation needed. Same as previous state.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Inserting into word1 corresponds to:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j-1] + 1"
              },
              {
                "id": "b",
                "text": "dp[i-1][j] + 1"
              },
              {
                "id": "c",
                "text": "dp[i-1][j-1] + 1"
              },
              {
                "id": "d",
                "text": "dp[i][j] + 1"
              }
            ],
            "correct": "a",
            "explanation": "Insert char to match word2[j-1]. Now need to match word1[0:i] with word2[0:j-1].",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Deleting from word1 corresponds to:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j-1] + 1"
              },
              {
                "id": "b",
                "text": "dp[i-1][j] + 1"
              },
              {
                "id": "c",
                "text": "dp[i-1][j-1] + 1"
              },
              {
                "id": "d",
                "text": "dp[i][j] - 1"
              }
            ],
            "correct": "b",
            "explanation": "Delete word1[i-1]. Now need to match word1[0:i-1] with word2[0:j].",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "Replacing in word1 corresponds to:",
            "options": [
              {
                "id": "a",
                "text": "dp[i][j-1] + 1"
              },
              {
                "id": "b",
                "text": "dp[i-1][j] + 1"
              },
              {
                "id": "c",
                "text": "dp[i-1][j-1] + 1"
              },
              {
                "id": "d",
                "text": "dp[i-1][j-1]"
              }
            ],
            "correct": "c",
            "explanation": "Replace word1[i-1] with word2[j-1]. Both chars now \"match\" (handled). Move diagonally.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][0] and dp[0][j] are:",
            "options": [
              {
                "id": "a",
                "text": "All 0"
              },
              {
                "id": "b",
                "text": "dp[i][0] = i, dp[0][j] = j"
              },
              {
                "id": "c",
                "text": "All 1"
              },
              {
                "id": "d",
                "text": "Undefined"
              }
            ],
            "correct": "b",
            "explanation": "Transform word1[0:i] to empty = i deletions. Transform empty to word2[0:j] = j insertions.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Match → dp[i-1][j-1]. No match → 1 + min(insert dp[i][j-1], delete dp[i-1][j], replace dp[i-1][j-1]).",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "If characters match, no operation needed. Otherwise, try all three operations and take minimum.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "edit distance",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    \n    # Space-optimized: only need previous row\n    prev = list(range(n + 1))  # Base: dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        curr = [i] + [0] * n  # Base: dp[i][0] = i\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                curr[j] = prev[j - 1]\n            else:\n                curr[j] = 1 + min(\n                    curr[j - 1],   # Insert\n                    prev[j],       # Delete\n                    prev[j - 1]    # Replace\n                )\n        prev = curr\n    \n    return prev[n]"
      },
      {
        "id": "08-burst-balloons",
        "slug": "burst-balloons",
        "title": "Burst Balloons",
        "category": "2d-dp",
        "difficulty": "hard",
        "tags": [
          "2d-dp",
          "burst-balloons"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn the maximum coins you can collect by bursting the balloons wisely.",
        "examples": [
          {
            "input": "nums = [3,1,5,8]",
            "output": "167",
            "explanation": ""
          },
          {
            "input": "nums = [1,5]",
            "output": "10",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Thinking \"which balloon to burst first\" is hard because:",
            "options": [
              {
                "id": "a",
                "text": "Adjacent balloons change after each burst"
              },
              {
                "id": "b",
                "text": "Subproblems aren't independent"
              },
              {
                "id": "c",
                "text": "Can't use DP easily"
              },
              {
                "id": "d",
                "text": "A and B"
              }
            ],
            "correct": "d",
            "explanation": "After bursting, neighbors change. Left and right subproblems depend on what was burst.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "\"Which balloon to burst LAST in range\" works because:",
            "options": [
              {
                "id": "a",
                "text": "The last balloon sees the boundary balloons"
              },
              {
                "id": "b",
                "text": "Left and right subproblems become independent"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "It doesn't work"
              }
            ],
            "correct": "c",
            "explanation": "If k is last in (i,j), left side (i,k) and right side (k,j) are solved independently first.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "If balloon k is burst last in range (i, j):",
            "options": [
              {
                "id": "a",
                "text": "Coins = nums[i] * nums[k] * nums[j]"
              },
              {
                "id": "b",
                "text": "Coins = nums[k-1] * nums[k] * nums[k+1]"
              },
              {
                "id": "c",
                "text": "Coins = nums[k] only"
              },
              {
                "id": "d",
                "text": "Depends on order"
              }
            ],
            "correct": "a",
            "explanation": "When k is last, all others are gone. k sees boundaries i and j.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] represents:",
            "options": [
              {
                "id": "a",
                "text": "Max coins for bursting balloons in original range"
              },
              {
                "id": "b",
                "text": "Max coins for balloons between indices i and j (exclusive)"
              },
              {
                "id": "c",
                "text": "Number of balloons"
              },
              {
                "id": "d",
                "text": "Min coins"
              }
            ],
            "correct": "b",
            "explanation": "Range (i, j) means balloons from i+1 to j-1. Boundaries i and j remain.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "dp[i][j] = max over k of:",
            "options": [
              {
                "id": "a",
                "text": "nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j]"
              },
              {
                "id": "b",
                "text": "dp[i][k] * dp[k][j]"
              },
              {
                "id": "c",
                "text": "nums[k] + dp[i][k] + dp[k][j]"
              },
              {
                "id": "d",
                "text": "max(dp[i][k], dp[k][j])"
              }
            ],
            "correct": "a",
            "explanation": "Burst k last (gets i*k*j coins), plus best for left and right subranges.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "Think backwards: which balloon k is burst LAST in range (i,j)? It sees boundaries i,j. Coins = nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j].",
        "pattern": "2D Dynamic Programming",
        "keyInsight": "Think backwards: which balloon is burst LAST in a range?",
        "timeComplexity": "O(n³)",
        "spaceComplexity": "O(n²)",
        "triggerWords": [
          "burst balloons",
          "2d-dp"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxCoins(nums: List[int]) -> int:\n    # Add boundary balloons with value 1\n    nums = [1] + nums + [1]\n    n = len(nums)\n    \n    # dp[i][j] = max coins for range (i, j) exclusive\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill by increasing range length\n    for length in range(2, n):  # length = j - i\n        for i in range(n - length):\n            j = i + length\n            # Try each k as last balloon to burst in (i, j)\n            for k in range(i + 1, j):\n                coins = nums[i] * nums[k] * nums[j]\n                dp[i][j] = max(dp[i][j], dp[i][k] + coins + dp[k][j])\n    \n    return dp[0][n - 1]"
      }
    ],
    "greedy": [
      {
        "id": "01-maximum-subarray",
        "slug": "maximum-subarray",
        "title": "Maximum Subarray",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "maximum-subarray"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.",
        "examples": [
          {
            "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
            "output": "6",
            "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
          },
          {
            "input": "nums = [1]",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "nums = [5,4,-1,7,8]",
            "output": "23",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At each element, we decide:",
            "options": [
              {
                "id": "a",
                "text": "Include in current subarray or start new"
              },
              {
                "id": "b",
                "text": "Skip or include"
              },
              {
                "id": "c",
                "text": "Add or subtract"
              },
              {
                "id": "d",
                "text": "Left or right"
              }
            ],
            "correct": "a",
            "explanation": "Either extend current subarray or this element starts a new one.",
            "conceptId": "kadane"
          },
          {
            "type": "mcq",
            "question": "We start a new subarray at nums[i] when:",
            "options": [
              {
                "id": "a",
                "text": "nums[i] is positive"
              },
              {
                "id": "b",
                "text": "current_sum + nums[i] < nums[i]"
              },
              {
                "id": "c",
                "text": "nums[i] is the largest"
              },
              {
                "id": "d",
                "text": "i is even"
              }
            ],
            "correct": "b",
            "explanation": "If adding to current sum makes it worse than just nums[i], start fresh.",
            "conceptId": "kadane"
          },
          {
            "type": "mcq",
            "question": "current_sum + nums[i] < nums[i] simplifies to:",
            "options": [
              {
                "id": "a",
                "text": "current_sum < 0"
              },
              {
                "id": "b",
                "text": "nums[i] < 0"
              },
              {
                "id": "c",
                "text": "current_sum > nums[i]"
              },
              {
                "id": "d",
                "text": "Always true"
              }
            ],
            "correct": "a",
            "explanation": "Subtract nums[i] from both sides: current_sum < 0.",
            "conceptId": "kadane"
          },
          {
            "type": "mcq",
            "question": "We need to track:",
            "options": [
              {
                "id": "a",
                "text": "Current running sum"
              },
              {
                "id": "b",
                "text": "Maximum sum seen so far"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Current sum for building subarray, max sum for the answer.",
            "conceptId": "kadane"
          },
          {
            "type": "mcq",
            "question": "For [-3, -1, -2]:",
            "options": [
              {
                "id": "a",
                "text": "Return 0"
              },
              {
                "id": "b",
                "text": "Return -1 (largest single element)"
              },
              {
                "id": "c",
                "text": "Return -6"
              },
              {
                "id": "d",
                "text": "Return empty"
              }
            ],
            "correct": "b",
            "explanation": "Must have at least one element. Best is the largest (least negative).",
            "conceptId": "kadane"
          }
        ],
        "oneLiner": "Kadane's: current_sum = max(nums[i], current_sum + nums[i]). If current sum is negative, start fresh.",
        "pattern": "Greedy",
        "keyInsight": "Kadane's Algorithm: If current sum becomes negative, start fresh.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "maximum subarray",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def maxSubArray(nums: List[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        # Either extend current subarray or start new\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"
      },
      {
        "id": "02-jump-game",
        "slug": "jump-game",
        "title": "Jump Game",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "jump-game"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` if you can reach the last index, or `false` otherwise.",
        "examples": [
          {
            "input": "nums = [2,3,1,1,4]",
            "output": "true",
            "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
          },
          {
            "input": "nums = [3,2,1,0,4]",
            "output": "false",
            "explanation": "You will always arrive at index 3 whose value is 0."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "At position i, you can jump to:",
            "options": [
              {
                "id": "a",
                "text": "Exactly i + nums[i]"
              },
              {
                "id": "b",
                "text": "Any position from i+1 to i + nums[i]"
              },
              {
                "id": "c",
                "text": "Only i + 1"
              },
              {
                "id": "d",
                "text": "Anywhere"
              }
            ],
            "correct": "b",
            "explanation": "nums[i] is MAXIMUM jump. You can jump 1, 2, ..., up to nums[i] steps.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We greedily track:",
            "options": [
              {
                "id": "a",
                "text": "Number of jumps"
              },
              {
                "id": "b",
                "text": "Farthest reachable index"
              },
              {
                "id": "c",
                "text": "Current position"
              },
              {
                "id": "d",
                "text": "All reachable positions"
              }
            ],
            "correct": "b",
            "explanation": "If farthest_reachable >= last_index, we can reach the end.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "At position i, update farthest to:",
            "options": [
              {
                "id": "a",
                "text": "i + nums[i]"
              },
              {
                "id": "b",
                "text": "max(farthest, i + nums[i])"
              },
              {
                "id": "c",
                "text": "farthest + nums[i]"
              },
              {
                "id": "d",
                "text": "nums[i]"
              }
            ],
            "correct": "b",
            "explanation": "Farthest is the max of previous farthest and what we can reach from i.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We can't reach the end if:",
            "options": [
              {
                "id": "a",
                "text": "nums[i] = 0 at some point"
              },
              {
                "id": "b",
                "text": "i > farthest (we can't reach position i)"
              },
              {
                "id": "c",
                "text": "nums contains negative"
              },
              {
                "id": "d",
                "text": "Array is empty"
              }
            ],
            "correct": "b",
            "explanation": "If current position i is beyond farthest reachable, we're stuck.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We can return True early when:",
            "options": [
              {
                "id": "a",
                "text": "We see a large number"
              },
              {
                "id": "b",
                "text": "farthest >= last_index"
              },
              {
                "id": "c",
                "text": "We're past the midpoint"
              },
              {
                "id": "d",
                "text": "Never"
              }
            ],
            "correct": "b",
            "explanation": "If we can already reach or exceed the last index, we're done.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Track farthest reachable index. At each i, update farthest = max(farthest, i + nums[i]). If i > farthest, stuck.",
        "pattern": "Greedy",
        "keyInsight": "Track the farthest index you can reach. If you ever land on a position beyond your reach, return false.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "jump game",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def canJump(nums: List[int]) -> bool:\n    farthest = 0\n    \n    for i in range(len(nums)):\n        # Can't reach position i\n        if i > farthest:\n            return False\n        \n        farthest = max(farthest, i + nums[i])\n        \n        # Can reach the end\n        if farthest >= len(nums) - 1:\n            return True\n    \n    return True"
      },
      {
        "id": "03-jump-game-ii",
        "slug": "jump-game-ii",
        "title": "Jump Game II",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "jump-game-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a 0-indexed array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. Return the minimum number of jumps to reach `nums[n - 1]`.\n\nYou can assume that you can always reach `nums[n - 1]`.",
        "examples": [
          {
            "input": "nums = [2,3,1,1,4]",
            "output": "2",
            "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
          },
          {
            "input": "nums = [2,3,0,1,4]",
            "output": "2",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "This problem is like BFS where:",
            "options": [
              {
                "id": "a",
                "text": "Each position is a node"
              },
              {
                "id": "b",
                "text": "Jump count is the \"level\""
              },
              {
                "id": "c",
                "text": "We find shortest path to last index"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "BFS gives shortest path. \"Levels\" are positions reachable with same jump count.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We track:",
            "options": [
              {
                "id": "a",
                "text": "Current jump boundary (end of current level)"
              },
              {
                "id": "b",
                "text": "Farthest reachable in next level"
              },
              {
                "id": "c",
                "text": "Number of jumps"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Boundary tells when to increment jumps. Farthest becomes new boundary.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We increment jump count when:",
            "options": [
              {
                "id": "a",
                "text": "We see a large nums[i]"
              },
              {
                "id": "b",
                "text": "We reach the current boundary"
              },
              {
                "id": "c",
                "text": "nums[i] = 0"
              },
              {
                "id": "d",
                "text": "We're at odd index"
              }
            ],
            "correct": "b",
            "explanation": "Passing the boundary means we need another jump to go further.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "While traversing, farthest is updated to:",
            "options": [
              {
                "id": "a",
                "text": "max(farthest, i + nums[i])"
              },
              {
                "id": "b",
                "text": "i + nums[i] always"
              },
              {
                "id": "c",
                "text": "farthest + 1"
              },
              {
                "id": "d",
                "text": "end + nums[end]"
              }
            ],
            "correct": "a",
            "explanation": "Track the farthest we can reach from any position in current level.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We iterate i from 0 to:",
            "options": [
              {
                "id": "a",
                "text": "n - 1 (inclusive)"
              },
              {
                "id": "b",
                "text": "n - 2 (up to second-to-last)"
              },
              {
                "id": "c",
                "text": "n"
              },
              {
                "id": "d",
                "text": "Farthest"
              }
            ],
            "correct": "b",
            "explanation": "Don't need to process last index. If we reach it, we're done.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "BFS-like greedy: track current level's boundary. When you hit boundary, increment jumps and set new boundary to farthest reachable.",
        "pattern": "Greedy",
        "keyInsight": "BFS-like greedy: each \"level\" is all positions reachable with same number of jumps.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "jump game ii",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def jump(nums: List[int]) -> int:\n    n = len(nums)\n    if n <= 1:\n        return 0\n    \n    jumps = 0\n    end = 0       # Current level boundary\n    farthest = 0  # Farthest reachable in next level\n    \n    for i in range(n - 1):  # Don't need to process last index\n        farthest = max(farthest, i + nums[i])\n        \n        if i == end:  # Hit boundary, need another jump\n            jumps += 1\n            end = farthest\n    \n    return jumps"
      },
      {
        "id": "04-gas-station",
        "slug": "gas-station",
        "title": "Gas Station",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "gas-station"
        ],
        "estimatedTime": 5,
        "problemStatement": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return `-1`. If there exists a solution, it is guaranteed to be unique.",
        "examples": [
          {
            "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
            "output": "3",
            "explanation": "Start at station 3, tank = 4. Travel to station 4, tank = 4-1+5 = 8. Continue around."
          },
          {
            "input": "gas = [2,3,4], cost = [3,4,3]",
            "output": "-1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A solution exists if:",
            "options": [
              {
                "id": "a",
                "text": "gas[0] >= cost[0]"
              },
              {
                "id": "b",
                "text": "total_gas >= total_cost"
              },
              {
                "id": "c",
                "text": "max(gas) >= max(cost)"
              },
              {
                "id": "d",
                "text": "All gas[i] >= cost[i]"
              }
            ],
            "correct": "b",
            "explanation": "If total gas can cover total cost, you can complete the circuit from some starting point.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "At station i, the net effect is:",
            "options": [
              {
                "id": "a",
                "text": "gas[i] - cost[i]"
              },
              {
                "id": "b",
                "text": "gas[i] + cost[i]"
              },
              {
                "id": "c",
                "text": "gas[i] / cost[i]"
              },
              {
                "id": "d",
                "text": "cost[i] - gas[i]"
              }
            ],
            "correct": "a",
            "explanation": "You gain gas[i] but spend cost[i] to reach next station.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "If starting from station i, you can't reach station j (tank < 0):",
            "options": [
              {
                "id": "a",
                "text": "Try starting from i + 1"
              },
              {
                "id": "b",
                "text": "Station i is bad, try others"
              },
              {
                "id": "c",
                "text": "No station from i to j-1 can be the start"
              },
              {
                "id": "d",
                "text": "Start from j - 1"
              }
            ],
            "correct": "c",
            "explanation": "If you can't reach j from i with accumulated gas, you can't reach j from any station between i and j (you'd have less gas).",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When tank goes negative at station j:",
            "options": [
              {
                "id": "a",
                "text": "Start = j + 1, reset tank"
              },
              {
                "id": "b",
                "text": "Start = j, add more gas"
              },
              {
                "id": "c",
                "text": "Return -1 immediately"
              },
              {
                "id": "d",
                "text": "Skip station j"
              }
            ],
            "correct": "a",
            "explanation": "j and all stations before it in current attempt can't be the start. Try j+1.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "One pass is sufficient because:",
            "options": [
              {
                "id": "a",
                "text": "If total_gas >= total_cost, a valid start exists"
              },
              {
                "id": "b",
                "text": "We eliminate impossible starts greedily"
              },
              {
                "id": "c",
                "text": "The first valid start we find works"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Total check ensures solution. Greedy elimination finds it.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "If total_gas >= total_cost, solution exists. Greedily start from next station whenever tank goes negative. The last valid start is the answer.",
        "pattern": "Greedy",
        "keyInsight": "If total gas >= total cost, solution exists. If you can't reach station j from station i, start from j+1.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "gas station",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    # Check if solution exists\n    if sum(gas) < sum(cost):\n        return -1\n    \n    start = 0\n    tank = 0\n    \n    for i in range(len(gas)):\n        tank += gas[i] - cost[i]\n        \n        if tank < 0:  # Can't reach next station\n            start = i + 1  # Try starting from next\n            tank = 0\n    \n    return start"
      },
      {
        "id": "05-hand-of-straights",
        "slug": "hand-of-straights",
        "title": "Hand of Straights",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "hand-of-straights"
        ],
        "estimatedTime": 5,
        "problemStatement": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size `groupSize`, and consists of `groupSize` consecutive cards.\n\nGiven an integer array `hand` where `hand[i]` is the value written on the `ith` card and an integer `groupSize`, return `true` if she can rearrange the cards, or `false` otherwise.",
        "examples": [
          {
            "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
            "output": "true",
            "explanation": "[1,2,3], [2,3,4], [6,7,8]"
          },
          {
            "input": "hand = [1,2,3,4,5], groupSize = 4",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If len(hand) % groupSize != 0:",
            "options": [
              {
                "id": "a",
                "text": "Might still work"
              },
              {
                "id": "b",
                "text": "Definitely impossible"
              },
              {
                "id": "c",
                "text": "Always possible"
              },
              {
                "id": "d",
                "text": "Need more info"
              }
            ],
            "correct": "b",
            "explanation": "Can't divide cards evenly into groups.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "The smallest card must:",
            "options": [
              {
                "id": "a",
                "text": "Be skipped sometimes"
              },
              {
                "id": "b",
                "text": "Start some group"
              },
              {
                "id": "c",
                "text": "End some group"
              },
              {
                "id": "d",
                "text": "Be in the middle"
              }
            ],
            "correct": "b",
            "explanation": "No smaller card exists to have it continue a sequence. It must be a group's start.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "Best data structure for this problem:",
            "options": [
              {
                "id": "a",
                "text": "Array"
              },
              {
                "id": "b",
                "text": "Hash map (count of each card)"
              },
              {
                "id": "c",
                "text": "Linked list"
              },
              {
                "id": "d",
                "text": "Binary tree"
              }
            ],
            "correct": "b",
            "explanation": "Need to track how many of each card remain, efficiently check and decrement.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "We should process cards:",
            "options": [
              {
                "id": "a",
                "text": "In any order"
              },
              {
                "id": "b",
                "text": "In sorted order (smallest first)"
              },
              {
                "id": "c",
                "text": "Largest first"
              },
              {
                "id": "d",
                "text": "Random order"
              }
            ],
            "correct": "b",
            "explanation": "Smallest must start a group. After using it, the next smallest becomes the new \"must start\".",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When starting a group at card x:",
            "options": [
              {
                "id": "a",
                "text": "Need exactly x, x+1, ..., x+groupSize-1"
              },
              {
                "id": "b",
                "text": "Any groupSize cards work"
              },
              {
                "id": "c",
                "text": "Need x and any larger cards"
              },
              {
                "id": "d",
                "text": "Need x repeated groupSize times"
              }
            ],
            "correct": "a",
            "explanation": "Consecutive means exactly x, x+1, x+2, etc.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Greedy: smallest card must start a group. Process sorted cards, form groups of consecutive numbers, decrement counts. Fail if any needed card is missing.",
        "pattern": "Greedy",
        "keyInsight": "Greedy: always start a group with the smallest available card.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "hand of straights",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isNStraightHand(hand: List[int], groupSize: int) -> bool:\n    if len(hand) % groupSize != 0:\n        return False\n    \n    count = Counter(hand)\n    \n    for card in sorted(count):\n        if count[card] > 0:  # Start a group\n            need = count[card]\n            # Need consecutive cards\n            for i in range(groupSize):\n                if count[card + i] < need:\n                    return False\n                count[card + i] -= need\n    \n    return True"
      },
      {
        "id": "06-merge-triplets-to-form-target-triplet",
        "slug": "merge-triplets-to-form-target-triplet",
        "title": "Merge Triplets to Form Target Triplet",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "merge-triplets-to-form-target-triplet"
        ],
        "estimatedTime": 5,
        "problemStatement": "A triplet is an array of three integers. You are given a 2D integer array `triplets`, where `triplets[i] = [ai, bi, ci]` describes the `ith` triplet. You are also given an integer array `target = [x, y, z]` that describes the triplet you want to obtain.\n\nTo obtain `target`, you may apply the following operation on `triplets` any number of times:\n\nChoose two indices `i` and `j` (i != j) and update `triplets[j]` to become `[max(ai, aj), max(bi, bj), max(ci, cj)]`.\n\nReturn `true` if it is possible to obtain the `target` triplet `[x, y, z]` as an element of `triplets`, or `false` otherwise.",
        "examples": [
          {
            "input": "triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]",
            "output": "true",
            "explanation": "Merge triplets[0] and triplets[2]: [max(2,1), max(5,7), max(3,5)] = [2,7,5]"
          },
          {
            "input": "triplets = [[3,4,5],[4,5,6]], target = [3,2,5]",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "After taking max of two triplets:",
            "options": [
              {
                "id": "a",
                "text": "Values can only increase or stay same"
              },
              {
                "id": "b",
                "text": "Values can decrease"
              },
              {
                "id": "c",
                "text": "Values are averaged"
              },
              {
                "id": "d",
                "text": "Values are summed"
              }
            ],
            "correct": "a",
            "explanation": "max(a, b) >= a and max(a, b) >= b. Values never decrease.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "A triplet [a, b, c] is unusable if:",
            "options": [
              {
                "id": "a",
                "text": "Any value exceeds corresponding target"
              },
              {
                "id": "b",
                "text": "Sum exceeds target sum"
              },
              {
                "id": "c",
                "text": "All values are smaller"
              },
              {
                "id": "d",
                "text": "Any value equals target"
              }
            ],
            "correct": "a",
            "explanation": "If a > target[0], using this triplet will make result[0] > target[0], which we can never reduce.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We need to find valid triplets that together:",
            "options": [
              {
                "id": "a",
                "text": "Cover all target values exactly"
              },
              {
                "id": "b",
                "text": "Sum to target"
              },
              {
                "id": "c",
                "text": "Have same length as target"
              },
              {
                "id": "d",
                "text": "Are consecutive"
              }
            ],
            "correct": "a",
            "explanation": "We need some triplet with value = target[0], some with = target[1], some with = target[2].",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "For each valid triplet, we track:",
            "options": [
              {
                "id": "a",
                "text": "Which target positions it matches exactly"
              },
              {
                "id": "b",
                "text": "Its sum"
              },
              {
                "id": "c",
                "text": "Its average"
              },
              {
                "id": "d",
                "text": "Its index"
              }
            ],
            "correct": "a",
            "explanation": "If triplet[i] == target[i], this triplet can \"contribute\" that target value.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We succeed if:",
            "options": [
              {
                "id": "a",
                "text": "One triplet matches all"
              },
              {
                "id": "b",
                "text": "Valid triplets together cover all 3 positions"
              },
              {
                "id": "c",
                "text": "We have 3 triplets"
              },
              {
                "id": "d",
                "text": "Average matches target"
              }
            ],
            "correct": "b",
            "explanation": "Collectively, valid triplets must have each target value achievable.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Filter triplets where ALL values ≤ target (usable). Among usable ones, check if we can find each target value exactly. Max never decreases values.",
        "pattern": "Greedy",
        "keyInsight": "A triplet is usable only if ALL its values are ≤ corresponding target values.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "merge triplets to form target triplet",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def mergeTriplets(triplets: List[List[int]], target: List[int]) -> bool:\n    found = [False, False, False]\n    \n    for triplet in triplets:\n        # Skip if any value exceeds target\n        if triplet[0] > target[0] or triplet[1] > target[1] or triplet[2] > target[2]:\n            continue\n        \n        # Mark which target values this triplet can contribute\n        for i in range(3):\n            if triplet[i] == target[i]:\n                found[i] = True\n    \n    return all(found)"
      },
      {
        "id": "07-partition-labels",
        "slug": "partition-labels",
        "title": "Partition Labels",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "partition-labels"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a string `s`. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn a list of integers representing the size of these parts.",
        "examples": [
          {
            "input": "s = \"ababcbacadefegdehijhklij\"",
            "output": "[9,7,8]",
            "explanation": "\"ababcbaca\", \"defegde\", \"hijhklij\""
          },
          {
            "input": "s = \"eccbbbbdec\"",
            "output": "[10]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If partition contains character 'a', it must:",
            "options": [
              {
                "id": "a",
                "text": "Start with 'a'"
              },
              {
                "id": "b",
                "text": "End with 'a'"
              },
              {
                "id": "c",
                "text": "Contain ALL occurrences of 'a'"
              },
              {
                "id": "d",
                "text": "Have 'a' in the middle"
              }
            ],
            "correct": "c",
            "explanation": "Each character appears in at most one part, so all its occurrences must be together.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "For each character, we need:",
            "options": [
              {
                "id": "a",
                "text": "First occurrence"
              },
              {
                "id": "b",
                "text": "Last occurrence"
              },
              {
                "id": "c",
                "text": "Count"
              },
              {
                "id": "d",
                "text": "ASCII value"
              }
            ],
            "correct": "b",
            "explanation": "Partition containing a character must extend at least to its last occurrence.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "As we traverse, we extend current partition to:",
            "options": [
              {
                "id": "a",
                "text": "First occurrence of current char"
              },
              {
                "id": "b",
                "text": "Last occurrence of current char"
              },
              {
                "id": "c",
                "text": "Next character"
              },
              {
                "id": "d",
                "text": "End of string"
              }
            ],
            "correct": "b",
            "explanation": "If we see char c, we must include everything up to c's last occurrence.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "We can close the current partition when:",
            "options": [
              {
                "id": "a",
                "text": "We see a new character"
              },
              {
                "id": "b",
                "text": "Current index equals the partition's farthest required extent"
              },
              {
                "id": "c",
                "text": "We've seen all characters"
              },
              {
                "id": "d",
                "text": "At every index"
              }
            ],
            "correct": "b",
            "explanation": "If i == end, all characters in this partition have been fully included.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "The partition end is updated to:",
            "options": [
              {
                "id": "a",
                "text": "last[s[i]]"
              },
              {
                "id": "b",
                "text": "max(end, last[s[i]])"
              },
              {
                "id": "c",
                "text": "min(end, last[s[i]])"
              },
              {
                "id": "d",
                "text": "last[s[i]] + 1"
              }
            ],
            "correct": "b",
            "explanation": "End grows to accommodate all characters. Take max with current end.",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Track last occurrence of each char. Extend partition end to max(end, last[current_char]). When index equals end, close partition.",
        "pattern": "Greedy",
        "keyInsight": "A partition must include ALL occurrences of any character it contains.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "partition labels",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def partitionLabels(s: str) -> List[int]:\n    # Find last occurrence of each character\n    last = {c: i for i, c in enumerate(s)}\n    \n    result = []\n    start = 0\n    end = 0\n    \n    for i, c in enumerate(s):\n        end = max(end, last[c])  # Extend partition\n        \n        if i == end:  # All chars in partition fully included\n            result.append(end - start + 1)\n            start = i + 1\n    \n    return result"
      },
      {
        "id": "08-valid-parenthesis-string",
        "slug": "valid-parenthesis-string",
        "title": "Valid Parenthesis String",
        "category": "greedy",
        "difficulty": "medium",
        "tags": [
          "greedy",
          "valid-parenthesis-string"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a string `s` containing only three types of characters: `'('`, `')'` and `'*'`, return `true` if `s` is valid.\n\nThe following rules define a valid string:\n- Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.\n- Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.\n- Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.\n- `'*'` could be treated as a single right parenthesis `')'` OR a single left parenthesis `'('` OR an empty string `\"\"`.",
        "examples": [
          {
            "input": "s = \"()\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"(*)\"",
            "output": "true",
            "explanation": ""
          },
          {
            "input": "s = \"(*))\"",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We track a range [low, high] because:",
            "options": [
              {
                "id": "a",
                "text": "* can be (, ), or empty → multiple possibilities"
              },
              {
                "id": "b",
                "text": "We need exactly two values"
              },
              {
                "id": "c",
                "text": "It's more efficient"
              },
              {
                "id": "d",
                "text": "Standard approach for all problems"
              }
            ],
            "correct": "a",
            "explanation": "At any point, open count could be anywhere in a range depending on * choices.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When we see '(':",
            "options": [
              {
                "id": "a",
                "text": "low++, high++"
              },
              {
                "id": "b",
                "text": "low--, high--"
              },
              {
                "id": "c",
                "text": "low--, high++"
              },
              {
                "id": "d",
                "text": "Only high++"
              }
            ],
            "correct": "a",
            "explanation": "'(' definitely adds one open parenthesis.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When we see ')':",
            "options": [
              {
                "id": "a",
                "text": "low++, high++"
              },
              {
                "id": "b",
                "text": "low--, high--"
              },
              {
                "id": "c",
                "text": "low--, high++"
              },
              {
                "id": "d",
                "text": "Only low--"
              }
            ],
            "correct": "b",
            "explanation": "')' definitely closes one parenthesis.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When we see '*':",
            "options": [
              {
                "id": "a",
                "text": "low++, high++"
              },
              {
                "id": "b",
                "text": "low--, high--"
              },
              {
                "id": "c",
                "text": "low--, high++"
              },
              {
                "id": "d",
                "text": "No change"
              }
            ],
            "correct": "c",
            "explanation": "* as ')' decreases open count (low--), * as '(' increases it (high++).",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "String is valid if:",
            "options": [
              {
                "id": "a",
                "text": "high >= 0 always (not too many closing)"
              },
              {
                "id": "b",
                "text": "low <= 0 at end (can balance opens)   (after clamping low to 0)"
              },
              {
                "id": "c",
                "text": "low == 0 at end"
              },
              {
                "id": "d",
                "text": "A and C"
              }
            ],
            "correct": "d",
            "explanation": "If high < 0, too many ')'. At end, low must be 0 (all opens matched).",
            "conceptId": "greedy"
          }
        ],
        "oneLiner": "Track [low, high] range of possible open counts. '(' increases both, ')' decreases both, '*' does both. If high < 0, fail. At end, low must be 0.",
        "pattern": "Greedy",
        "keyInsight": "Track range of possible open parentheses counts [low, high].",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "valid parenthesis string",
          "greedy"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def checkValidString(s: str) -> bool:\n    low = 0   # Minimum possible open count\n    high = 0  # Maximum possible open count\n    \n    for c in s:\n        if c == '(':\n            low += 1\n            high += 1\n        elif c == ')':\n            low -= 1\n            high -= 1\n        else:  # '*'\n            low -= 1   # Treat as ')'\n            high += 1  # Treat as '('\n        \n        # Too many closing parens\n        if high < 0:\n            return False\n        \n        # low can't go negative (we'd just treat * as empty)\n        low = max(low, 0)\n    \n    return low == 0"
      }
    ],
    "intervals": [
      {
        "id": "01-insert-interval",
        "slug": "insert-interval",
        "title": "Insert Interval",
        "category": "intervals",
        "difficulty": "medium",
        "tags": [
          "intervals",
          "insert-interval"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.\n\nInsert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still has no overlapping intervals (merge overlapping intervals if necessary).\n\nReturn `intervals` after the insertion.",
        "examples": [
          {
            "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
            "output": "[[1,5],[6,9]]",
            "explanation": ""
          },
          {
            "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
            "output": "[[1,2],[3,10],[12,16]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Interval [a, b] is completely before newInterval [x, y] if:",
            "options": [
              {
                "id": "a",
                "text": "a < x"
              },
              {
                "id": "b",
                "text": "b < x"
              },
              {
                "id": "c",
                "text": "a < y"
              },
              {
                "id": "d",
                "text": "b < y"
              }
            ],
            "correct": "b",
            "explanation": "If interval ends before new starts, no overlap. Add to result as-is.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Interval [a, b] is completely after newInterval [x, y] if:",
            "options": [
              {
                "id": "a",
                "text": "a > y"
              },
              {
                "id": "b",
                "text": "b > y"
              },
              {
                "id": "c",
                "text": "a > x"
              },
              {
                "id": "d",
                "text": "b > x"
              }
            ],
            "correct": "a",
            "explanation": "If interval starts after new ends, no overlap. Add to result as-is.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Interval [a, b] overlaps with [x, y] if:",
            "options": [
              {
                "id": "a",
                "text": "a <= y AND b >= x"
              },
              {
                "id": "b",
                "text": "a < y AND b > x"
              },
              {
                "id": "c",
                "text": "a == x OR b == y"
              },
              {
                "id": "d",
                "text": "a <= x AND b >= y"
              }
            ],
            "correct": "a",
            "explanation": "Overlap when neither is completely before nor after the other.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "When merging [a, b] into [x, y]:",
            "options": [
              {
                "id": "a",
                "text": "new_start = min(a, x), new_end = max(b, y)"
              },
              {
                "id": "b",
                "text": "new_start = a, new_end = y"
              },
              {
                "id": "c",
                "text": "new_start = x, new_end = b"
              },
              {
                "id": "d",
                "text": "new_start = max(a, x), new_end = min(b, y)"
              }
            ],
            "correct": "a",
            "explanation": "Merged interval spans from earliest start to latest end.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "We process intervals:",
            "options": [
              {
                "id": "a",
                "text": "In any order"
              },
              {
                "id": "b",
                "text": "By start time (given sorted)"
              },
              {
                "id": "c",
                "text": "By end time"
              },
              {
                "id": "d",
                "text": "By length"
              }
            ],
            "correct": "b",
            "explanation": "Input is sorted by start. Process linearly: before, overlap, after.",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Three phases: (1) add intervals ending before new starts, (2) merge all overlapping intervals with new, (3) add intervals starting after new ends.",
        "pattern": "Intervals",
        "keyInsight": "Three phases: intervals before new (no overlap), merge with new (overlap), intervals after new (no overlap).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "insert interval",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def insert(intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n    result = []\n    i = 0\n    n = len(intervals)\n    \n    # Phase 1: Add intervals ending before newInterval starts\n    while i < n and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    # Phase 2: Merge overlapping intervals\n    while i < n and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    result.append(newInterval)\n    \n    # Phase 3: Add remaining intervals\n    while i < n:\n        result.append(intervals[i])\n        i += 1\n    \n    return result"
      },
      {
        "id": "02-merge-intervals",
        "slug": "merge-intervals",
        "title": "Merge Intervals",
        "category": "intervals",
        "difficulty": "medium",
        "tags": [
          "intervals",
          "merge-intervals"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
        "examples": [
          {
            "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
            "output": "[[1,6],[8,10],[15,18]]",
            "explanation": "[1,3] and [2,6] overlap, merge into [1,6]."
          },
          {
            "input": "intervals = [[1,4],[4,5]]",
            "output": "[[1,5]]",
            "explanation": "[1,4] and [4,5] overlap (touch at 4)."
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Sorting by start time ensures:",
            "options": [
              {
                "id": "a",
                "text": "Overlapping intervals become adjacent"
              },
              {
                "id": "b",
                "text": "Faster merging"
              },
              {
                "id": "c",
                "text": "No duplicates"
              },
              {
                "id": "d",
                "text": "Smaller output"
              }
            ],
            "correct": "a",
            "explanation": "If sorted by start, interval can only overlap with its predecessor in result.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "After sorting, [a, b] overlaps with [c, d] (where c >= a) if:",
            "options": [
              {
                "id": "a",
                "text": "a <= d"
              },
              {
                "id": "b",
                "text": "b >= c"
              },
              {
                "id": "c",
                "text": "a == c"
              },
              {
                "id": "d",
                "text": "b == d"
              }
            ],
            "correct": "b",
            "explanation": "Since intervals are sorted, c >= a. Overlap if previous end >= current start.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "When merging [a, b] with overlapping [c, d]:",
            "options": [
              {
                "id": "a",
                "text": "[a, max(b, d)]"
              },
              {
                "id": "b",
                "text": "[min(a, c), max(b, d)]"
              },
              {
                "id": "c",
                "text": "[a, d]"
              },
              {
                "id": "d",
                "text": "[c, b]"
              }
            ],
            "correct": "a",
            "explanation": "Since sorted, a <= c. So start is a. End is the farther of b and d.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Start a new merged interval when:",
            "options": [
              {
                "id": "a",
                "text": "Current doesn't overlap with result's last"
              },
              {
                "id": "b",
                "text": "Current has larger start"
              },
              {
                "id": "c",
                "text": "Current is longer"
              },
              {
                "id": "d",
                "text": "At even indices"
              }
            ],
            "correct": "a",
            "explanation": "No overlap means current interval is separate. Add it to result.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "[1,4] and [4,5] should:",
            "options": [
              {
                "id": "a",
                "text": "Remain separate"
              },
              {
                "id": "b",
                "text": "Merge to [1,5]"
              },
              {
                "id": "c",
                "text": "Error"
              },
              {
                "id": "d",
                "text": "Depends"
              }
            ],
            "correct": "b",
            "explanation": "They touch at 4. Typically treated as overlapping (b >= c means 4 >= 4).",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Sort by start. For each interval, if it overlaps with result's last (start <= last_end), merge. Otherwise, add new.",
        "pattern": "Intervals",
        "keyInsight": "Sort by start time. Then merge consecutive intervals if they overlap.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "merge intervals",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def merge(intervals: List[List[int]]) -> List[List[int]]:\n    if not intervals:\n        return []\n    \n    # Sort by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    result = [intervals[0]]\n    \n    for i in range(1, len(intervals)):\n        # If overlaps with last in result\n        if intervals[i][0] <= result[-1][1]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n    \n    return result"
      },
      {
        "id": "03-non-overlapping-intervals",
        "slug": "non-overlapping-intervals",
        "title": "Non-overlapping Intervals",
        "category": "intervals",
        "difficulty": "medium",
        "tags": [
          "intervals",
          "non-overlapping-intervals"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.",
        "examples": [
          {
            "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
            "output": "1",
            "explanation": "Remove [1,3] to make the rest non-overlapping."
          },
          {
            "input": "intervals = [[1,2],[1,2],[1,2]]",
            "output": "2",
            "explanation": ""
          },
          {
            "input": "intervals = [[1,2],[2,3]]",
            "output": "0",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Minimum removals = n - maximum non-overlapping. This is:",
            "options": [
              {
                "id": "a",
                "text": "Dynamic programming"
              },
              {
                "id": "b",
                "text": "Activity selection problem"
              },
              {
                "id": "c",
                "text": "Graph problem"
              },
              {
                "id": "d",
                "text": "String matching"
              }
            ],
            "correct": "b",
            "explanation": "Classic greedy activity selection. Maximize intervals we can keep.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "Sorting by end time:",
            "options": [
              {
                "id": "a",
                "text": "Groups overlapping intervals"
              },
              {
                "id": "b",
                "text": "Ensures we leave maximum room for future intervals"
              },
              {
                "id": "c",
                "text": "Is required for correctness"
              },
              {
                "id": "d",
                "text": "Makes code simpler"
              }
            ],
            "correct": "b",
            "explanation": "Picking interval that ends earliest leaves most time for remaining intervals.",
            "conceptId": "greedy"
          },
          {
            "type": "mcq",
            "question": "When intervals overlap, we should remove:",
            "options": [
              {
                "id": "a",
                "text": "The one that starts first"
              },
              {
                "id": "b",
                "text": "The one that ends later"
              },
              {
                "id": "c",
                "text": "The shorter one"
              },
              {
                "id": "d",
                "text": "Random choice"
              }
            ],
            "correct": "b",
            "explanation": "Interval ending later \"blocks\" more future intervals. Remove it.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "After sorting by end, [a, b] overlaps with [c, d] if:",
            "options": [
              {
                "id": "a",
                "text": "c < b"
              },
              {
                "id": "b",
                "text": "c <= b"
              },
              {
                "id": "c",
                "text": "d > b"
              },
              {
                "id": "d",
                "text": "a < d"
              }
            ],
            "correct": "a",
            "explanation": "If next interval starts before current ends, they overlap. (Using strict < since [1,2],[2,3] don't overlap)",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "While iterating, we track:",
            "options": [
              {
                "id": "a",
                "text": "Last interval's start"
              },
              {
                "id": "b",
                "text": "Last interval's end (of kept intervals)"
              },
              {
                "id": "c",
                "text": "Number of removals"
              },
              {
                "id": "d",
                "text": "All intervals"
              }
            ],
            "correct": "b",
            "explanation": "Compare next interval's start with last kept interval's end.",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Activity selection: sort by end time. Greedily keep intervals that don't overlap with the last kept one. Removals = n - kept.",
        "pattern": "Intervals",
        "keyInsight": "Equivalent to: find maximum number of non-overlapping intervals (activity selection).",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "non-overlapping intervals",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def eraseOverlapIntervals(intervals: List[List[int]]) -> int:\n    if not intervals:\n        return 0\n    \n    # Sort by end time (activity selection)\n    intervals.sort(key=lambda x: x[1])\n    \n    kept = 1\n    end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] >= end:  # No overlap\n            kept += 1\n            end = intervals[i][1]\n    \n    return len(intervals) - kept"
      },
      {
        "id": "04-meeting-rooms",
        "slug": "meeting-rooms",
        "title": "Meeting Rooms",
        "category": "intervals",
        "difficulty": "easy",
        "tags": [
          "intervals",
          "meeting-rooms"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of meeting time intervals where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.",
        "examples": [
          {
            "input": "intervals = [[0,30],[5,10],[15,20]]",
            "output": "false",
            "explanation": "[0,30] overlaps with [5,10] and [15,20]."
          },
          {
            "input": "intervals = [[7,10],[2,4]]",
            "output": "true",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "A person can attend all meetings if:",
            "options": [
              {
                "id": "a",
                "text": "Total meeting time < 24 hours"
              },
              {
                "id": "b",
                "text": "No two meetings overlap"
              },
              {
                "id": "c",
                "text": "Meetings are sorted"
              },
              {
                "id": "d",
                "text": "All meetings are short"
              }
            ],
            "correct": "b",
            "explanation": "Can't be in two places at once. No overlaps means all are attendable.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "After sorting by start time, we only need to check:",
            "options": [
              {
                "id": "a",
                "text": "First and last meetings"
              },
              {
                "id": "b",
                "text": "Consecutive pairs of meetings"
              },
              {
                "id": "c",
                "text": "All pairs"
              },
              {
                "id": "d",
                "text": "Random pairs"
              }
            ],
            "correct": "b",
            "explanation": "If sorted, meeting i can only overlap with i+1. If i overlaps with j (j > i+1), it must overlap with i+1 first.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Sorted meetings [a, b] and [c, d] (where a <= c) overlap if:",
            "options": [
              {
                "id": "a",
                "text": "b > c"
              },
              {
                "id": "b",
                "text": "b >= c"
              },
              {
                "id": "c",
                "text": "a < d"
              },
              {
                "id": "d",
                "text": "b == c"
              }
            ],
            "correct": "a",
            "explanation": "If meeting 1 ends after meeting 2 starts, overlap. (b > c, not >=, since [1,2],[2,3] don't overlap)",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "If we find one pair of overlapping meetings:",
            "options": [
              {
                "id": "a",
                "text": "Check more pairs"
              },
              {
                "id": "b",
                "text": "Return false immediately"
              },
              {
                "id": "c",
                "text": "Try to reschedule"
              },
              {
                "id": "d",
                "text": "Count overlaps"
              }
            ],
            "correct": "b",
            "explanation": "One overlap is enough to fail. Can't attend both.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "If 0 or 1 meetings:",
            "options": [
              {
                "id": "a",
                "text": "Return false"
              },
              {
                "id": "b",
                "text": "Return true"
              },
              {
                "id": "c",
                "text": "Error"
              },
              {
                "id": "d",
                "text": "Depends"
              }
            ],
            "correct": "b",
            "explanation": "No meetings or one meeting means no possible conflicts.",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Sort by start time. Check if any meeting starts before the previous ends. One overlap = can't attend all.",
        "pattern": "Intervals",
        "keyInsight": "Sort by start time. Check if any meeting starts before the previous one ends.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "meeting rooms",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def canAttendMeetings(intervals: List[List[int]]) -> bool:\n    if len(intervals) <= 1:\n        return True\n    \n    # Sort by start time\n    intervals.sort(key=lambda x: x[0])\n    \n    for i in range(1, len(intervals)):\n        # If current starts before previous ends\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n    \n    return True"
      },
      {
        "id": "05-meeting-rooms-ii",
        "slug": "meeting-rooms-ii",
        "title": "Meeting Rooms II",
        "category": "intervals",
        "difficulty": "medium",
        "tags": [
          "intervals",
          "meeting-rooms-ii"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.",
        "examples": [
          {
            "input": "intervals = [[0,30],[5,10],[15,20]]",
            "output": "2",
            "explanation": "[0,30] in room 1, [5,10] and [15,20] in room 2."
          },
          {
            "input": "intervals = [[7,10],[2,4]]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Minimum rooms needed equals:",
            "options": [
              {
                "id": "a",
                "text": "Total number of meetings"
              },
              {
                "id": "b",
                "text": "Maximum concurrent meetings at any time"
              },
              {
                "id": "c",
                "text": "Longest meeting"
              },
              {
                "id": "d",
                "text": "Number of overlaps"
              }
            ],
            "correct": "b",
            "explanation": "At peak concurrency, each meeting needs its own room.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "We treat starts and ends as:",
            "options": [
              {
                "id": "a",
                "text": "Two separate sorted arrays"
              },
              {
                "id": "b",
                "text": "Events on a timeline"
              },
              {
                "id": "c",
                "text": "Paired data"
              },
              {
                "id": "d",
                "text": "Weights"
              }
            ],
            "correct": "b",
            "explanation": "Start = +1 room needed. End = -1 room needed. Track running count.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "When a start and end are at same time:",
            "options": [
              {
                "id": "a",
                "text": "Process start first"
              },
              {
                "id": "b",
                "text": "Process end first"
              },
              {
                "id": "c",
                "text": "Doesn't matter"
              },
              {
                "id": "d",
                "text": "Skip both"
              }
            ],
            "correct": "b",
            "explanation": "If meeting ends at time t and another starts at t, same room can be reused. End frees room first.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Min-heap stores:",
            "options": [
              {
                "id": "a",
                "text": "Meeting start times"
              },
              {
                "id": "b",
                "text": "End times of active meetings"
              },
              {
                "id": "c",
                "text": "Meeting indices"
              },
              {
                "id": "d",
                "text": "Room numbers"
              }
            ],
            "correct": "b",
            "explanation": "Heap tracks when earliest active meeting ends. If new meeting starts after, reuse that room.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Add new room when:",
            "options": [
              {
                "id": "a",
                "text": "Heap is empty"
              },
              {
                "id": "b",
                "text": "New meeting starts before all current meetings end"
              },
              {
                "id": "c",
                "text": "Meeting is long"
              },
              {
                "id": "d",
                "text": "At every meeting"
              }
            ],
            "correct": "b",
            "explanation": "If start < heap.min (earliest end), can't reuse any room. Need new one.",
            "conceptId": "intervals"
          }
        ],
        "oneLiner": "Sweep line: treat starts as +1, ends as -1. Max concurrent count = rooms needed. Or use min-heap of end times, reuse room if meeting ended.",
        "pattern": "Intervals",
        "keyInsight": "Sweep line: track starts and ends as events. Maximum concurrent meetings = minimum rooms needed.",
        "timeComplexity": "O(n log n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "meeting rooms ii",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minMeetingRooms(intervals: List[List[int]]) -> int:\n    if not intervals:\n        return 0\n    \n    # Sweep line approach\n    events = []\n    for start, end in intervals:\n        events.append((start, 1))   # +1 room at start\n        events.append((end, -1))    # -1 room at end\n    \n    # Sort: by time, then ends before starts at same time\n    events.sort(key=lambda x: (x[0], x[1]))\n    \n    rooms = 0\n    max_rooms = 0\n    \n    for time, delta in events:\n        rooms += delta\n        max_rooms = max(max_rooms, rooms)\n    \n    return max_rooms"
      },
      {
        "id": "06-minimum-interval-to-include-each-query",
        "slug": "minimum-interval-to-include-each-query",
        "title": "Minimum Interval to Include Each Query",
        "category": "intervals",
        "difficulty": "hard",
        "tags": [
          "intervals",
          "minimum-interval-to-include-each-query"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a 2D integer array `intervals`, where `intervals[i] = [lefti, righti]` describes the `ith` interval starting at `lefti` and ending at `righti` (inclusive). The size of an interval is defined as the number of integers it contains, or more formally `righti - lefti + 1`.\n\nYou are also given an integer array `queries`. The answer to the `jth` query is the size of the smallest interval `i` such that `lefti <= queries[j] <= righti`. If no such interval exists, the answer is `-1`.\n\nReturn an array `answer` where `answer[j]` is the answer to the `jth` query.",
        "examples": [
          {
            "input": "intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",
            "output": "[3,3,1,4]",
            "explanation": ""
          },
          {
            "input": "intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",
            "output": "[2,-1,4,6]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Processing queries in sorted order:",
            "options": [
              {
                "id": "a",
                "text": "Required for correctness"
              },
              {
                "id": "b",
                "text": "Allows efficient interval management"
              },
              {
                "id": "c",
                "text": "Makes output sorted"
              },
              {
                "id": "d",
                "text": "Reduces space"
              }
            ],
            "correct": "b",
            "explanation": "Can add intervals as we move right, remove expired ones. Efficient sweeping.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "The min-heap stores:",
            "options": [
              {
                "id": "a",
                "text": "(start, end) pairs"
              },
              {
                "id": "b",
                "text": "(size, end) pairs"
              },
              {
                "id": "c",
                "text": "Just sizes"
              },
              {
                "id": "d",
                "text": "Just ends"
              }
            ],
            "correct": "b",
            "explanation": "Priority by size (want smallest). Need end to check if still valid.",
            "conceptId": "heap"
          },
          {
            "type": "mcq",
            "question": "Add interval to heap when:",
            "options": [
              {
                "id": "a",
                "text": "Interval start <= current query"
              },
              {
                "id": "b",
                "text": "Interval end >= current query"
              },
              {
                "id": "c",
                "text": "Interval contains query"
              },
              {
                "id": "d",
                "text": "Always"
              }
            ],
            "correct": "a",
            "explanation": "If interval starts at or before query, it might contain query. Add to candidates.",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "Remove interval from heap when:",
            "options": [
              {
                "id": "a",
                "text": "It's been used"
              },
              {
                "id": "b",
                "text": "Its end < current query"
              },
              {
                "id": "c",
                "text": "It's too large"
              },
              {
                "id": "d",
                "text": "After each query"
              }
            ],
            "correct": "b",
            "explanation": "If end < query, interval can't contain query (or any future query since sorted).",
            "conceptId": "intervals"
          },
          {
            "type": "mcq",
            "question": "After cleanup, answer is:",
            "options": [
              {
                "id": "a",
                "text": "Heap top's size (if heap non-empty)"
              },
              {
                "id": "b",
                "text": "Heap top's end"
              },
              {
                "id": "c",
                "text": "Sum of all sizes"
              },
              {
                "id": "d",
                "text": "Number of intervals"
              }
            ],
            "correct": "a",
            "explanation": "Min-heap by size, so top is smallest valid interval.",
            "conceptId": "heap"
          }
        ],
        "oneLiner": "Sort intervals by start, queries by value. Sweep: add intervals starting <= query to min-heap (by size), remove expired ones (end < query). Heap top = answer.",
        "pattern": "Intervals",
        "keyInsight": "Sort intervals by start and queries by value. Use min-heap of (size, end) to track valid intervals.",
        "timeComplexity": "O((n + q) log n)",
        "spaceComplexity": "O(n + q)",
        "triggerWords": [
          "minimum interval to include each query",
          "intervals"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def minInterval(intervals: List[List[int]], queries: List[int]) -> List[int]:\n    # Sort intervals by start\n    intervals.sort()\n    \n    # Sort queries but keep original indices\n    sorted_queries = sorted(enumerate(queries), key=lambda x: x[1])\n    \n    result = [-1] * len(queries)\n    heap = []  # (size, end)\n    i = 0\n    \n    for idx, q in sorted_queries:\n        # Add all intervals that start <= query\n        while i < len(intervals) and intervals[i][0] <= q:\n            l, r = intervals[i]\n            heapq.heappush(heap, (r - l + 1, r))\n            i += 1\n        \n        # Remove expired intervals (end < query)\n        while heap and heap[0][1] < q:\n            heapq.heappop(heap)\n        \n        # Smallest valid interval\n        if heap:\n            result[idx] = heap[0][0]\n    \n    return result"
      }
    ],
    "bit-manipulation": [
      {
        "id": "01-single-number",
        "slug": "single-number",
        "title": "Single Number",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "single-number"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
        "examples": [
          {
            "input": "nums = [2,2,1]",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "nums = [4,1,2,1,2]",
            "output": "4",
            "explanation": ""
          },
          {
            "input": "nums = [1]",
            "output": "1",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "What is a ^ a (XOR of number with itself)?",
            "options": [
              {
                "id": "a",
                "text": "a"
              },
              {
                "id": "b",
                "text": "0"
              },
              {
                "id": "c",
                "text": "2a"
              },
              {
                "id": "d",
                "text": "1"
              }
            ],
            "correct": "b",
            "explanation": "XOR gives 1 only when bits differ. Same bits -> 0.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "What is a ^ 0?",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "a"
              },
              {
                "id": "c",
                "text": "1"
              },
              {
                "id": "d",
                "text": "-a"
              }
            ],
            "correct": "b",
            "explanation": "0 has no set bits. XOR with 0 preserves the original.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "a ^ b ^ a equals:",
            "options": [
              {
                "id": "a",
                "text": "a"
              },
              {
                "id": "b",
                "text": "b"
              },
              {
                "id": "c",
                "text": "0"
              },
              {
                "id": "d",
                "text": "2a ^ b"
              }
            ],
            "correct": "b",
            "explanation": "a ^ b ^ a = a ^ a ^ b = 0 ^ b = b. Order doesn't matter.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "XORing all elements works because:",
            "options": [
              {
                "id": "a",
                "text": "Pairs cancel to 0"
              },
              {
                "id": "b",
                "text": "Single number remains"
              },
              {
                "id": "c",
                "text": "Both A and B"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Each pair XORs to 0. Only the single number survives.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "This solution uses:",
            "options": [
              {
                "id": "a",
                "text": "O(n) space"
              },
              {
                "id": "b",
                "text": "O(n) hash set"
              },
              {
                "id": "c",
                "text": "O(1) space"
              },
              {
                "id": "d",
                "text": "O(log n) space"
              }
            ],
            "correct": "c",
            "explanation": "Only need one variable to accumulate XOR result.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "XOR all numbers. Pairs cancel (a^a=0), single number remains (a^0=a). Commutative and associative.",
        "pattern": "Bit Manipulation",
        "keyInsight": "XOR all numbers. Pairs cancel out (a ^ a = 0), leaving the single number.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "single number",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def singleNumber(nums: List[int]) -> int:\n    result = 0\n    for num in nums:\n        result ^= num\n    return result"
      },
      {
        "id": "02-number-of-1-bits",
        "slug": "number-of-1-bits",
        "title": "Number of 1 Bits",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "number-of-1-bits"
        ],
        "estimatedTime": 5,
        "problemStatement": "Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).",
        "examples": [
          {
            "input": "n = 00000000000000000000000000001011",
            "output": "3",
            "explanation": "Binary has three '1' bits."
          },
          {
            "input": "n = 00000000000000000000000010000000",
            "output": "1",
            "explanation": ""
          },
          {
            "input": "n = 11111111111111111111111111111101",
            "output": "31",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "n & (n-1) does:",
            "options": [
              {
                "id": "a",
                "text": "Sets rightmost 0 to 1"
              },
              {
                "id": "b",
                "text": "Clears rightmost 1 bit"
              },
              {
                "id": "c",
                "text": "Doubles n"
              },
              {
                "id": "d",
                "text": "Halves n"
              }
            ],
            "correct": "b",
            "explanation": "n-1 flips all bits from rightmost 1 to right. AND with n clears that 1.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "If n = 12 (1100), n & (n-1) = ?",
            "options": [
              {
                "id": "a",
                "text": "8 (1000)"
              },
              {
                "id": "b",
                "text": "11 (1011)"
              },
              {
                "id": "c",
                "text": "4 (0100)"
              },
              {
                "id": "d",
                "text": "0"
              }
            ],
            "correct": "a",
            "explanation": "12 = 1100, 11 = 1011. 1100 & 1011 = 1000 = 8.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "To count 1s, we:",
            "options": [
              {
                "id": "a",
                "text": "Count iterations until n = 0"
              },
              {
                "id": "b",
                "text": "Convert to string"
              },
              {
                "id": "c",
                "text": "Use multiplication"
              },
              {
                "id": "d",
                "text": "Use division"
              }
            ],
            "correct": "a",
            "explanation": "Each n = n & (n-1) removes one 1-bit. Count how many removals.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "We can also:",
            "options": [
              {
                "id": "a",
                "text": "Check n & 1, then n >>= 1"
              },
              {
                "id": "b",
                "text": "Check 32 bits always"
              },
              {
                "id": "c",
                "text": "Both A and B"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Either works. n & 1 checks last bit, shift right to check next.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Brian Kernighan's method iterates:",
            "options": [
              {
                "id": "a",
                "text": "32 times always"
              },
              {
                "id": "b",
                "text": "Number of 1-bits times"
              },
              {
                "id": "c",
                "text": "n times"
              },
              {
                "id": "d",
                "text": "log(n) times"
              }
            ],
            "correct": "b",
            "explanation": "Each iteration removes one 1-bit. Runs exactly count(1s) times.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "n & (n-1) clears rightmost 1-bit. Count iterations until n = 0. Each iteration = one 1-bit.",
        "pattern": "Bit Manipulation",
        "keyInsight": "n & (n-1) clears the rightmost set bit. Count iterations until n becomes 0.",
        "timeComplexity": "O(k)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "number of 1 bits",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def hammingWeight(n: int) -> int:\n    count = 0\n    while n:\n        n &= n - 1  # Clear rightmost 1-bit\n        count += 1\n    return count"
      },
      {
        "id": "03-counting-bits",
        "slug": "counting-bits",
        "title": "Counting Bits",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "counting-bits"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (0 <= i <= n), `ans[i]` is the number of 1's in the binary representation of `i`.",
        "examples": [
          {
            "input": "n = 2",
            "output": "[0,1,1]",
            "explanation": "0=0, 1=1, 2=10"
          },
          {
            "input": "n = 5",
            "output": "[0,1,1,2,1,2]",
            "explanation": "0=0, 1=1, 2=10, 3=11, 4=100, 5=101"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "i >> 1 (right shift by 1):",
            "options": [
              {
                "id": "a",
                "text": "Doubles i"
              },
              {
                "id": "b",
                "text": "Halves i (integer division by 2)"
              },
              {
                "id": "c",
                "text": "Removes all 1s"
              },
              {
                "id": "d",
                "text": "Adds a 0 at the end"
              }
            ],
            "correct": "b",
            "explanation": "Right shift by 1 = divide by 2. Removes rightmost bit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "bits(i) compared to bits(i >> 1):",
            "options": [
              {
                "id": "a",
                "text": "Always same"
              },
              {
                "id": "b",
                "text": "Differs by at most 1"
              },
              {
                "id": "c",
                "text": "Always greater"
              },
              {
                "id": "d",
                "text": "Doubled"
              }
            ],
            "correct": "b",
            "explanation": "i >> 1 loses one bit (rightmost). If that bit was 1, count decreases by 1.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "bits(i) = ?",
            "options": [
              {
                "id": "a",
                "text": "bits(i - 1) + 1"
              },
              {
                "id": "b",
                "text": "bits(i >> 1) + (i & 1)"
              },
              {
                "id": "c",
                "text": "bits(i / 2) * 2"
              },
              {
                "id": "d",
                "text": "bits(i - 1) + bits(1)"
              }
            ],
            "correct": "b",
            "explanation": "bits(i>>1) gives count without last bit. Add (i & 1) for the last bit.",
            "conceptId": "dynamic-programming"
          },
          {
            "type": "mcq",
            "question": "bits(0) = ?",
            "options": [
              {
                "id": "a",
                "text": "0"
              },
              {
                "id": "b",
                "text": "1"
              },
              {
                "id": "c",
                "text": "Undefined"
              },
              {
                "id": "d",
                "text": "-1"
              }
            ],
            "correct": "a",
            "explanation": "0 has no 1-bits.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "To compute bits(i), we need:",
            "options": [
              {
                "id": "a",
                "text": "bits(i - 1)"
              },
              {
                "id": "b",
                "text": "bits(i >> 1) (which is < i)"
              },
              {
                "id": "c",
                "text": "bits(i + 1)"
              },
              {
                "id": "d",
                "text": "bits(i * 2)"
              }
            ],
            "correct": "b",
            "explanation": "i >> 1 < i for i > 0. So compute in order 0, 1, 2, ..., n.",
            "conceptId": "dynamic-programming"
          }
        ],
        "oneLiner": "DP: dp[i] = dp[i >> 1] + (i & 1). Right shift gives count without last bit, add 1 if last bit is set.",
        "pattern": "Bit Manipulation",
        "keyInsight": "DP: bits(i) = bits(i >> 1) + (i & 1)",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "counting bits",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def countBits(n: int) -> List[int]:\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i >> 1] + (i & 1)\n    return dp"
      },
      {
        "id": "04-reverse-bits",
        "slug": "reverse-bits",
        "title": "Reverse Bits",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "reverse-bits"
        ],
        "estimatedTime": 5,
        "problemStatement": "Reverse bits of a given 32 bits unsigned integer.",
        "examples": [
          {
            "input": "n = 00000010100101000001111010011100",
            "output": "964176192 (00111001011110000010100101000000)",
            "explanation": ""
          },
          {
            "input": "n = 11111111111111111111111111111101",
            "output": "3221225471 (10111111111111111111111111111111)",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To extract the rightmost bit of n:",
            "options": [
              {
                "id": "a",
                "text": "n >> 1"
              },
              {
                "id": "b",
                "text": "n & 1"
              },
              {
                "id": "c",
                "text": "n | 1"
              },
              {
                "id": "d",
                "text": "n ^ 1"
              }
            ],
            "correct": "b",
            "explanation": "AND with 1 isolates the last bit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Each extracted bit should go:",
            "options": [
              {
                "id": "a",
                "text": "To the same position"
              },
              {
                "id": "b",
                "text": "To the mirrored position"
              },
              {
                "id": "c",
                "text": "To position 0 always"
              },
              {
                "id": "d",
                "text": "Random position"
              }
            ],
            "correct": "b",
            "explanation": "Bit at position 0 goes to position 31, etc. Reverse = mirror.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "For each of 32 bits:",
            "options": [
              {
                "id": "a",
                "text": "result = (result << 1) | (n & 1), then n >> 1"
              },
              {
                "id": "b",
                "text": "result = (result >> 1) | (n & 1), then n << 1"
              },
              {
                "id": "c",
                "text": "result += n & 1, then n >> 1"
              },
              {
                "id": "d",
                "text": "result = result ^ n"
              }
            ],
            "correct": "a",
            "explanation": "Shift result left to make room, OR with extracted bit, shift n right to get next bit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "We always iterate:",
            "options": [
              {
                "id": "a",
                "text": "Until n becomes 0"
              },
              {
                "id": "b",
                "text": "Exactly 32 times"
              },
              {
                "id": "c",
                "text": "log(n) times"
              },
              {
                "id": "d",
                "text": "n times"
              }
            ],
            "correct": "b",
            "explanation": "Need all 32 bits. Leading zeros in input become trailing zeros in output.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "If input has leading zeros:",
            "options": [
              {
                "id": "a",
                "text": "Ignore them"
              },
              {
                "id": "b",
                "text": "They become trailing zeros in output"
              },
              {
                "id": "c",
                "text": "Error"
              },
              {
                "id": "d",
                "text": "Skip them"
              }
            ],
            "correct": "b",
            "explanation": "Reversal means position 31 (leading) goes to position 0 (trailing).",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "Extract rightmost bit (n & 1), shift result left and add bit, shift n right. Repeat 32 times to reverse all bits.",
        "pattern": "Bit Manipulation",
        "keyInsight": "Extract rightmost bit, add to result (shifted left), shift input right. Repeat 32 times.",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reverse bits",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reverseBits(n: int) -> int:\n    result = 0\n    for _ in range(32):\n        result = (result << 1) | (n & 1)\n        n >>= 1\n    return result"
      },
      {
        "id": "05-missing-number",
        "slug": "missing-number",
        "title": "Missing Number",
        "category": "bit-manipulation",
        "difficulty": "easy",
        "tags": [
          "bit-manipulation",
          "missing-number"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.",
        "examples": [
          {
            "input": "nums = [3,0,1]",
            "output": "2",
            "explanation": ""
          },
          {
            "input": "nums = [0,1]",
            "output": "2",
            "explanation": ""
          },
          {
            "input": "nums = [9,6,4,2,3,5,7,0,1]",
            "output": "8",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "If we XOR all indices (0 to n) and all elements:",
            "options": [
              {
                "id": "a",
                "text": "Pairs will cancel (appear twice)"
              },
              {
                "id": "b",
                "text": "Missing number will remain (appears once)"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Each number except missing appears in both index set and array. Missing appears only in index set.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "For [3, 0, 1], we XOR: Indices: 0, 1, 2, 3 (n=3) Elements: 3, 0, 1",
            "options": [
              {
                "id": "a",
                "text": "0^1^2^3^3^0^1 = 2"
              },
              {
                "id": "b",
                "text": "3^0^1 = 2"
              },
              {
                "id": "c",
                "text": "0+1+2+3 - 3-0-1 = 2"
              },
              {
                "id": "d",
                "text": "A and C both work"
              }
            ],
            "correct": "d",
            "explanation": "XOR cancels pairs. Sum difference also works.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Expected sum 0+1+...+n = n(n+1)/2. Missing = ?",
            "options": [
              {
                "id": "a",
                "text": "expected - actual"
              },
              {
                "id": "b",
                "text": "actual - expected"
              },
              {
                "id": "c",
                "text": "expected / actual"
              },
              {
                "id": "d",
                "text": "expected * actual"
              }
            ],
            "correct": "a",
            "explanation": "Actual sum is missing one number. Difference gives that number.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Both XOR and sum methods use:",
            "options": [
              {
                "id": "a",
                "text": "O(n) space"
              },
              {
                "id": "b",
                "text": "O(1) space"
              },
              {
                "id": "c",
                "text": "O(n) for XOR, O(1) for sum"
              },
              {
                "id": "d",
                "text": "O(log n) space"
              }
            ],
            "correct": "b",
            "explanation": "Both only need a running accumulator.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Sum method might have:",
            "options": [
              {
                "id": "a",
                "text": "Integer overflow for large n"
              },
              {
                "id": "b",
                "text": "Floating point errors"
              },
              {
                "id": "c",
                "text": "Both"
              },
              {
                "id": "d",
                "text": "Neither (XOR is safer)"
              }
            ],
            "correct": "a",
            "explanation": "n(n+1)/2 can be large. XOR has no overflow issues.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "XOR all indices 0 to n with all array elements. Pairs cancel, missing number survives. Or: n(n+1)/2 - sum(nums).",
        "pattern": "Bit Manipulation",
        "keyInsight": "XOR all numbers 0 to n with all array elements. Pairs cancel, missing number remains.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "missing number",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def missingNumber(nums: List[int]) -> int:\n    n = len(nums)\n    result = n  # Start with n (last index)\n    \n    for i in range(n):\n        result ^= i ^ nums[i]\n    \n    return result"
      },
      {
        "id": "06-sum-of-two-integers",
        "slug": "sum-of-two-integers",
        "title": "Sum of Two Integers",
        "category": "bit-manipulation",
        "difficulty": "medium",
        "tags": [
          "bit-manipulation",
          "sum-of-two-integers"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two integers `a` and `b`, return the sum of the two integers without using the operators `+` and `-`.",
        "examples": [
          {
            "input": "a = 1, b = 2",
            "output": "3",
            "explanation": ""
          },
          {
            "input": "a = 2, b = 3",
            "output": "5",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "a ^ b gives:",
            "options": [
              {
                "id": "a",
                "text": "Sum without considering carries"
              },
              {
                "id": "b",
                "text": "Sum including carries"
              },
              {
                "id": "c",
                "text": "Only the carries"
              },
              {
                "id": "d",
                "text": "Difference of a and b"
              }
            ],
            "correct": "a",
            "explanation": "XOR adds bits without carry: 0+0=0, 0+1=1, 1+0=1, 1+1=0 (no carry).",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Carry happens when:",
            "options": [
              {
                "id": "a",
                "text": "Both bits are 0"
              },
              {
                "id": "b",
                "text": "Both bits are 1"
              },
              {
                "id": "c",
                "text": "Bits are different"
              },
              {
                "id": "d",
                "text": "Any bit is 1"
              }
            ],
            "correct": "b",
            "explanation": "1 + 1 = 10 in binary. Generates a carry to next position.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "Carry from a + b is:",
            "options": [
              {
                "id": "a",
                "text": "a | b"
              },
              {
                "id": "b",
                "text": "a & b"
              },
              {
                "id": "c",
                "text": "a ^ b"
              },
              {
                "id": "d",
                "text": "a + b"
              }
            ],
            "correct": "b",
            "explanation": "AND finds positions where both bits are 1 (where carries occur).",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "The carry needs to be:",
            "options": [
              {
                "id": "a",
                "text": "Added at same position"
              },
              {
                "id": "b",
                "text": "Shifted left by 1"
              },
              {
                "id": "c",
                "text": "Shifted right by 1"
              },
              {
                "id": "d",
                "text": "Kept as is"
              }
            ],
            "correct": "b",
            "explanation": "Carry from position i affects position i+1. Shift left.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "We stop when:",
            "options": [
              {
                "id": "a",
                "text": "a becomes 0"
              },
              {
                "id": "b",
                "text": "Carry becomes 0"
              },
              {
                "id": "c",
                "text": "After 32 iterations"
              },
              {
                "id": "d",
                "text": "Sum equals original"
              }
            ],
            "correct": "b",
            "explanation": "When no carry, XOR is the final answer.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "XOR = sum without carry. (AND << 1) = carry bits. Add sum and carry repeatedly until carry is 0.",
        "pattern": "Bit Manipulation",
        "keyInsight": "XOR gives sum without carry. AND shifted left gives carry. Repeat until no carry.",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "sum of two integers",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def getSum(a: int, b: int) -> int:\n    # Use 32-bit mask for Python (handles negatives)\n    MASK = 0xFFFFFFFF\n    MAX_INT = 0x7FFFFFFF\n    \n    while b != 0:\n        carry = (a & b) << 1\n        a = (a ^ b) & MASK\n        b = carry & MASK\n    \n    # Handle negative numbers\n    return a if a <= MAX_INT else ~(a ^ MASK)"
      },
      {
        "id": "07-reverse-integer",
        "slug": "reverse-integer",
        "title": "Reverse Integer",
        "category": "bit-manipulation",
        "difficulty": "medium",
        "tags": [
          "bit-manipulation",
          "reverse-integer"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return `0`.\n\nAssume the environment does not allow you to store 64-bit integers.",
        "examples": [
          {
            "input": "x = 123",
            "output": "321",
            "explanation": ""
          },
          {
            "input": "x = -123",
            "output": "-321",
            "explanation": ""
          },
          {
            "input": "x = 120",
            "output": "21",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "To get the last digit of x:",
            "options": [
              {
                "id": "a",
                "text": "x // 10"
              },
              {
                "id": "b",
                "text": "x % 10"
              },
              {
                "id": "c",
                "text": "x - 10"
              },
              {
                "id": "d",
                "text": "x / 10"
              }
            ],
            "correct": "b",
            "explanation": "Modulo 10 gives the ones digit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "To remove the last digit of x:",
            "options": [
              {
                "id": "a",
                "text": "x // 10"
              },
              {
                "id": "b",
                "text": "x % 10"
              },
              {
                "id": "c",
                "text": "x - 10"
              },
              {
                "id": "d",
                "text": "x * 10"
              }
            ],
            "correct": "a",
            "explanation": "Integer division by 10 drops the last digit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "To add digit d to reversed number rev:",
            "options": [
              {
                "id": "a",
                "text": "rev + d"
              },
              {
                "id": "b",
                "text": "rev * 10 + d"
              },
              {
                "id": "c",
                "text": "rev * d + 10"
              },
              {
                "id": "d",
                "text": "d * 10 + rev"
              }
            ],
            "correct": "b",
            "explanation": "Shift existing digits left (multiply by 10), add new digit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "For 32-bit signed int, overflow if:",
            "options": [
              {
                "id": "a",
                "text": "rev > MAX / 10"
              },
              {
                "id": "b",
                "text": "rev == MAX / 10 and digit > 7"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "Only after multiplication"
              }
            ],
            "correct": "c",
            "explanation": "Must check BEFORE multiplying. If rev > MAX/10, rev*10 overflows. If rev == MAX/10, depends on digit.",
            "conceptId": "bit-manipulation"
          },
          {
            "type": "mcq",
            "question": "For negative x:",
            "options": [
              {
                "id": "a",
                "text": "Reverse separately, add negative sign"
              },
              {
                "id": "b",
                "text": "x % 10 gives negative remainder"
              },
              {
                "id": "c",
                "text": "Convert to positive, reverse, negate"
              },
              {
                "id": "d",
                "text": "B or C both work"
              }
            ],
            "correct": "d",
            "explanation": "In Python, -123 % 10 = 7 (weird). Better to track sign, work with absolute value.",
            "conceptId": "bit-manipulation"
          }
        ],
        "oneLiner": "Pop last digit (x % 10), push to result (rev * 10 + digit), remove from x (x // 10). Check overflow BEFORE each push.",
        "pattern": "Bit Manipulation",
        "keyInsight": "Pop digits from end (mod 10), push to result (multiply by 10). Check overflow before each push.",
        "timeComplexity": "O(log x)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "reverse integer",
          "bit-manipulation"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def reverse(x: int) -> int:\n    INT_MAX = 2**31 - 1\n    INT_MIN = -2**31\n    \n    sign = 1 if x >= 0 else -1\n    x = abs(x)\n    rev = 0\n    \n    while x:\n        digit = x % 10\n        x //= 10\n        \n        # Check overflow before push\n        if rev > INT_MAX // 10:\n            return 0\n        \n        rev = rev * 10 + digit\n    \n    rev *= sign\n    return rev if INT_MIN <= rev <= INT_MAX else 0"
      }
    ],
    "math-and-geometry": [
      {
        "id": "01-rotate-image",
        "slug": "rotate-image",
        "title": "Rotate Image",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "rotate-image"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.",
        "examples": [
          {
            "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
            "output": "[[7,4,1],[8,5,2],[9,6,3]]",
            "explanation": ""
          },
          {
            "input": "matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
            "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Transposing a matrix:",
            "options": [
              {
                "id": "a",
                "text": "Swaps rows and columns"
              },
              {
                "id": "b",
                "text": "Reverses rows"
              },
              {
                "id": "c",
                "text": "Reverses columns"
              },
              {
                "id": "d",
                "text": "Rotates 90°"
              }
            ],
            "correct": "a",
            "explanation": "Element at (i,j) goes to (j,i).",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After 90° clockwise, element at (i, j) goes to:",
            "options": [
              {
                "id": "a",
                "text": "(j, n-1-i)"
              },
              {
                "id": "b",
                "text": "(n-1-i, j)"
              },
              {
                "id": "c",
                "text": "(n-1-j, i)"
              },
              {
                "id": "d",
                "text": "(i, n-1-j)"
              }
            ],
            "correct": "a",
            "explanation": "Row i becomes column n-1-i. Column j becomes row j.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "90° clockwise rotation equals:",
            "options": [
              {
                "id": "a",
                "text": "Transpose only"
              },
              {
                "id": "b",
                "text": "Transpose + reverse rows"
              },
              {
                "id": "c",
                "text": "Reverse rows + transpose"
              },
              {
                "id": "d",
                "text": "Reverse columns only"
              }
            ],
            "correct": "b",
            "explanation": "Transpose swaps (i,j)->(j,i). Reversing rows of transpose gives 90° clockwise.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "In-place transpose swaps:",
            "options": [
              {
                "id": "a",
                "text": "matrix[i][j] with matrix[j][i]"
              },
              {
                "id": "b",
                "text": "matrix[i][j] with matrix[n-1-i][j]"
              },
              {
                "id": "c",
                "text": "matrix[i][j] with matrix[i][n-1-j]"
              },
              {
                "id": "d",
                "text": "All four corners"
              }
            ],
            "correct": "a",
            "explanation": "Only swap upper triangle with lower triangle.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For in-place transpose, we iterate:",
            "options": [
              {
                "id": "a",
                "text": "All (i, j) pairs"
              },
              {
                "id": "b",
                "text": "Only upper triangle (j > i)"
              },
              {
                "id": "c",
                "text": "Only diagonal"
              },
              {
                "id": "d",
                "text": "Only corners"
              }
            ],
            "correct": "b",
            "explanation": "Swapping all would swap twice (back to original). Only swap where j > i.",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "90° clockwise = Transpose + Reverse each row. Transpose swaps (i,j)<->(j,i). Both operations are in-place.",
        "pattern": "Math & Geometry",
        "keyInsight": "90° clockwise rotation = transpose + reverse each row.",
        "timeComplexity": "O(n²)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "rotate image",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def rotate(matrix: List[List[int]]) -> None:\n    n = len(matrix)\n    \n    # Step 1: Transpose (swap across diagonal)\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    # Step 2: Reverse each row\n    for i in range(n):\n        matrix[i].reverse()"
      },
      {
        "id": "02-spiral-matrix",
        "slug": "spiral-matrix",
        "title": "Spiral Matrix",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "spiral-matrix"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` matrix, return all elements of the matrix in spiral order.",
        "examples": [
          {
            "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
            "output": "[1,2,3,6,9,8,7,4,5]",
            "explanation": ""
          },
          {
            "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
            "output": "[1,2,3,4,8,12,11,10,9,5,6,7]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Spiral traversal order is:",
            "options": [
              {
                "id": "a",
                "text": "Left->Right, Top->Bottom, Right->Left, Bottom->Top"
              },
              {
                "id": "b",
                "text": "Top->Bottom, Left->Right, Bottom->Top, Right->Left"
              },
              {
                "id": "c",
                "text": "Random"
              },
              {
                "id": "d",
                "text": "Depends on matrix size"
              }
            ],
            "correct": "a",
            "explanation": "Start at top-left, go right, down, left, up, then repeat inward.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "We track:",
            "options": [
              {
                "id": "a",
                "text": "top, bottom, left, right"
              },
              {
                "id": "b",
                "text": "Only center"
              },
              {
                "id": "c",
                "text": "Only corners"
              },
              {
                "id": "d",
                "text": "Current position only"
              }
            ],
            "correct": "a",
            "explanation": "Four boundaries define the current \"ring\" to traverse.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After traversing top row (left to right):",
            "options": [
              {
                "id": "a",
                "text": "Decrement top"
              },
              {
                "id": "b",
                "text": "Increment top"
              },
              {
                "id": "c",
                "text": "Decrement left"
              },
              {
                "id": "d",
                "text": "Increment right"
              }
            ],
            "correct": "b",
            "explanation": "Top row is done. Next ring's top is one row lower.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Stop when:",
            "options": [
              {
                "id": "a",
                "text": "We've visited all elements"
              },
              {
                "id": "b",
                "text": "top > bottom or left > right"
              },
              {
                "id": "c",
                "text": "Boundaries reach center"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "Boundaries crossing means no more elements to process.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For single row or column:",
            "options": [
              {
                "id": "a",
                "text": "Need special handling"
              },
              {
                "id": "b",
                "text": "Boundaries naturally handle it"
              },
              {
                "id": "c",
                "text": "Will loop forever"
              },
              {
                "id": "d",
                "text": "Skip traversal"
              }
            ],
            "correct": "b",
            "explanation": "Boundary checks (top <= bottom, left <= right) handle degenerate cases.",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "Track four boundaries. Traverse right->down->left->up, shrinking boundaries after each direction. Stop when boundaries cross.",
        "pattern": "Math & Geometry",
        "keyInsight": "Track four boundaries (top, bottom, left, right). Process each edge, shrink boundary, repeat.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "spiral matrix",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def spiralOrder(matrix: List[List[int]]) -> List[int]:\n    if not matrix:\n        return []\n    \n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse right\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        # Traverse down\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        # Traverse left (if rows remain)\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        # Traverse up (if columns remain)\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result"
      },
      {
        "id": "03-set-matrix-zeroes",
        "slug": "set-matrix-zeroes",
        "title": "Set Matrix Zeroes",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "set-matrix-zeroes"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given an `m x n` integer matrix, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it in place.",
        "examples": [
          {
            "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
            "output": "[[1,0,1],[0,0,0],[1,0,1]]",
            "explanation": ""
          },
          {
            "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
            "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Why can't we zero cells immediately when we find a 0?",
            "options": [
              {
                "id": "a",
                "text": "We'd lose information about original zeros"
              },
              {
                "id": "b",
                "text": "Too slow"
              },
              {
                "id": "c",
                "text": "Matrix size unknown"
              },
              {
                "id": "d",
                "text": "No issue"
              }
            ],
            "correct": "a",
            "explanation": "New zeros would trigger more zeroing incorrectly. Need to mark first, then zero.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "We can use O(1) extra space by:",
            "options": [
              {
                "id": "a",
                "text": "Using first row/column as markers"
              },
              {
                "id": "b",
                "text": "Using diagonal"
              },
              {
                "id": "c",
                "text": "Using last row/column"
              },
              {
                "id": "d",
                "text": "Not possible"
              }
            ],
            "correct": "a",
            "explanation": "First row marks columns to zero. First column marks rows to zero.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "matrix[0][0] belongs to both first row and column. Handle by:",
            "options": [
              {
                "id": "a",
                "text": "Using a separate variable for row 0"
              },
              {
                "id": "b",
                "text": "Using a separate variable for col 0"
              },
              {
                "id": "c",
                "text": "Either A or B"
              },
              {
                "id": "d",
                "text": "No special handling"
              }
            ],
            "correct": "c",
            "explanation": "Need to separately track whether row 0 or col 0 should be zeroed.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After marking, we should fill zeros:",
            "options": [
              {
                "id": "a",
                "text": "From (0,0) to (m-1, n-1)"
              },
              {
                "id": "b",
                "text": "From (1,1) to (m-1, n-1), then first row/col"
              },
              {
                "id": "c",
                "text": "Randomly"
              },
              {
                "id": "d",
                "text": "First row/col first, then rest"
              }
            ],
            "correct": "b",
            "explanation": "Fill inner matrix first. If we zero first row/col early, we lose marker info.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "If matrix[0][j] = 0 after scanning:",
            "options": [
              {
                "id": "a",
                "text": "Column j should be zeroed"
              },
              {
                "id": "b",
                "text": "Row j should be zeroed"
              },
              {
                "id": "c",
                "text": "Cell (0,j) was originally 0 only"
              },
              {
                "id": "d",
                "text": "Nothing special"
              }
            ],
            "correct": "a",
            "explanation": "First row marks which columns to zero (either original 0 or 0 found below).",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "Use first row to mark columns, first column to mark rows. Handle row 0 separately. Fill inner cells, then first row/col.",
        "pattern": "Math & Geometry",
        "keyInsight": "Use first row and column as markers. Scan for zeros, mark in first row/col, then fill zeros.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "set matrix zeroes",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def setZeroes(matrix: List[List[int]]) -> None:\n    m, n = len(matrix), len(matrix[0])\n    first_row_zero = any(matrix[0][j] == 0 for j in range(n))\n    first_col_zero = any(matrix[i][0] == 0 for i in range(m))\n    \n    # Mark zeros in first row/col\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n    \n    # Fill zeros for inner matrix\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n    \n    # Handle first row/col\n    if first_row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n    if first_col_zero:\n        for i in range(m):\n            matrix[i][0] = 0"
      },
      {
        "id": "04-happy-number",
        "slug": "happy-number",
        "title": "Happy Number",
        "category": "math-and-geometry",
        "difficulty": "easy",
        "tags": [
          "math-and-geometry",
          "happy-number"
        ],
        "estimatedTime": 5,
        "problemStatement": "Write an algorithm to determine if a number `n` is happy.\n\nA happy number is a number defined by the following process:\n- Starting with any positive integer, replace the number by the sum of the squares of its digits.\n- Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n- Those numbers for which this process ends in 1 are happy.\n\nReturn `true` if `n` is a happy number, and `false` otherwise.",
        "examples": [
          {
            "input": "n = 19",
            "output": "true",
            "explanation": "1² + 9² = 82 -> 8² + 2² = 68 -> 6² + 8² = 100 -> 1² + 0² + 0² = 1"
          },
          {
            "input": "n = 2",
            "output": "false",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "The sequence must cycle or reach 1 because:",
            "options": [
              {
                "id": "a",
                "text": "Sum of digit squares has bounded values"
              },
              {
                "id": "b",
                "text": "Numbers keep decreasing"
              },
              {
                "id": "c",
                "text": "Random chance"
              },
              {
                "id": "d",
                "text": "Always reaches 1"
              }
            ],
            "correct": "a",
            "explanation": "For any number, digit-square-sum is bounded. Eventually repeats or hits 1.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "To detect cycle, we can use:",
            "options": [
              {
                "id": "a",
                "text": "Hash set to track seen numbers"
              },
              {
                "id": "b",
                "text": "Floyd's slow/fast pointers"
              },
              {
                "id": "c",
                "text": "Either"
              },
              {
                "id": "d",
                "text": "Neither"
              }
            ],
            "correct": "c",
            "explanation": "Hash set: check if seen. Floyd's: if slow meets fast, cycle exists.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "In Floyd's algorithm:",
            "options": [
              {
                "id": "a",
                "text": "Slow advances 1 step, fast advances 2"
              },
              {
                "id": "b",
                "text": "Both advance 1 step"
              },
              {
                "id": "c",
                "text": "Slow advances 2, fast advances 1"
              },
              {
                "id": "d",
                "text": "Both advance 2 steps"
              }
            ],
            "correct": "a",
            "explanation": "If there's a cycle, fast will \"lap\" slow and meet.",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "Number is happy if:",
            "options": [
              {
                "id": "a",
                "text": "Sequence reaches 1"
              },
              {
                "id": "b",
                "text": "Sequence cycles at any number"
              },
              {
                "id": "c",
                "text": "Sequence decreases"
              },
              {
                "id": "d",
                "text": "First digit becomes 0"
              }
            ],
            "correct": "a",
            "explanation": "Happy numbers eventually reach 1 and stay there (1->1).",
            "conceptId": "floyd-cycle"
          },
          {
            "type": "mcq",
            "question": "Number is NOT happy if:",
            "options": [
              {
                "id": "a",
                "text": "Sequence reaches 1"
              },
              {
                "id": "b",
                "text": "Slow meets fast (and not at 1)"
              },
              {
                "id": "c",
                "text": "Number seen before (and not 1)"
              },
              {
                "id": "d",
                "text": "B and C"
              }
            ],
            "correct": "d",
            "explanation": "Cycle detected that doesn't include 1 means it will loop forever.",
            "conceptId": "floyd-cycle"
          }
        ],
        "oneLiner": "Cycle detection: sequence either reaches 1 or cycles. Use hash set to detect repeats, or Floyd's fast/slow pointers.",
        "pattern": "Math & Geometry",
        "keyInsight": "This is cycle detection. Use Floyd's algorithm (slow/fast pointers) or a hash set.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)",
        "triggerWords": [
          "happy number",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def isHappy(n: int) -> bool:\n    def get_next(num):\n        total = 0\n        while num > 0:\n            digit = num % 10\n            total += digit * digit\n            num //= 10\n        return total\n    \n    # Floyd's cycle detection\n    slow = n\n    fast = get_next(n)\n    \n    while fast != 1 and slow != fast:\n        slow = get_next(slow)\n        fast = get_next(get_next(fast))\n    \n    return fast == 1"
      },
      {
        "id": "05-plus-one",
        "slug": "plus-one",
        "title": "Plus One",
        "category": "math-and-geometry",
        "difficulty": "easy",
        "tags": [
          "math-and-geometry",
          "plus-one"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
          {
            "input": "digits = [1,2,3]",
            "output": "[1,2,4]",
            "explanation": "123 + 1 = 124"
          },
          {
            "input": "digits = [4,3,2,1]",
            "output": "[4,3,2,2]",
            "explanation": ""
          },
          {
            "input": "digits = [9]",
            "output": "[1,0]",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "We add 1 starting from:",
            "options": [
              {
                "id": "a",
                "text": "Left (most significant digit)"
              },
              {
                "id": "b",
                "text": "Right (least significant digit)"
              },
              {
                "id": "c",
                "text": "Middle"
              },
              {
                "id": "d",
                "text": "Any position"
              }
            ],
            "correct": "b",
            "explanation": "Addition starts from rightmost digit (ones place).",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Carry occurs when:",
            "options": [
              {
                "id": "a",
                "text": "Digit is 0"
              },
              {
                "id": "b",
                "text": "Digit becomes 10 after adding"
              },
              {
                "id": "c",
                "text": "Digit is 9 before adding"
              },
              {
                "id": "d",
                "text": "B and C (same thing)"
              }
            ],
            "correct": "d",
            "explanation": "9 + 1 = 10. Set digit to 0, carry 1 to next position.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "If digit < 9:",
            "options": [
              {
                "id": "a",
                "text": "Increment and return immediately"
              },
              {
                "id": "b",
                "text": "Continue to next digit"
              },
              {
                "id": "c",
                "text": "Set to 0"
              },
              {
                "id": "d",
                "text": "Need to check carry"
              }
            ],
            "correct": "a",
            "explanation": "No carry will happen. Just increment and we're done.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For [9, 9, 9]:",
            "options": [
              {
                "id": "a",
                "text": "Result is [9, 9, 10]"
              },
              {
                "id": "b",
                "text": "Result is [1, 0, 0, 0]"
              },
              {
                "id": "c",
                "text": "Result is [0, 0, 0]"
              },
              {
                "id": "d",
                "text": "Overflow error"
              }
            ],
            "correct": "b",
            "explanation": "999 + 1 = 1000. Array grows by one element.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Array needs to grow when:",
            "options": [
              {
                "id": "a",
                "text": "Last digit is 9"
              },
              {
                "id": "b",
                "text": "First digit is 9"
              },
              {
                "id": "c",
                "text": "All digits are 9"
              },
              {
                "id": "d",
                "text": "Any digit is 9"
              }
            ],
            "correct": "c",
            "explanation": "Only when carry propagates all the way through.",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "From right: if digit < 9, increment and return. If 9, set to 0 and continue. If all 9s, prepend 1.",
        "pattern": "Math & Geometry",
        "keyInsight": "Simulate addition from right to left. Handle carry propagation.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "plus one",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def plusOne(digits: List[int]) -> List[int]:\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    \n    # All 9s case: [9,9,9] -> [1,0,0,0]\n    return [1] + digits"
      },
      {
        "id": "06-pow-x-n",
        "slug": "pow-x-n",
        "title": "Pow(x, n)",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "powx-n"
        ],
        "estimatedTime": 5,
        "problemStatement": "Implement `pow(x, n)`, which calculates `x` raised to the power `n` (i.e., `x^n`).",
        "examples": [
          {
            "input": "x = 2.00000, n = 10",
            "output": "1024.00000",
            "explanation": ""
          },
          {
            "input": "x = 2.10000, n = 3",
            "output": "9.26100",
            "explanation": ""
          },
          {
            "input": "x = 2.00000, n = -2",
            "output": "0.25000",
            "explanation": "2^-2 = 1/2^2 = 1/4 = 0.25"
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Computing x * x * ... * x (n times) is:",
            "options": [
              {
                "id": "a",
                "text": "O(1)"
              },
              {
                "id": "b",
                "text": "O(log n)"
              },
              {
                "id": "c",
                "text": "O(n)"
              },
              {
                "id": "d",
                "text": "O(n²)"
              }
            ],
            "correct": "c",
            "explanation": "n multiplications for x^n. Too slow for large n.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "x^10 can be computed as:",
            "options": [
              {
                "id": "a",
                "text": "x * x^9"
              },
              {
                "id": "b",
                "text": "(x^5)^2"
              },
              {
                "id": "c",
                "text": "(x^2)^5"
              },
              {
                "id": "d",
                "text": "All of above"
              }
            ],
            "correct": "d",
            "explanation": "All are mathematically equivalent. (x^5)² uses fewer multiplications.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For even n, x^n = ?",
            "options": [
              {
                "id": "a",
                "text": "x * x^(n-1)"
              },
              {
                "id": "b",
                "text": "(x^(n/2))²"
              },
              {
                "id": "c",
                "text": "x² * x^(n-2)"
              },
              {
                "id": "d",
                "text": "Any of above"
              }
            ],
            "correct": "b",
            "explanation": "Halves the problem size immediately.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For odd n, x^n = ?",
            "options": [
              {
                "id": "a",
                "text": "x * x^(n-1)"
              },
              {
                "id": "b",
                "text": "(x^(n/2))²"
              },
              {
                "id": "c",
                "text": "x * (x^((n-1)/2))²"
              },
              {
                "id": "d",
                "text": "A or C"
              }
            ],
            "correct": "d",
            "explanation": "Make it even by extracting one x, then apply even rule.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "For negative n, x^n = ?",
            "options": [
              {
                "id": "a",
                "text": "-x^n"
              },
              {
                "id": "b",
                "text": "1/x^n"
              },
              {
                "id": "c",
                "text": "x^(-n)"
              },
              {
                "id": "d",
                "text": "x/n"
              }
            ],
            "correct": "b",
            "explanation": "x^(-n) = 1/(x^n). Compute positive power, take reciprocal.",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "Binary exponentiation: halve exponent each step. Even n: (x²)^(n/2). Odd n: x * (x²)^((n-1)/2). O(log n) multiplications.",
        "pattern": "Math & Geometry",
        "keyInsight": "Binary exponentiation: x^n = (x^(n/2))^2 for even n, x * x^(n-1) for odd n.",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(log n)",
        "triggerWords": [
          "pow(x, n)",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def myPow(x: float, n: int) -> float:\n    if n < 0:\n        x = 1 / x\n        n = -n\n    \n    result = 1\n    while n > 0:\n        if n % 2 == 1:  # Odd\n            result *= x\n        x *= x\n        n //= 2\n    \n    return result"
      },
      {
        "id": "07-multiply-strings",
        "slug": "multiply-strings",
        "title": "Multiply Strings",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "multiply-strings"
        ],
        "estimatedTime": 5,
        "problemStatement": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.",
        "examples": [
          {
            "input": "num1 = \"2\", num2 = \"3\"",
            "output": "\"6\"",
            "explanation": ""
          },
          {
            "input": "num1 = \"123\", num2 = \"456\"",
            "output": "\"56088\"",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "Product of m-digit and n-digit numbers has at most:",
            "options": [
              {
                "id": "a",
                "text": "m + n digits"
              },
              {
                "id": "b",
                "text": "m * n digits"
              },
              {
                "id": "c",
                "text": "max(m, n) digits"
              },
              {
                "id": "d",
                "text": "m + n - 1 digits"
              }
            ],
            "correct": "a",
            "explanation": "Maximum is when 999...9 × 999...9 which has m+n digits.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "num1[i] * num2[j] contributes to positions:",
            "options": [
              {
                "id": "a",
                "text": "i and j"
              },
              {
                "id": "b",
                "text": "i + j and i + j + 1"
              },
              {
                "id": "c",
                "text": "i * j only"
              },
              {
                "id": "d",
                "text": "0 and 1 only"
              }
            ],
            "correct": "b",
            "explanation": "Digit at position i has value × 10^(n1-1-i). Product at positions i+j, i+j+1 in result.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "We process digits:",
            "options": [
              {
                "id": "a",
                "text": "Left to right"
              },
              {
                "id": "b",
                "text": "Right to left for both"
              },
              {
                "id": "c",
                "text": "Left to right for num1, right to left for num2"
              },
              {
                "id": "d",
                "text": "Any order"
              }
            ],
            "correct": "b",
            "explanation": "Rightmost digits are ones place. Process like manual multiplication.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "After accumulating at result[i+j+1]:",
            "options": [
              {
                "id": "a",
                "text": "Immediately propagate carry"
              },
              {
                "id": "b",
                "text": "Handle all carries at the end"
              },
              {
                "id": "c",
                "text": "Either works"
              },
              {
                "id": "d",
                "text": "No carry needed"
              }
            ],
            "correct": "c",
            "explanation": "Can accumulate all products first, then handle carries. Or propagate immediately.",
            "conceptId": "sorting"
          },
          {
            "type": "mcq",
            "question": "Leading zeros in result:",
            "options": [
              {
                "id": "a",
                "text": "Should be kept"
              },
              {
                "id": "b",
                "text": "Should be removed"
              },
              {
                "id": "c",
                "text": "Don't exist"
              },
              {
                "id": "d",
                "text": "Cause errors"
              }
            ],
            "correct": "b",
            "explanation": "\"00123\" should become \"123\". Handle edge case of \"0\".",
            "conceptId": "sorting"
          }
        ],
        "oneLiner": "Like manual multiplication: num1[i] × num2[j] goes to result[i+j] and result[i+j+1]. Handle carries, remove leading zeros.",
        "pattern": "Math & Geometry",
        "keyInsight": "Product of digits at positions i and j contributes to position i+j and i+j+1.",
        "timeComplexity": "O(m × n)",
        "spaceComplexity": "O(m + n)",
        "triggerWords": [
          "multiply strings",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "def multiply(num1: str, num2: str) -> str:\n    if num1 == \"0\" or num2 == \"0\":\n        return \"0\"\n    \n    m, n = len(num1), len(num2)\n    result = [0] * (m + n)\n    \n    # Multiply each digit pair\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            prod = int(num1[i]) * int(num2[j])\n            p1, p2 = i + j, i + j + 1\n            \n            total = prod + result[p2]\n            result[p2] = total % 10\n            result[p1] += total // 10\n    \n    # Convert to string, skip leading zeros\n    result_str = ''.join(map(str, result)).lstrip('0')\n    return result_str if result_str else \"0\""
      },
      {
        "id": "08-detect-squares",
        "slug": "detect-squares",
        "title": "Detect Squares",
        "category": "math-and-geometry",
        "difficulty": "medium",
        "tags": [
          "math-and-geometry",
          "detect-squares"
        ],
        "estimatedTime": 5,
        "problemStatement": "You are given a stream of points on the X-Y plane. Design an algorithm that:\n\n- **Adds** new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.\n- Given a query point, **counts** the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.\n\nAn axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.",
        "examples": [
          {
            "input": "nums = [1,2,3]",
            "output": "result",
            "explanation": ""
          }
        ],
        "relatedProblems": [],
        "steps": [
          {
            "type": "mcq",
            "question": "For axis-aligned square, edges must be:",
            "options": [
              {
                "id": "a",
                "text": "Any direction"
              },
              {
                "id": "b",
                "text": "Parallel/perpendicular to axes"
              },
              {
                "id": "c",
                "text": "At 45° angles"
              },
              {
                "id": "d",
                "text": "Variable length"
              }
            ],
            "correct": "b",
            "explanation": "\"Axis-aligned\" means sides are horizontal and vertical.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Given two diagonal corners (x1, y1) and (x2, y2), the other two are:",
            "options": [
              {
                "id": "a",
                "text": "(x1, y2) and (x2, y1)"
              },
              {
                "id": "b",
                "text": "((x1+x2)/2, (y1+y2)/2)"
              },
              {
                "id": "c",
                "text": "(x1+1, y1+1) and (x2+1, y2+1)"
              },
              {
                "id": "d",
                "text": "Random points"
              }
            ],
            "correct": "a",
            "explanation": "For axis-aligned square, diagonal corners share no coordinates. Other two share one with each.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "(x1, y1) and (x2, y2) form square diagonal if:",
            "options": [
              {
                "id": "a",
                "text": "|x1 - x2| == |y1 - y2| != 0"
              },
              {
                "id": "b",
                "text": "x1 == x2 or y1 == y2"
              },
              {
                "id": "c",
                "text": "|x1 - x2| + |y1 - y2| == constant"
              },
              {
                "id": "d",
                "text": "Any two points work"
              }
            ],
            "correct": "a",
            "explanation": "Square has equal side lengths. Diagonal implies equal x and y distances.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "To count squares for query point p:",
            "options": [
              {
                "id": "a",
                "text": "Check all pairs of points"
              },
              {
                "id": "b",
                "text": "For each point on same x or y, check diagonal"
              },
              {
                "id": "c",
                "text": "Random sampling"
              },
              {
                "id": "d",
                "text": "Brute force all triplets"
              }
            ],
            "correct": "b",
            "explanation": "Fix one dimension (same x or same y), other corners are determined.",
            "conceptId": "hash-map"
          },
          {
            "type": "mcq",
            "question": "Duplicate points should:",
            "options": [
              {
                "id": "a",
                "text": "Be ignored"
              },
              {
                "id": "b",
                "text": "Increase square count"
              },
              {
                "id": "c",
                "text": "Cause errors"
              },
              {
                "id": "d",
                "text": "Replace old point"
              }
            ],
            "correct": "b",
            "explanation": "Multiple copies of a point can form multiple squares with same corners.",
            "conceptId": "hash-map"
          }
        ],
        "oneLiner": "For query point, check points with same x (or y). Calculate side length, check if the other two corners exist. Multiply counts for duplicates.",
        "pattern": "Math & Geometry",
        "keyInsight": "Fix query point as one corner. For each point with same x, compute potential square corners. Check if both exist.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)",
        "triggerWords": [
          "detect squares",
          "math-and-geometry"
        ],
        "relatedPatterns": [],
        "pythonSolution": "class DetectSquares:\n    def __init__(self):\n        self.points = defaultdict(int)\n        self.x_points = defaultdict(list)  # x -> list of y values\n    \n    def add(self, point: List[int]) -> None:\n        x, y = point\n        self.points[(x, y)] += 1\n        self.x_points[x].append(y)\n    \n    def count(self, point: List[int]) -> int:\n        x1, y1 = point\n        result = 0\n        \n        # For each point with same x, try to form square\n        for y2 in self.x_points[x1]:\n            if y2 == y1:\n                continue\n            \n            side = abs(y2 - y1)\n            \n            # Check two possible squares (left and right)\n            for x2 in [x1 + side, x1 - side]:\n                count1 = self.points[(x2, y1)]\n                count2 = self.points[(x2, y2)]\n                result += count1 * count2\n        \n        return result"
      }
    ]
  },
  "comparisons": [
    {
      "pattern1": "sliding-window",
      "pattern2": "two-pointers",
      "title": "Sliding Window vs Two Pointers"
    },
    {
      "pattern1": "bfs",
      "pattern2": "dfs",
      "title": "BFS vs DFS"
    },
    {
      "pattern1": "dynamic-programming",
      "pattern2": "greedy",
      "title": "Dynamic Programming vs Greedy"
    },
    {
      "pattern1": "hash-map",
      "pattern2": "hash-set",
      "title": "Hash Map vs Hash Set"
    },
    {
      "pattern1": "memoization",
      "pattern2": "tabulation",
      "title": "Memoization vs Tabulation"
    },
    {
      "pattern1": "recursion",
      "pattern2": "iteration",
      "title": "Recursion vs Iteration"
    },
    {
      "pattern1": "dijkstra",
      "pattern2": "bfs",
      "title": "Dijkstra's vs BFS"
    },
    {
      "pattern1": "stack",
      "pattern2": "queue",
      "title": "Stack vs Queue"
    },
    {
      "pattern1": "binary-search",
      "pattern2": "linear-search",
      "title": "Binary Search vs Linear Search"
    },
    {
      "pattern1": "inorder",
      "pattern2": "preorder",
      "title": "Inorder vs Preorder Traversal"
    },
    {
      "pattern1": "1d-dp",
      "pattern2": "2d-dp",
      "title": "1D DP vs 2D DP"
    },
    {
      "pattern1": "top-down",
      "pattern2": "bottom-up",
      "title": "Top-Down vs Bottom-Up DP"
    },
    {
      "pattern1": "heap",
      "pattern2": "sorted-array",
      "title": "Heap vs Sorted Array"
    },
    {
      "pattern1": "trie",
      "pattern2": "hash-map",
      "title": "Trie vs Hash Map for Strings"
    },
    {
      "pattern1": "union-find",
      "pattern2": "dfs",
      "title": "Union-Find vs DFS for Connectivity"
    },
    {
      "pattern1": "backtracking",
      "pattern2": "dynamic-programming",
      "title": "Backtracking vs Dynamic Programming"
    },
    {
      "pattern1": "kadane",
      "pattern2": "brute-force",
      "title": "Kadane's Algorithm vs Brute Force"
    },
    {
      "pattern1": "floyd-cycle",
      "pattern2": "hash-set",
      "title": "Floyd Cycle Detection vs Hash Set"
    },
    {
      "pattern1": "monotonic-stack",
      "pattern2": "brute-force",
      "title": "Monotonic Stack vs Brute Force"
    },
    {
      "pattern1": "prefix-sum",
      "pattern2": "brute-force",
      "title": "Prefix Sum vs Brute Force"
    },
    {
      "pattern1": "merge-sort",
      "pattern2": "quick-sort",
      "title": "Merge Sort vs Quick Sort"
    },
    {
      "pattern1": "array",
      "pattern2": "linked-list",
      "title": "Array vs Linked List"
    },
    {
      "pattern1": "adjacency-list",
      "pattern2": "adjacency-matrix",
      "title": "Adjacency List vs Matrix"
    },
    {
      "pattern1": "bst",
      "pattern2": "hash-map",
      "title": "BST vs Hash Map"
    },
    {
      "pattern1": "topological-sort",
      "pattern2": "dfs",
      "title": "Topological Sort vs DFS"
    },
    {
      "pattern1": "prims",
      "pattern2": "kruskals",
      "title": "Prim's vs Kruskal's Algorithm"
    },
    {
      "pattern1": "bellman-ford",
      "pattern2": "dijkstra",
      "title": "Bellman-Ford vs Dijkstra's"
    },
    {
      "pattern1": "counting-sort",
      "pattern2": "comparison-sort",
      "title": "Counting Sort vs Comparison Sort"
    },
    {
      "pattern1": "sliding-window-fixed",
      "pattern2": "sliding-window-variable",
      "title": "Fixed vs Variable Sliding Window"
    },
    {
      "pattern1": "fast-slow-pointers",
      "pattern2": "two-pointers",
      "title": "Fast-Slow Pointers vs Two Pointers"
    }
  ],
  "triggerWords": {
    "arrays-and-hashing": [
      "contains duplicate",
      "arrays-and-hashing",
      "valid anagram",
      "two sum",
      "group anagrams",
      "top k frequent elements",
      "product of array except self",
      "valid sudoku",
      "longest consecutive sequence"
    ],
    "two-pointers": [
      "valid palindrome",
      "two-pointers",
      "two sum ii - input array is sorted",
      "3sum",
      "container with most water",
      "trapping rain water"
    ],
    "stack": [
      "valid parentheses",
      "stack",
      "min stack",
      "evaluate reverse polish notation",
      "generate parentheses",
      "daily temperatures",
      "car fleet",
      "largest rectangle in histogram"
    ],
    "sliding-window": [
      "best time to buy and sell stock",
      "sliding-window",
      "longest substring without repeating characters",
      "longest repeating character replacement",
      "permutation in string",
      "minimum window substring",
      "sliding window maximum"
    ],
    "binary-search": [
      "binary search",
      "binary-search",
      "search a 2d matrix",
      "koko eating bananas",
      "search in rotated sorted array",
      "find minimum in rotated sorted array",
      "time based key-value store",
      "median of two sorted arrays"
    ],
    "linked-list": [
      "reverse linked list",
      "linked-list",
      "merge two sorted lists",
      "linked list cycle",
      "reorder list",
      "remove nth node from end of list",
      "copy list with random pointer",
      "merge k sorted lists",
      "reverse nodes in k-group"
    ],
    "trees": [
      "invert binary tree",
      "trees",
      "maximum depth of binary tree",
      "validate binary search tree",
      "lowest common ancestor of a binary search tree",
      "binary tree level order traversal",
      "binary tree right side view",
      "serialize and deserialize binary tree",
      "binary tree maximum path sum"
    ],
    "tries": [
      "implement trie (prefix tree)",
      "tries",
      "design add and search words data structure",
      "word search ii"
    ],
    "backtracking": [
      "subsets",
      "backtracking",
      "combination sum",
      "permutations",
      "subsets ii",
      "combination sum ii",
      "word search",
      "palindrome partitioning",
      "n-queens"
    ],
    "heap": [
      "kth largest element in a stream",
      "heap",
      "last stone weight",
      "k closest points to origin",
      "kth largest element in an array",
      "task scheduler",
      "design twitter",
      "find median from data stream"
    ],
    "graphs": [
      "number of islands",
      "graphs",
      "clone graph",
      "pacific atlantic water flow",
      "course schedule",
      "course schedule ii",
      "rotting oranges",
      "surrounded regions",
      "graph valid tree"
    ],
    "advanced-graphs": [
      "min cost to connect all points",
      "advanced-graphs",
      "network delay time",
      "swim in rising water",
      "alien dictionary",
      "cheapest flights within k stops",
      "reconstruct itinerary"
    ],
    "1d-dp": [
      "climbing stairs",
      "1d-dp",
      "min cost climbing stairs",
      "house robber",
      "house robber ii",
      "longest palindromic substring",
      "palindromic substrings",
      "decode ways",
      "word break"
    ],
    "2d-dp": [
      "unique paths",
      "2d-dp",
      "longest common subsequence",
      "best time to buy and sell stock with cooldown",
      "coin change ii",
      "target sum",
      "interleaving string",
      "edit distance",
      "burst balloons"
    ],
    "greedy": [
      "maximum subarray",
      "greedy",
      "jump game",
      "jump game ii",
      "gas station",
      "hand of straights",
      "merge triplets to form target triplet",
      "partition labels",
      "valid parenthesis string"
    ],
    "intervals": [
      "insert interval",
      "intervals",
      "merge intervals",
      "non-overlapping intervals",
      "meeting rooms",
      "meeting rooms ii",
      "minimum interval to include each query"
    ],
    "bit-manipulation": [
      "single number",
      "bit-manipulation",
      "number of 1 bits",
      "counting bits",
      "reverse bits",
      "missing number",
      "sum of two integers",
      "reverse integer"
    ],
    "math-and-geometry": [
      "rotate image",
      "math-and-geometry",
      "spiral matrix",
      "set matrix zeroes",
      "happy number",
      "plus one",
      "pow(x, n)",
      "multiply strings",
      "detect squares"
    ]
  },
  "difficultyStats": {
    "arrays-and-hashing": {
      "easy": 8,
      "medium": 0,
      "hard": 0
    },
    "two-pointers": {
      "easy": 5,
      "medium": 0,
      "hard": 0
    },
    "stack": {
      "easy": 0,
      "medium": 7,
      "hard": 0
    },
    "sliding-window": {
      "easy": 0,
      "medium": 6,
      "hard": 0
    },
    "binary-search": {
      "easy": 0,
      "medium": 7,
      "hard": 0
    },
    "linked-list": {
      "easy": 0,
      "medium": 8,
      "hard": 0
    },
    "trees": {
      "easy": 0,
      "medium": 8,
      "hard": 0
    },
    "tries": {
      "easy": 0,
      "medium": 3,
      "hard": 0
    },
    "backtracking": {
      "easy": 0,
      "medium": 0,
      "hard": 8
    },
    "heap": {
      "easy": 0,
      "medium": 0,
      "hard": 7
    },
    "graphs": {
      "easy": 0,
      "medium": 8,
      "hard": 0
    },
    "advanced-graphs": {
      "easy": 0,
      "medium": 0,
      "hard": 6
    },
    "1d-dp": {
      "easy": 2,
      "medium": 6,
      "hard": 0
    },
    "2d-dp": {
      "easy": 0,
      "medium": 7,
      "hard": 1
    },
    "greedy": {
      "easy": 0,
      "medium": 8,
      "hard": 0
    },
    "intervals": {
      "easy": 1,
      "medium": 4,
      "hard": 1
    },
    "bit-manipulation": {
      "easy": 5,
      "medium": 2,
      "hard": 0
    },
    "math-and-geometry": {
      "easy": 2,
      "medium": 6,
      "hard": 0
    }
  },
  "meta": {
    "generatedAt": "2025-12-24T04:05:11.022Z",
    "totalProblems": 126,
    "selectedProblems": 126,
    "categoryCount": 18,
    "comparisonCount": 30
  }
}